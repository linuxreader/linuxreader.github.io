![](images/cover.jpeg)

[]{#titlepage.xhtml}

::: {}
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="100%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 900 1130" width="100%">
`<image height="1130" width="900" xlink:href="cover.jpeg">`{=html}`</image>`{=html}
</svg>
:::

[]{#ifm.html}

# Inside front cover {#ifm.html_heading_id_2 .tochead}

Podman and Docker feature comparison

+-----------------+---------------+---------------+--------------------------------------+
| Feature         | Podman        | Docker        | Description                          |
+=================+===============+===============+======================================+
| Supports all    | [✔]{.cambria} | [✔]{.cambria} | Both pull and run container images   |
| OCI and Docker  |               |               | from container registries (i.e.,     |
| images          |               |               | quay.io and docker.io)               |
+-----------------+---------------+---------------+--------------------------------------+
| Launches OCI    | [✔]{.cambria} | [✔]{.cambria} | Launch containers using runc, crun,  |
| container       |               |               | Kata, gVisor, and OCI container      |
| engines         |               |               | engines                              |
+-----------------+---------------+---------------+--------------------------------------+
| Simple          | [✔]{.cambria} | [✔]{.cambria} | Podman and Docker share the same     |
| command-line    |               |               | CLI.                                 |
| interface       |               |               |                                      |
+-----------------+---------------+---------------+--------------------------------------+
| Integration     | [✔]{.cambria} | [✘]{.cambria} | Podman supports running systemd      |
| with systemd    |               |               | inside of the container as well as   |
|                 |               |               | many systemd features.               |
+-----------------+---------------+---------------+--------------------------------------+
| Fork/exec model | [✔]{.cambria} | [✘]{.cambria} | The container is a direct descendant |
|                 |               |               | of the podman command.               |
+-----------------+---------------+---------------+--------------------------------------+
| Fully support   | [✔]{.cambria} | [✘]{.cambria} | Only Podman supports running         |
| user namespace  |               |               | containers in separate user          |
|                 |               |               | namespaces.                          |
+-----------------+---------------+---------------+--------------------------------------+
| Client--server  | [✔]{.cambria} | [✔]{.cambria} | Docker is a RESTful API daemon.      |
| model           |               |               | Podman supports RESTful API via a    |
|                 |               |               | systemd socket=activated service.    |
+-----------------+---------------+---------------+--------------------------------------+
| Supports        | [✔]{.cambria} | [✔]{.cambria} | compose scripts work against both    |
| dockercompose   |               |               | restful APIs. Podman[']{.calibre6}s  |
|                 |               |               | works in rootless mode.              |
+-----------------+---------------+---------------+--------------------------------------+
| Supports        | [✔]{.cambria} | [✔]{.cambria} | docker-py python bindings work       |
| docker-py       |               |               | against both restful APIs. Podman's  |
|                 |               |               | works in rootless mode. Podman also  |
|                 |               |               | supports podman-py for running       |
|                 |               |               | advanced features.                   |
+-----------------+---------------+---------------+--------------------------------------+
| Daemonless      | [✔]{.cambria} | [✘]{.cambria} | The podman command runs like a       |
|                 |               |               | traditional command-line tool, while |
|                 |               |               | Docker requires multiple             |
|                 |               |               | root-running daemons.                |
+-----------------+---------------+---------------+--------------------------------------+
| Supports        | [✔]{.cambria} | [✘]{.cambria} | Podman supports running multiple     |
| Kubernetes-like |               |               | containers within the same pod.      |
| pods            |               |               |                                      |
+-----------------+---------------+---------------+--------------------------------------+
| Supports        | [✔]{.cambria} | [✘]{.cambria} | Podman can launch containers and     |
| Kubernetes yaml |               |               | pods based on Kubernetes yaml. It    |
|                 |               |               | can also generate Kuberenetes.yaml   |
|                 |               |               | from running containers.             |
+-----------------+---------------+---------------+--------------------------------------+
| Supports Docker | [✘]{.cambria} | [✔]{.cambria} | Podman believes the future for       |
| swarm           |               |               | orchestrated multi-node containers   |
|                 |               |               | is Kubernetes and does not plan on   |
|                 |               |               | implementing Swarm.                  |
+-----------------+---------------+---------------+--------------------------------------+
| Customizable    | [✔]{.cambria} | [✘]{.cambria} | Podman allows you to configure       |
| registries      |               |               | registries for short name expansion. |
|                 |               |               | Docker is hard coded to docker.io    |
|                 |               |               | when you specify a short name.       |
+-----------------+---------------+---------------+--------------------------------------+
| Customizable    | [✔]{.cambria} | [✘]{.cambria} | Podman supports fully customizing    |
| defaults        |               |               | all of its defaults including        |
|                 |               |               | security, namespaces, volumes, and   |
|                 |               |               | more.                                |
+-----------------+---------------+---------------+--------------------------------------+
| Mac OS support  | [✔]{.cambria} | [✔]{.cambria} | Podman and Docker support running    |
|                 |               |               | containers on a Mac via a VM running |
|                 |               |               | Linux.                               |
+-----------------+---------------+---------------+--------------------------------------+
| Windows support | [✔]{.cambria} | [✔]{.cambria} | Podman and Docker support running    |
|                 |               |               | containers on a Windows WSL2 or a VM |
|                 |               |               | running Linux.                       |
+-----------------+---------------+---------------+--------------------------------------+
| Linux support   | [✔]{.cambria} | [✔]{.cambria} | Podman and Docker are supported on   |
|                 |               |               | all major Linux distributions.       |
+-----------------+---------------+---------------+--------------------------------------+

[]{#title.htm}

  

![](images/Manning_copyright.png){.calibre7}

 

 

# Podman in Action {#title.htm_heading_id_2 .copyrighta}

[]{#title.htm_pgfId-1002085} Secure, rootless containers for Kubernetes,
microservices, and more

 

[]{#title.htm_pgfId-1002087}Daniel Walsh

 

`<!--<p class="copyrightc2">Foreword by _______________</p>-->`{=html}

 

To comment go to
[liveBook](https://livebook.manning.com/#!/book/podman-in-action/discussion){.index}

 

 

![](images/Manning_M_small.png){.calibre8}

Manning

Shelter Island

 

For more information on this and other Manning titles go to

[www.manning.com](https://www.manning.com/){.index}

 

[]{#copyright.htm}

# Copyright {#copyright.htm_heading_id_2 .copyright}

For online information and ordering of these  and other Manning books,
please visit [www.manning.com](https://www.manning.com/){.index}. The
publisher offers discounts on these books when ordered in quantity.

For more information, please contact

 

Special Sales Department

Manning Publications Co.

20 Baldwin Road

PO Box 761

Shelter Island, NY 11964

Email: [orders@manning.com](mailto:orders@manning.com){.url}

 

©2023 by Manning Publications Co. All rights reserved.

 

No part of this publication may be reproduced, stored in a retrieval
system, or transmitted, in any form or by means electronic, mechanical,
photocopying, or otherwise, without prior written permission of the
publisher.

Many of the designations used by manufacturers and sellers to
distinguish their products are claimed as trademarks. Where those
designations appear in the book, and Manning Publications was aware of a
trademark claim, the designations have been printed in initial caps or
all caps.

[♾]{.segoe} Recognizing the importance of preserving what has been
written, it is Manning's policy to have the books we publish printed on
acid-free paper, and we exert our best efforts to that end. Recognizing
also our responsibility to conserve the resources of our planet, Manning
books are printed on paper that is at least 15 percent recycled and
processed without the use of elemental chlorine.

 

+--------------------------------------------------------------+-----------------------------------+
| ![](images/Manning_M_small.png){.calibre14}     | Manning Publications Co.          |
|                                                              |                                   |
|                                                              | 20 Baldwin Road Technical         |
|                                                              |                                   |
|                                                              | PO Box 761                        |
|                                                              |                                   |
|                                                              | Shelter Island, NY 11964          |
+--------------------------------------------------------------+-----------------------------------+

 

+-----------------------------------+-----------------------------------+
| Development editor:               | Toni Arritola                     |
+-----------------------------------+-----------------------------------+
| Technical development editor:     | Joshua White                      |
+-----------------------------------+-----------------------------------+
| Technical editor:                 | Roman Zhuzha                      |
+-----------------------------------+-----------------------------------+
| Review editor:                    | Aleksandar Dragosavljević         |
+-----------------------------------+-----------------------------------+
| Production editor:                | Andy Marinkovich                  |
+-----------------------------------+-----------------------------------+
| Copy editor:                      | Christian Berk                    |
+-----------------------------------+-----------------------------------+
| Proofreader:                      | Katie Tennant                     |
+-----------------------------------+-----------------------------------+
| Technical proofreader:            | Alain Lompo                       |
+-----------------------------------+-----------------------------------+
| Typesetter:                       | Dennis Dalinnik                   |
+-----------------------------------+-----------------------------------+
| Cover designer:                   | Marija Tudor                      |
+-----------------------------------+-----------------------------------+

 

ISBN: 9781633439689

[]{#dedication.htm}

# dedication {#dedication.htm_heading_id_2 .tochead}

In memory of my mother, Joan P. Walsh

[]{#btoc.htm}

# []{#btoc.htm_pgfId-96982}brief contents {#btoc.htm_heading_id_2 .tochead}

    

Part 1.
[]{#btoc.htm_pgfId-96438}[Foundations](#p1.htm_pgfId-1014486){.index}

  1 []{#btoc.htm_pgfId-96394}[Podman: A next-generation container
engine](../Text/01.htm){.index}

  2 []{#btoc.htm_pgfId-96440}[Command
line](#02.htm_pgfId-1037520){.index}

  3 []{#btoc.htm_pgfId-96492}[Volumes](../Text/03.htm){.index}

  4 []{#btoc.htm_pgfId-96504}[Pods](../Text/04.htm){.index}

Part 2. []{#btoc.htm_pgfId-96522}[Design](#p2.htm_pgfId-1015382){.index}

  5 []{#btoc.htm_pgfId-96524}[Customization and configuration
files](#05.htm_pgfId-1105485){.index}

  6 []{#btoc.htm_pgfId-96542}[Rootless
containers](#06.htm_pgfId-1110284){.index}

Part 3. []{#btoc.htm_pgfId-96564}[Advanced
topics](#p3.htm_pgfId-1016261){.index}

  7 []{#btoc.htm_pgfId-96566}[Integration with
systemd](#07.htm_pgfId-1110285){.index}

  8 []{#btoc.htm_pgfId-96600}[Working with
Kubernetes](#08.htm_pgfId-1118668){.index}

  9 []{#btoc.htm_pgfId-96620}[Podman as a
service](#09.htm_pgfId-1109409){.index}

Part 4. []{#btoc.htm_pgfId-96650}[Container
security](#p4.htm_pgfId-1017166){.index}

10 []{#btoc.htm_pgfId-96652}[Security container
isolation](#10.htm_pgfId-1114067){.index}

11 []{#btoc.htm_pgfId-96704}[Additional security
considerations](#11.htm_pgfId-1121652){.index}

  

Appendix A. []{#btoc.htm_pgfId-96730}[Podman-related container
tools](#A.htm_pgfId-1277653){.index}

Appendix B. []{#btoc.htm_pgfId-96756}[OCI
runtimes](#B.htm_pgfId-1282814){.index}

Appendix C. []{#btoc.htm_pgfId-96766}[Getting
Podman](#C.htm_pgfId-1284762){.index}

Appendix D. []{#btoc.htm_pgfId-96804}[Contributing to
Podman](#D.htm_pgfId-1286422){.index}

Appendix E. []{#btoc.htm_pgfId-96810}[Podman on
macOS](#E.htm_pgfId-1286423){.index}

Appendix F. []{#btoc.htm_pgfId-96824}[Podman on
Windows](#F.htm_pgfId-1289586){.index}

\

[]{#toc.htm}

# []{#toc.htm_pgfId-96982}contents {#toc.htm_heading_id_2 .tochead}

  

[]{#toc.htm_pgfId-96374}[Front matter](../Text/fm.htm){.index}

[preface](#fm.htm_pgfId-1113482){.index}

[]{#toc.htm_pgfId-96376}[acknowledgments](#fm.htm_pgfId-1113486){.index}

[]{#toc.htm_pgfId-96378}[about this book](#fm.htm_pgfId-1113491){.index}

[]{#toc.htm_pgfId-96390}[about the
author](#fm.htm_pgfId-1113530){.index}

[]{#toc.htm_pgfId-96392}[about the cover
illustration](#fm.htm_pgfId-1113536){.index}

  

Part 1.
[]{#toc.htm_pgfId-96438}[Foundations](#p1.htm_pgfId-1014486){.index}

  1 []{#toc.htm_pgfId-96394}[Podman: A next-generation container
engine](../Text/01.htm){.index}

  []{#toc.htm_pgfId-96396}1.1   [About all these
terms](#01.htm_pgfId-1031531){.index}

  []{#toc.htm_pgfId-96398}1.2   [A brief overview of
containers](#01.htm_pgfId-1031591){.index}

[]{#toc.htm_pgfId-96400}[Container images: A new way to ship
software](#01.htm_pgfId-1031664){.index}

[Container images lead to microservices](#01.htm_pgfId-1031688){.index}

[Container image format](#01.htm_pgfId-1031712){.index}

[Container standards](#01.htm_pgfId-1031793){.index}

  []{#toc.htm_pgfId-96408}1.3   [Why use Podman when you have
Docker?](#01.htm_pgfId-1031807){.index}

[]{#toc.htm_pgfId-96410}[Why have only one way to run
containers?](#01.htm_pgfId-1031810){.index}

[Rootless containers](#01.htm_pgfId-1031982){.index}

[Fork/exec model](#01.htm_pgfId-1032001){.index}

[Podman is daemonless](#01.htm_pgfId-1032026){.index}

[User-friendly command line](#01.htm_pgfId-1032034){.index}

[Support for REST API](#01.htm_pgfId-1032052){.index}

[Integration with systemd](#01.htm_pgfId-1032061){.index}

[Pods](#01.htm_pgfId-1032083){.index}

[Customizable registries](#01.htm_pgfId-1032099){.index}

[Multiple transports](#01.htm_pgfId-1032159){.index}

[Complete customizability](#01.htm_pgfId-1032211){.index}

[User-namespace support](#01.htm_pgfId-1032223){.index}

  []{#toc.htm_pgfId-96434}1.4   [When not to use
Podman](#01.htm_pgfId-1032233){.index}

  2 []{#toc.htm_pgfId-96440}[Command
line](#02.htm_pgfId-1037520){.index}

  []{#toc.htm_pgfId-96442}2.1   [Working with
containers](#02.htm_pgfId-1037546){.index}

[]{#toc.htm_pgfId-96444}[Exploring
containers](#02.htm_pgfId-1037552){.index}

[Running the containerized application](#02.htm_pgfId-1037619){.index}

[Stopping containers](#02.htm_pgfId-1037696){.index}

[Starting containers](#02.htm_pgfId-1037737){.index}

[Listing containers](#02.htm_pgfId-1037765){.index}

[Inspecting containers](#02.htm_pgfId-1037795){.index}

[Removing containers](#02.htm_pgfId-1037843){.index}

[exec-ing into a container](#02.htm_pgfId-1037863){.index}

[Creating an image from a container](#02.htm_pgfId-1037916){.index}

  []{#toc.htm_pgfId-96462}2.2   [Working with container
images](#02.htm_pgfId-1038202){.index}

[]{#toc.htm_pgfId-96464}[Differences between a container and an
image](#02.htm_pgfId-1038207){.index}

[Listing images](#02.htm_pgfId-1038261){.index}

[Inspecting images](#02.htm_pgfId-1038320){.index}

[Pushing images](#02.htm_pgfId-1038364){.index}

[podman login: Logging into a container
registry](#02.htm_pgfId-1038455){.index}

[Tagging images](#02.htm_pgfId-1038512){.index}

[Removing images](#02.htm_pgfId-1038583){.index}

[Pulling images](#02.htm_pgfId-1038657){.index}

[Searching for images](#02.htm_pgfId-1038812){.index}

[Mounting images](#02.htm_pgfId-1038842){.index}

  []{#toc.htm_pgfId-96484}2.3   [Building
images](#02.htm_pgfId-1038884){.index}

[]{#toc.htm_pgfId-96486}[Format of a Containerfile or
Dockerfile](#02.htm_pgfId-1038895){.index}

[Automating the building of our
application](#02.htm_pgfId-1039048){.index}

  3 []{#toc.htm_pgfId-96492}[Volumes](../Text/03.htm){.index}

  []{#toc.htm_pgfId-96494}3.1   [Using volumes with
containers](#03.htm_pgfId-1048601){.index}

[]{#toc.htm_pgfId-96496}[Named volumes](#03.htm_pgfId-1048655){.index}

[Volume mount options](#03.htm_pgfId-1048730){.index}

[podman run - -mount command option](#03.htm_pgfId-1052263){.index}

  4 []{#toc.htm_pgfId-96504}[Pods](../Text/04.htm){.index}

  []{#toc.htm_pgfId-96506}4.1   [Running
pods](#04.htm_pgfId-1103755){.index}

  []{#toc.htm_pgfId-96508}4.2   [Creating a
pod](#04.htm_pgfId-1103802){.index}

  []{#toc.htm_pgfId-96510}4.3   [Adding a container to a
pod](#04.htm_pgfId-1103828){.index}

  []{#toc.htm_pgfId-96512}4.4   [Starting a
pod](#04.htm_pgfId-1103884){.index}

  []{#toc.htm_pgfId-96514}4.5   [Stopping a
pod](#04.htm_pgfId-1103924){.index}

  []{#toc.htm_pgfId-96516}4.6   [Listing
pods](#04.htm_pgfId-1103948){.index}

  []{#toc.htm_pgfId-96518}4.7   [Removing
pods](#04.htm_pgfId-1103966){.index}

Part 2. []{#toc.htm_pgfId-96522}[Design](#p2.htm_pgfId-1015382){.index}

  5 []{#toc.htm_pgfId-96524}[Customization and configuration
files](#05.htm_pgfId-1105485){.index}

  []{#toc.htm_pgfId-96526}5.1   [Configuration files for
storage](#05.htm_pgfId-1105544){.index}

[]{#toc.htm_pgfId-96528}[Storage
location](#05.htm_pgfId-1105558){.index}

[Storage drivers](#05.htm_pgfId-1105641){.index}

  []{#toc.htm_pgfId-96532}5.2   [Configuration files for
registries](#05.htm_pgfId-1105768){.index}

[]{#toc.htm_pgfId-96534}[registries.conf](#05.htm_pgfId-1105773){.index}

  []{#toc.htm_pgfId-96536}5.3   [Configuration files for
engines](#05.htm_pgfId-1105908){.index}

  []{#toc.htm_pgfId-96538}5.4   [System configuration
files](#05.htm_pgfId-1106060){.index}

  6 []{#toc.htm_pgfId-96542}[Rootless
containers](#06.htm_pgfId-1110284){.index}

  []{#toc.htm_pgfId-96544}6.1   [How does rootless Podman
work?](#06.htm_pgfId-1110312){.index}

[]{#toc.htm_pgfId-96546}[Images contain content owned by multiple user
identifiers (UIDs)](#06.htm_pgfId-1110335){.index}

  []{#toc.htm_pgfId-96548}6.2   [Rootless Podman under the
covers](#06.htm_pgfId-1110640){.index}

[]{#toc.htm_pgfId-96550}[Pulling the
image](#06.htm_pgfId-1110658){.index}

[Creating a container](#06.htm_pgfId-1110680){.index}

[Setting up the network](#06.htm_pgfId-1110688){.index}

[Starting the container monitor: conmon](#06.htm_pgfId-1110707){.index}

[Launching the OCI runtime](#06.htm_pgfId-1110723){.index}

[The containerized application runs until
completion](#06.htm_pgfId-1110762){.index}

Part 3. []{#toc.htm_pgfId-96564}[Advanced
topics](#p3.htm_pgfId-1016261){.index}

  7 []{#toc.htm_pgfId-96566}[Integration with
systemd](#07.htm_pgfId-1110285){.index}

  []{#toc.htm_pgfId-96568}7.1   [Running systemd within a
container](#07.htm_pgfId-1110308){.index}

[]{#toc.htm_pgfId-96570}[Containerized systemd
requirements](#07.htm_pgfId-1110355){.index}

[Podman container in systemd mode](#07.htm_pgfId-1110391){.index}

[Running an Apache service within a systemd
container](#07.htm_pgfId-1110439){.index}

  []{#toc.htm_pgfId-96576}7.2   [Journald for logging and
events](#07.htm_pgfId-1110503){.index}

[]{#toc.htm_pgfId-96578}[Log driver](#07.htm_pgfId-1110508){.index}

[Events](#07.htm_pgfId-1110574){.index}

  []{#toc.htm_pgfId-96582}7.3   [Starting containers at
boot](#07.htm_pgfId-1110633){.index}

[]{#toc.htm_pgfId-96584}[Restarting
containers](#07.htm_pgfId-1110638){.index}

[Podman containers as systemd services](#07.htm_pgfId-1110686){.index}

[Distributing systemd unit files to manage Podman
containers](#07.htm_pgfId-1110769){.index}

[Automatically updating Podman
containers](#07.htm_pgfId-1110842){.index}

  []{#toc.htm_pgfId-96592}7.4   [Running containers in notify unit
files](#07.htm_pgfId-1110957){.index}

  []{#toc.htm_pgfId-96594}7.5   [Rolling back failed containers after
update](#07.htm_pgfId-1110978){.index}

  []{#toc.htm_pgfId-96596}7.6   [Socket-activated Podman
containers](#07.htm_pgfId-1110991){.index}

  8 []{#toc.htm_pgfId-96600}[Working with
Kubernetes](#08.htm_pgfId-1118668){.index}

  []{#toc.htm_pgfId-96602}8.1   [Kubernetes YAML
files](#08.htm_pgfId-1118696){.index}

  []{#toc.htm_pgfId-96604}8.2   [Generating Kubernetes YAML files with
Podman](#08.htm_pgfId-1118705){.index}

  []{#toc.htm_pgfId-96606}8.3   [Generating Podman pods and containers
from Kubernetes YAML](#08.htm_pgfId-1118798){.index}

[]{#toc.htm_pgfId-96608}[Shutting down pods and containers based on a
Kubernetes YAML file](#08.htm_pgfId-1118853){.index}

[Building images using Podman and Kubernetes YAML
files](#08.htm_pgfId-1118884){.index}

  []{#toc.htm_pgfId-96612}8.4   [Running Podman within a
container](#08.htm_pgfId-1118979){.index}

[]{#toc.htm_pgfId-96614}[Running Podman within a Podman
container](#08.htm_pgfId-1119032){.index}

[Running Podman within a Kubernetes pod](#08.htm_pgfId-1119072){.index}

  9 []{#toc.htm_pgfId-96620}[Podman as a
service](#09.htm_pgfId-1109409){.index}

  []{#toc.htm_pgfId-96622}9.1   [Introducing the Podman
service](#09.htm_pgfId-1109433){.index}

[]{#toc.htm_pgfId-96624}[Systemd
services](#09.htm_pgfId-1109467){.index}

  []{#toc.htm_pgfId-96626}9.2   [Podman-supported
APIs](#09.htm_pgfId-1109565){.index}

  []{#toc.htm_pgfId-96628}9.3   [Python libraries for interacting with
Podman](#09.htm_pgfId-1109682){.index}

[]{#toc.htm_pgfId-96630}[Using docker-py with the Podman
API](#09.htm_pgfId-1109687){.index}

[Using podman-py with the Podman API](#09.htm_pgfId-1109731){.index}

[Which Python library should you use?](#09.htm_pgfId-1109775){.index}

  []{#toc.htm_pgfId-96636}9.4   [Using docker-compose with the Podman
service](#09.htm_pgfId-1109821){.index}

  []{#toc.htm_pgfId-96638}9.5   [podman -
-remote](#09.htm_pgfId-1109917){.index}

[]{#toc.htm_pgfId-96640}[Local
connections](#09.htm_pgfId-1109935){.index}

[Remote connections](#09.htm_pgfId-1109974){.index}

[Setting up SSH on the client machine](#09.htm_pgfId-1110068){.index}

[Configuring a connection](#09.htm_pgfId-1110087){.index}

Part 4. []{#toc.htm_pgfId-96650}[Container
security](#p4.htm_pgfId-1017166){.index}

10 []{#toc.htm_pgfId-96652}[Security container
isolation](#10.htm_pgfId-1114067){.index}

[]{#toc.htm_pgfId-96654}10.1   [Read-only Linux kernel pseudo
filesystems](#10.htm_pgfId-1114100){.index}

[]{#toc.htm_pgfId-96656}[Unmasking the masked
paths](#10.htm_pgfId-1114165){.index}

[Masking additional paths](#10.htm_pgfId-1114200){.index}

[]{#toc.htm_pgfId-96660}10.2   [Linux
capabilities](#10.htm_pgfId-1114238){.index}

[]{#toc.htm_pgfId-96662}[Dropped Linux
capabilities](#10.htm_pgfId-1114267){.index}

[Dropped CAP_SYS_ADMIN](#10.htm_pgfId-1114369){.index}

[Dropping capabilities](#10.htm_pgfId-1114384){.index}

[Adding capabilities](#10.htm_pgfId-1114413){.index}

[No new privileges](#10.htm_pgfId-1114439){.index}

[Root with no capabilities is still
dangerous](#10.htm_pgfId-1114450){.index}

[]{#toc.htm_pgfId-96674}10.3   [UID isolation: User
namespace](#10.htm_pgfId-1114461){.index}

[]{#toc.htm_pgfId-96676}[Isolating containers using the - -userns=auto
flag](#10.htm_pgfId-1114475){.index}

[User-namespaced Linux capabilities](#10.htm_pgfId-1114536){.index}

[Rootless Podman with the - -userns=auto
flag](#10.htm_pgfId-1114567){.index}

[User volumes with the - -userns=auto
flag](#10.htm_pgfId-1114589){.index}

[]{#toc.htm_pgfId-96684}10.4   [Process isolation: PID
namespace](#10.htm_pgfId-1114645){.index}

[]{#toc.htm_pgfId-96686}10.5   [Network isolation: Network
namespace](#10.htm_pgfId-1114671){.index}

[]{#toc.htm_pgfId-96688}10.6   [IPC isolation: IPC
namespace](#10.htm_pgfId-1114711){.index}

[]{#toc.htm_pgfId-96690}10.7   [Filesystem isolation: Mount
namespace](#10.htm_pgfId-1114733){.index}

[]{#toc.htm_pgfId-96692}10.8   [Filesystem isolation:
SELinux](#10.htm_pgfId-1114752){.index}

[]{#toc.htm_pgfId-96694}[SELinux type
enforcement](#10.htm_pgfId-1114760){.index}

[SELinux Multi-Category Security
separation](#10.htm_pgfId-1114953){.index}

[]{#toc.htm_pgfId-96698}10.9   [System call isolation
seccomp](#10.htm_pgfId-1115100){.index}

[]{#toc.htm_pgfId-96700}10.10 [Virtual machine
isolation](#10.htm_pgfId-1115148){.index}

11 []{#toc.htm_pgfId-96704}[Additional security
considerations](#11.htm_pgfId-1121652){.index}

[]{#toc.htm_pgfId-96706}11.1   [Daemon versus the fork/exec
model](#11.htm_pgfId-1121663){.index}

[]{#toc.htm_pgfId-96708}[Access to the
docker.sock](#11.htm_pgfId-1121669){.index}

[Auditing and logging](#11.htm_pgfId-1121703){.index}

[]{#toc.htm_pgfId-96712}11.2   [Podman secret
handling](#11.htm_pgfId-1121782){.index}

[]{#toc.htm_pgfId-96714}11.3   [Podman image
trust](#11.htm_pgfId-1121863){.index}

[]{#toc.htm_pgfId-96716}[Podman image
signing](#11.htm_pgfId-1121984){.index}

[]{#toc.htm_pgfId-96718}11.4   [Podman image
scanning](#11.htm_pgfId-1122123){.index}

[]{#toc.htm_pgfId-96720}[Read-only
containers](#11.htm_pgfId-1122154){.index}

[]{#toc.htm_pgfId-96722}11.5   [Security in
depth](#11.htm_pgfId-1122175){.index}

[]{#toc.htm_pgfId-96724}[Podman uses all security mechanisms
simultaneously](#11.htm_pgfId-1122181){.index}

[Where should you run your containers?](#11.htm_pgfId-1122191){.index}

  

Appendix A. []{#toc.htm_pgfId-96730}[Podman-related container
tools](#A.htm_pgfId-1277653){.index}

Appendix B. []{#toc.htm_pgfId-96756}[OCI
runtimes](#B.htm_pgfId-1282814){.index}

Appendix C. []{#toc.htm_pgfId-96766}[Getting
Podman](#C.htm_pgfId-1284762){.index}

Appendix D. []{#toc.htm_pgfId-96804}[Contributing to
Podman](#D.htm_pgfId-1286422){.index}

Appendix E. []{#toc.htm_pgfId-96810}[Podman on
macOS](#E.htm_pgfId-1286423){.index}

Appendix F. []{#toc.htm_pgfId-96824}[Podman on
Windows](#F.htm_pgfId-1289586){.index}

  

[]{#toc.htm_pgfId-96844}[index](#index.htm_pgfId-261944){.index}

[]{#fm.htm}

# front matter {#fm.htm_heading_id_2 .tochead}

## []{#fm.htm_pgfId-1113482}preface {#fm.htm_heading_id_3 .fm-head}

[]{#fm.htm_pgfId-1113483}I have been working on computer security for
close to 40 years, and for the past 20 years, I've focused on container
technologies. When Docker showed up about 10 years ago, it triggered a
revolution in the way the people distributed and ran applications on the
internet. As I worked on Docker, I felt it could have been designed
better. Working with a root-running daemon and then adding more and more
daemons felt like the wrong approach. Instead, I felt we could use
low-level operating systems concepts to create a tool that ran the same
containerized applications in the same manner but with more security and
requiring fewer privileges. With this in mind, my team at Red Hat set
out to build a series of tools to help developers and administrators run
containers in the most secure way possible. Out of this effort came
Podman.

[]{#fm.htm_pgfId-1113484}I started blogging on subjects like SELinux in
the early 2000s and have been writing articles ever since. I have
written hundreds of articles on containers and security over the years,
but I wanted to consolidate the ideas and describe the technology of
Podman in a single book I could point users and customers to.

[]{#fm.htm_pgfId-1113485}This book introduces Podman and how to use it.
It also dives deep into the technology and the different parts of the
Linux operating system that we take advantage of. Since I am a security
engineer, I also spend a couple of chapters describing how the security
of containers works. Reading this book should give you a better
understanding of what containers are, how they work, and how to work
with different features of Podman. You will even learn a lot more about
Docker. As Podman grows in popularity and infiltrates your
infrastructure, this book will be a handy reference to guide your way.

## []{#fm.htm_pgfId-1113486}acknowledgments {#fm.htm_heading_id_4 .fm-head}

[]{#fm.htm_pgfId-1113487}I extend thanks to all the people who helped me
write this book. This includes members of the Podman team, who have
written articles that helped me understand some of the technology I did
not fully comprehend and have helped build a great product. Thank you,
Brent Baude, Matt Heon, Valentin Rothberg, Giuseppe Scrivano, Urvashi
Mohnani, Nalin Dahyabhai, Lokesh Mandvekar, Miloslav Trmac, Jason
Greene, Jhon Honce, Scott McCarty, Tom Sweeney, Ashley Cui, Ed Santiago,
Chris Evich, Aditya Rajan, Paul Holzinger, Preethi Thomas, and Charlie
Doern. I also want to thank the countless open source contributors who
have made Linux containers and Podman possible.

[]{#fm.htm_pgfId-1113488}I thank the entire team at Manning, but
especially Toni Arritola. Toni taught me how to better focus my ideas
and has been a great partner on this journey. She's had to deal with me,
an old mathematics major who was never great at writing, and she helped
make this book possible.

[]{#fm.htm_pgfId-1113489}To all the reviewers---Alain Lompo, Alessandro
Campeis, Allan Makura, Amanda Debler, Anders Björklund, Andrea Monacchi,
Camal Cakar, Clifford Thurber, Conor Redmond, David Paccoud, Deepak
Sharma, Federico Kircheis, Frans Oilinki, Gowtham Sadasivam, Ibrahim
Akkulak, James Liu, James Nyika, Jeremy Chen, Kent Spillner, Kevin
Etienne, Kirill Shirinkin, Kosmas Chatzimichalis, Krzysztof Kamyczek,
Larry Cai, Michael Bright, Mladen Knežić, Oliver Korten, Richard
Meinsen, Roman Zhuzha, Rui Liu, Satadru Roy, Seung-jin Kim, Simeon
Leyzerzon, Simone Sguazza, Syed Ahmed, Thomas Peklak, and Vivek
Veerappan---thank you, your suggestions helped make this a better book.

## []{#fm.htm_pgfId-1113491}about this book {#fm.htm_heading_id_5 .fm-head}

[]{#fm.htm_pgfId-1113492}*Podman in Action* describes how users can
build, manage, and run containers. My goal in writing it was to explain
how easy it is to transfer skills you might have learned in Docker to
Podman as well as how easy it is to use Podman if you have never used a
container engine before. *Podman in Action* also teaches you how to use
advanced features like pods and guides you on your journey toward
building applications ready to run on the edge of or inside Kubernetes.
Finally, *Podman in Action* explains all of the security features of the
Linux kernel used to isolate containers from the system as well as from
other containers.

### []{#fm.htm_pgfId-1113493}Who should read this book? {#fm.htm_heading_id_6 .fm-head1}

[]{#fm.htm_pgfId-1113494}*Podman in Action* is written for software
developers who are looking to understand, develop, and work with
containers, as well as system administrators who need to run containers
in production. Reading this book will give you a deeper understanding of
what containers are. Having knowledge of Linux processes and familiarity
working with the Linux shells is necessary to get the full benefit of
the book.

[]{#fm.htm_pgfId-1113495}The book should have something for everyone on
their quest to use containers. Users with a deep understanding of Docker
will learn about advanced features of Podman not available from Docker
and will get an even deeper understanding of how Docker works. Novice
users will learn the basics of containers and pods.

### []{#fm.htm_pgfId-1113496}How this book is organized: A roadmap {#fm.htm_heading_id_7 .fm-head1}

[]{#fm.htm_pgfId-1113498}*Podman in Action* is split into four parts and
six appendixes: []{#fm.htm_id_3mrcqet55bxe}

- []{#fm.htm_pgfId-1113499 .calibre17}Part 1, "Foundations," comprises
  four chapters and provides readers an introduction to Podman. Chapter
  1 explains what Podman does, why it was created, and why it is
  important. The next two chapters introduce the command-line interface
  and how to use volumes within containers. Finally, chapter 4
  introduces the concept of pods and how Podman works with them. There
  should be something for everyone in these chapters, but if you have
  great experience with Docker, you should be able to skim over much of
  the content in chapter 2.

- []{#fm.htm_pgfId-1113501 .calibre17}Part 2, "Design," comprises two
  chapters in which I dig deep into Podman's design. You will learn
  about rootless containers and how they work and will come out of these
  chapters with a better understanding of user namespaces and the
  security of rootless containers. You will also learn how to customize
  the configuration of your Podman environment.

- []{#fm.htm_pgfId-1113503 .calibre17}Part 3, "Advanced topics,"
  comprises three chapters and moves beyond the basics of Podman. In
  chapter 7 you will see how Podman can work in production through its
  integration with systemd. It covers running systemd inside a container
  and how you can use it as a container manager. You will learn how to
  set up edge servers with Podman containers, where systemd manages the
  life cycle of the container. Podman makes it easy to generate systemd
  unit files to help you put your containerized applications into
  production. In chapter 8 you will learn how Podman can be used to help
  you move containers into Kubernetes. Podman supports launching
  containers with the same YAML files that Kubernetes uses as well as
  the ability to generate Kubernetes YAML from your current containers.
  In chapter 9 you will see Podman running as a service, allowing remote
  access to Podman containers. Using Podman as a service allows you to
  use other programming languages and tools to manage Podman containers.
  You will see how `docker-compose`{.fm-code-in-text} can work with
  Podman containers. You will also learn how to use the Python libraries
  like podman-py and docker-py to communicate with the Podman service
  for managing containers.

- []{#fm.htm_pgfId-1113505 .calibre17}Part 4, "Container security,"
  comprises two chapters, in which I discuss important security
  considerations. Chapter 10 covers features used to ensure container
  isolation. This chapter covers security subsystems of Linux, like
  SELinux, seccomp, Linux capabilities, kernel file systems, and
  namespaces. Chapter 11 then examines the security considerations I
  consider best practices for running your containers in as secure a
  manner as possible.

[]{#fm.htm_pgfId-1113506}Additionally, there are six appendixes covering
Podman-related subjects:

- []{#fm.htm_pgfId-1113507 .calibre17}Appendix A covers all of the
  Podman-related tools, including Buildah, Skopeo, and CRI-O.

- []{#fm.htm_pgfId-1113508 .calibre17}Appendix B dives into the
  different OCI runtimes available to Podman as well as Docker. It
  covers `runc`{.fm-code-in-text}, `crun`{.fm-code-in-text}, Kata, and
  gVisor.

- []{#fm.htm_pgfId-1113509 .calibre17}Appendix C describes how you can
  get Podman onto your local system, whether that system is a Linux,
  Mac, or Windows box.

- []{#fm.htm_pgfId-1113510 .calibre17}Appendix D describes the Podman
  open source community and how you can join.

- []{#fm.htm_pgfId-1113511 .calibre17}Appendixes E and F dive into
  running Podman on Mac and Windows boxes.

### []{#fm.htm_pgfId-1113520}liveBook discussion forum {#fm.htm_heading_id_8 .fm-head1}

[]{#fm.htm_pgfId-1113521}Each purchase of *Podman in Action* includes
free access to liveBook, Manning's online reading platform. Using
liveBook's exclusive discussion features, you can attach comments to the
book globally or to specific sections or paragraphs. It's a snap to make
notes for yourself, ask and answer technical questions, and receive help
from the author and other users. []{#fm.htm_id_Hlk6318184}To access the
forum, go to
[https://livebook.manning.com/book/podman-in-action/discussion](https://livebook.manning.com/book/podman-in-action/discussion){.url}.
You can also learn more about Manning\'s forums and the rules of conduct
at
[https://livebook.manning.com/discussion](https://livebook.manning.com/discussion){.url}.

[]{#fm.htm_pgfId-1113525}Manning's commitment to our readers is to
provide a venue where a meaningful dialogue between individual readers
and between readers and the author can take place. It is not a
commitment to any specific amount of participation on the part of the
author, whose contribution to the forum remains voluntary (and unpaid).
We suggest you try asking him some challenging questions lest his
interest stray! The forum and the archives of previous discussions will
be accessible from the publisher's website as long as the book is in
print.

### []{#fm.htm_pgfId-1113526}Author online {#fm.htm_heading_id_9 .fm-head1}

[]{#fm.htm_pgfId-1113528}You can follow Dan Walsh on Twitter and GitHub
\@rhatdan. He regularly blogs at
[https://www.redhat.com/sysadmin/users/dwalsh](https://www.redhat.com/sysadmin/users/dwalsh){.url}
as well as on several other sites. There are many videos of talks Dan
has presented available on YouTube as well.

## []{#fm.htm_pgfId-1113530}about the author {#fm.htm_heading_id_10 .fm-head}

::: figure
![](images/FM-Daniel_Walsh.png){.calibre18}
:::

[]{#fm.htm_pgfId-1113532}[Daniel Walsh]{.mc-small-caps} leads the team
that created Podman, Buildah, Skopeo, CRI-O, and their related tools.
Dan is a senior distinguished engineer at Red Hat, having joined in
August 2001. He has worked in the computer security field for over 40
years. Dan is sometimes referred to as Mr. SELinux after leading the
development of SELinux at Red Hat prior to leading the container team.
Dan has a BA in mathematics from the College of the Holy Cross and an MS
in computer science from Worcester Polytechnic Institute. On Twitter and
GitHub you can find him \@rhatdan. You can email him at
dwalsh@redhat.com.

## []{#fm.htm_pgfId-1113536}about the cover illustration {#fm.htm_heading_id_11 .fm-head}

[]{#fm.htm_pgfId-1113537}The figure on the cover of *Podman in Action*
is captioned "La vandale," or "The vandal," and is taken from a
collection by Jacques Grasset de Saint-Sauveur, published in 1797. Each
illustration is finely drawn and colored by hand.

[]{#fm.htm_pgfId-1113538}In those days, it was easy to identify where
people lived and what their trade or station in life was just by their
dress. Manning celebrates the inventiveness and initiative of the
computer business with book covers based on the rich diversity of
regional culture centuries ago, brought back to life by pictures from
collections such as this one.

[]{#p1.htm}

# []{#p1.htm_pgfId-998407} []{#p1.htm_id_Hlk73883217}[]{#p1.htm_pgfId-1014486}Part 1. Foundations {#p1.htm_heading_id_2 .tochead}

[]{#p1.htm_pgfId-1014487}[I]{.fm-part-initial-cap}n part 1 of the book,
I introduce you to several ways you can use Podman from the command
line. In chapter 2 you learn how to create and work with containers and
how containers work with images. You also learn the difference between a
container and an image, how to save a container into an image, and then
to push the image to a registry, so it can be shared with other users.

[]{#p1.htm_pgfId-1014488}In chapter 3 I introduce the concept of a
*volume*. Volumes are the mechanisms most users of your containerized
applications use to store their data and keep it isolated from the
application. The first two chapters really concentrate on the use of
containers and images, which is very similar to the way containers work
in Docker.

[]{#p1.htm_pgfId-1014489}Chapter 4 adds the concept of *pods*, similar
to Kubernetes Pods, a feature Docker does not support. Pods allow you to
share one or more containers within the same resource, namespaces, and
security constraints. Pods can allow you to write more complex
applications and manage them as a single
entity.[]{#p1.htm_id_u6n877dddx1z}[]{#p1.htm_id_7dubk56duarh}[]{#p1.htm_id_j5ogsbez02wl}

[]{#01.htm}

# []{#01.htm_pgfId-1031516}[]{#01.htm_pgfId-1031519}1 Podman: A next-generation container engine {#01.htm_heading_id_2 .tochead}

[]{#01.htm_pgfId-1031522}This chapter []{#01.htm_marker-1033181}covers

- []{#01.htm_pgfId-1031523 .calibre17}What Podman is
- []{#01.htm_pgfId-1031524 .calibre17}The advantages of using Podman
  over Docker
- []{#01.htm_pgfId-1031525 .calibre17}Examples of using Podman

[]{#01.htm_pgfId-1031527}Starting this book is difficult because so many
people come to it with different expectations and experiences. You
likely have some experience with containers, Docker, or Kubernetes---or
at least are interested in learning more about Podman because you've
heard about it. If you've used or evaluated Docker, you'll find that
Podman works the same as Docker in most cases, but it solves some
problems inherent in Docker; most significantly, Podman offers enhanced
security and the ability to run commands with non-root privileges. This
means you can manage containers with Podman without root access or
privileges. Because of Podman's design, it can run with much better
security than Docker by default.

[]{#01.htm_pgfId-1031529}In addition to being open source (and therefore
free), Podman's commands, run from the command-line interface (CLI), are
quite similar to Docker's. This book shows how you can use Podman as a
local container engine to launch containers on a single node, either
locally or through a remote REST API. You'll also learn how to find,
run, and build containers using Podman with open source tools such as
Buildah and Skopeo.

## []{#01.htm_pgfId-1031531}1.1 About all these terms {#01.htm_heading_id_3 .fm-head}

[]{#01.htm_pgfId-1031533}Before []{#01.htm_marker-1031532}you go
further, I think it is important to define the terminology that will be
used throughout this book. In the container world, terms like *container
orchestrator*[]{#01.htm_marker-1031534}, *container
engine*[]{#01.htm_marker-1031535}, and *container
runtime*[]{#01.htm_marker-1031536} are often used interchangeably, which
commonly leads to confusion. The following list is a summary of what
each of these terms refers to in the context of this text:

- []{#01.htm_pgfId-1031538 .calibre17}*Container
  orchestrators*[]{#01.htm_marker-1031537 .calibre17}---Software
  projects and products that orchestrate containers onto multiple
  different machines or nodes. These orchestrators communicate with
  container engines to run containers. The primary container
  orchestrator is Kubernetes, which was originally designed to talk to
  the Docker daemon container engine, but using Docker is becoming
  obsolete because Kubernetes primarily uses CRI-O or
  []{#01.htm_id_Hlk113268497 .calibre17}containerd as its container
  engine. CRI-O and containerd are purpose built for running
  orchestrated Kubernetes containers (CRI-O is covered in appendix
  A).[]{#01.htm_id_Hlk113268570 .calibre17} Docker Swarm
  an[]{#01.htm_id_Hlk113268625 .calibre17}d Apache Mesos are other
  examples of container orchestrators.

- []{#01.htm_pgfId-1031543 .calibre17}*Container
  engines*[]{#01.htm_marker-1031542 .calibre17}---Primarily used for
  configuring containerized applications to run on a single local node.
  They can be launched directly by users, administrators, and
  developers. They can also be launched out of systemd unit files at
  boot as well as launched by container orchestrators like Kubernetes.
  As previously mentioned, CRI-O and containerd are container engines
  used by Kubernetes to manage containers locally. They really are not
  intended to be used directly by users. Docker and Podman are the
  primary container engines used by users to develop, manage, and run
  containerized applications on a single machine. Podman is seldom used
  to launch containers for Kubernetes; therefore, Kubernetes is not
  generally covered in this book. Buildah is another container engine,
  although it is only used for building container images.

- []{#01.htm_pgfId-1031544 .calibre17}*Open Container Initiative (OCI)
  container runtimes*---Configure different parts of the Linux kernel
  and then, finally, launch the containerized application. The two most
  commonly used container runtimes are
  `runc`{.fm-code-in-text}[]{#01.htm_id_Hlk113270894 .calibre17}
  and[]{#01.htm_id_Hlk113270903 .calibre17}
  `crun`{.fm-code-in-text}[]{#01.htm_marker-1031547 .calibre17}. Kata
  an[]{#01.htm_id_Hlk113270883 .calibre17}d gVisor are other examples of
  container runtimes. See appendix B to understand the differences
  between the OCI container runtimes.

[]{#01.htm_pgfId-1031549}Figure 1.1 shows into which categories these
open source container projects fit.

::: figure
![](images/01-01.png){.calibre18}

[]{#01.htm_pgfId-1040864}Figure 1.1 Different open source projects
dealing with containers within the categories of orchestrators, engines,
and runtimes.
:::

[]{#01.htm_pgfId-1031557}*Podman* is short for *Pod
Manager*[]{#01.htm_marker-1031555}. A *pod*[]{#01.htm_marker-1031556}, a
concept popularized by the Kubernetes project, is one or more containers
sharing the same namespaces and `cgroups`{.fm-code-in-text} (resource
constraints[]{#01.htm_marker-1031558}). Pods are covered in greater
depth in chapter 4. Podman runs individual containers as well as pods.
The Podman logo in figure 1.2 is a group of Selkies, the Irish concept
of a mermaid. Groups of Selkies are called pods.

::: figure
![](images/01-02.png){.calibre18}

[]{#01.htm_pgfId-1040912}Figure 1.2 Podman's logo
:::

[]{#01.htm_pgfId-1031565}The Podman project describes Podman as "a
daemonless container engine for developing, managing, and running OCI
Containers on your Linux System. Containers can either be run as root or
in rootless mode" ([https://podman.io](https://podman.io){.url}). Podman
is often summarized with the simple line *alias Docker = Podman* because
Podman does almost everything that Docker can do with the same command
line as Docker. But as you will learn in this book, Podman can do so
much more. Understanding Docker is not critical to understanding Podman,
but it is helpful.

[]{#01.htm_pgfId-1031568}[Note]{.fm-callout-head} The
[]{#01.htm_id_Hlk113270255}Open Container Initiative (OCI) is a
standards body with the primary goal of creating open industry standards
regarding container formats and runtimes. For more information, see
[https://opencontainers.org](https://opencontainers.org){.url}.

[]{#01.htm_pgfId-1031569}The Podman upstream project resides at
github.com in the Containers project,
([https://github.com/containers/podman](https://github.com/containers/podman){.url})
shown in figure 1.3, along with other container libraries and container
management tools like Buildah[]{#01.htm_marker-1036166} and
Skopeo[]{#01.htm_marker-1036167}. (See appendix A for a description of
some of these tools.)

::: figure
![](images/01-03.png){.calibre18}

[]{#01.htm_pgfId-1041026}Figure 1.3 Containers is the developer site for
Podman and other related container tools (see
[https://github.com/containers](https://github.com/containers){.url}).
:::

[]{#01.htm_marker-1031582}[]{#01.htm_pgfId-1031580}Podman runs images
with the newer OCI format, described in section 1.1.2, as well as the
legacy Docker (v2 and v1) format images. Podman runs any image available
at container registries, like docker.io and quay.io, as well as the
hundreds of other container registries. Podman pulls these images to a
Linux host and launches them in the same way as Docker and Kubernetes.
Podman supports all OCI runtimes, including
`runc`{.fm-code-in-text}[]{#01.htm_marker-1041010},
`crun`{.fm-code-in-text}[]{#01.htm_marker-1041011},
`kata`{.fm-code-in-text}, and
`gvisord`{.fm-code-in-text}[]{#01.htm_marker-1041012} (appendix B), just
like Docker.

[]{#01.htm_pgfId-1031584}This book is intended to aid Linux
administrators in understanding the advantages of using Podman as their
primary container engine. You will learn how to configure your systems
as securely as possible but still allow your users to work with
containers. One of Podman's primary use cases is running containerized
applications on single-node environments, such as edge devices. Podman
and []{#01.htm_id_Hlk113270866}systemd allow you to manage the entire
life cycle of the application on nodes without human intervention.
Podman's goal is running containers naturally on a Linux box, taking
advantage of all the features of the Linux platform.

[]{#01.htm_pgfId-1031586}[Note]{.fm-callout-head} Podman is available
for many different Linux distributions and on Mac and Windows platforms.
Please refer to appendix C to see how to get Podman on your platform.

[]{#01.htm_pgfId-1031587}Application developers are also an intended
audience for this book. Podman is a great tool for developers looking to
containerize their applications in a secure manner. Podman allows
developers to create Linux containers on all Linux distributions. In
addition, Podman is available on the Mac and Windows platforms, where it
can communicate with the Podman service running within a VM or on a
Linux box available on the network. *Podman in Action* shows you how to
work with containers, build container images, and then convert their
containerized applications into either single-node services to run on
edge devices or into Kubernetes-based microservices.

[]{#01.htm_pgfId-1031588}Podman and the container tools are open source
projects with contributors from many different companies, universities,
and organizations. Contributors come from all over the world. The
projects are always looking to add new contributors to improve them;
please refer to appendix D to see how you can join the effort. In this
chapter, I first provide a brief overview of containers, and then I
explain some key features that make Podman a great tool for working with
[]{#01.htm_marker-1031589}containers.

## []{#01.htm_pgfId-1031591}1.2 A brief overview of containers {#01.htm_heading_id_4 .fm-head}

[]{#01.htm_pgfId-1031594}*Containers*
[]{#01.htm_marker-1031592}[]{#01.htm_marker-1031593}are groups of
processes running on a Linux system that are isolated from each other.
Containers make sure one group of processes does not interfere with
other processes on the system. Rogue processes can't dominate system
resources, which might prevent other processes from performing their
task. Hostile containers are also prevented from attacking other
containers, stealing data, or causing denial of service attacks. A final
goal of containers is allowing applications to be installed with their
own versions of shared libraries that do not conflict with applications
requiring different versions of the same libraries. Instead they allow
applications to live in a virtualized environment, giving the impression
that they own the entire system.

[]{#01.htm_pgfId-1031595}Containers are isolated via the following:

- []{#01.htm_pgfId-1031597 .calibre17}*Resource constraints
  (cgroups*[]{#01.htm_marker-1035922 .calibre17}*)*---The cgroup man
  page
  ([https://man7.org/linux/man-pages/man7/cgroups.7.html](https://man7.org/linux/man-pages/man7/cgroups.7.html){.url1})
  defines cgroups as the following: "Control groups, usually referred to
  as cgroups, are a Linux kernel feature which allow processes to be
  organized into hierarchical groups whose usage of various types of
  resources can then be limited and monitored."

  []{#01.htm_pgfId-1031598 .calibre17}Examples of resources controlled
  by cgroups include the following:

  - []{#01.htm_pgfId-1031599 .calibre17}The amount of memory a group of
    processes can use
  - []{#01.htm_pgfId-1031600 .calibre17}The amount of CPU processes can
    use
  - []{#01.htm_pgfId-1031601 .calibre17}The amount of network resources
    a process can use

  []{#01.htm_pgfId-1031603 .calibre17}The basic idea of
  []{#01.htm_id_Hlk113272354 .calibre17}cgroups is preventing one group
  of processes from dominating certain system resources in such a way
  that another group of processes can't make progress on the system.

- []{#01.htm_pgfId-1031605 .calibre17}*Security
  constraints*[]{#01.htm_marker-1031604 .calibre17}---Containers are
  isolated from each other using many security tools available in the
  kernel. The goal is blocking privilege escalation and preventing a
  rogue group of processes from committing hostile acts against the
  system, including the following examples:

  - []{#01.htm_pgfId-1031606 .calibre17}Dropped Linux capabilities limit
    the power of root.
  - []{#01.htm_pgfId-1031608 .calibre17}[]{#01.htm_id_Hlk113272985
    .calibre17}SELinux controls access to the filesystem.
  - []{#01.htm_pgfId-1031609 .calibre17}There is read-only access to
    kernel filesystems.
  - []{#01.htm_pgfId-1031610 .calibre17}Seccomp limits the system calls
    available in the kernel.
  - []{#01.htm_pgfId-1031611 .calibre17}A user namespace to map one
    group of UIDs in the host to another allows access to limited root
    environments.

  []{#01.htm_pgfId-1031612 .calibre17}Table 1.1 gives further
  information and provides links with more detail about some of these
  security features.

[]{#01.htm_pgfId-1033506}Table 1.1 Advanced Linux security features

+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+
| []{#01.htm_pgfId-1033512}Component                         | []{#01.htm_pgfId-1033514}Description       | []{#01.htm_pgfId-1033516}Reference                        |
+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+
| []{#01.htm_pgfId-1033518}Linux capabilities                | []{#01.htm_pgfId-1033520}Linux             | []{#01.htm_pgfId-1033522}The capabilities man page is a   |
|                                                            | capabilities subdivide the power of root   | good overview of the available capabilities               |
|                                                            | into distinct capabilities.                | ([https://bit.ly/3A3Ppeg](https://bit.ly/3A3Ppeg){.url}). |
+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+
| []{#01.htm_pgfId-1033524}SELinux                           | []{#01.htm_pgfId-1033526}Security-Enhanced | []{#01.htm_pgfId-1033528}I wrote the *SELinux Coloring    |
|                                                            | Linux (SELinux) is a                       | Book*, which is a fun way to help you understand SELinux  |
|                                                            | []{#01.htm_id_Hlk113273591}Linux kernel    | ([https://bit.ly/33plEbD](https://bit.ly/33plEbD){.url}). |
|                                                            | mechanism that labels every process and    | If you really want to study the subject, check out the    |
|                                                            | every filesystem object on the system. A   | SELinux notebook                                          |
|                                                            | SELinux policy defines the rules on how    | ([https://bit.ly/3GxGhkm](https://bit.ly/3GxGhkm){.url}). |
|                                                            | labeled processes interact with label      |                                                           |
|                                                            | objects. The Linux kernel enforces the     |                                                           |
|                                                            | rules.                                     |                                                           |
+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+
| []{#01.htm_pgfId-1033530}Seccomp[]{#01.htm_marker-1033542} | []{#01.htm_pgfId-1033532}seccomp is a      | []{#01.htm_pgfId-1033534}The seccomp man page is a good   |
|                                                            | Linux kernel mechanism that limits the     | source of additional information on seccomp               |
|                                                            | number of syscalls to a group of processes | ([https://bit.ly/3rnnim1](https://bit.ly/3rnnim1){.url}). |
|                                                            | on the system. You can remove potentially  |                                                           |
|                                                            | dangerous syscalls from being called by    |                                                           |
|                                                            | the processes.                             |                                                           |
+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+
| []{#01.htm_pgfId-1033536}User namespace                    | []{#01.htm_pgfId-1033538}The user          | []{#01.htm_pgfId-1033540}The user namespace is fully      |
|                                                            | namespace allows you to have Linux         | explained in chapter 3.                                   |
|                                                            | capabilities within the group of UIDs and  |                                                           |
|                                                            | GIDs assigned to the namespace, without    |                                                           |
|                                                            | having root capabilities on the host.      |                                                           |
+------------------------------------------------------------+--------------------------------------------+-----------------------------------------------------------+

- []{#01.htm_pgfId-1031650 .calibre17}*Virtualization technologies
  (namespaces*[]{#01.htm_marker-1031649 .calibre17}*)*---The Linux
  kernel employs a concept called *namespaces*[]{#01.htm_marker-1031651
  .calibre17}, which creates virtualized environments, where one set of
  processes sees one set of resources, while another set of processes
  sees a different set of resources. These virtualized environments
  eliminate processes' views into the rest of the system, giving them
  the feel of a virtual machine (VM) without the overhead. Examples of
  namespaces include the following:

  - []{#01.htm_pgfId-1031653 .calibre17}*Network
    namespace*[]{#01.htm_marker-1031652 .calibre17}---Eliminates the
    access to the host network but gives access to virtual network
    devices
  - []{#01.htm_pgfId-1031655 .calibre17}*Mount
    namespace*[]{#01.htm_marker-1035526 .calibre17}---Eliminates the
    view of all the filesystem, except the containers filesystem
  - []{#01.htm_pgfId-1031658 .calibre17}*PID
    namespace*[]{#01.htm_id_Hlk113274629
    .calibre17}[]{#01.htm_marker-1035529 .calibre17}---Eliminates the
    view of other processes on the system; container processes only see
    the processes within the container

[]{#01.htm_pgfId-1031659}These container technologies have existed in
the Linux kernel for many years. Security tools for isolating processes
started in Unix back in the 1970s, and SELinux started in 2001.
Namespaces were introduced around 2004, and cgroups were introduced
around 2006.

[]{#01.htm_pgfId-1031660}[Note]{.fm-callout-head} Windows container
images exist, but this book concentrates on Linux-based containers. Even
when running Podman on Windows, you are still working with
[]{#01.htm_id_Hlk113274857}Linux containers. Podman on Mac is covered in
appendix E. Podman on Windows is covered in appendix F.

### []{#01.htm_pgfId-1031664}1.2.1 Container images: A new way to ship software {#01.htm_heading_id_5 .fm-head1}

[]{#01.htm_pgfId-1031667}Containers
[]{#01.htm_marker-1031665}[]{#01.htm_marker-1031666}really didn't take
off until the Docker project introduced the concept of the container
image and container registry. Basically, they created a new way to ship
software.

[]{#01.htm_pgfId-1031668}Traditionally, installing multiple software
applications on a Linux system has led to a problem of dependency
management. Before containers, you packaged software using package
managers like RPM and Debian packages. These packages are installed on a
host and share the content on the host, including shared libraries. When
developers test their code, everything might work fine when run on the
host machine. The quality engineering team then might test the software
on a different machine with different packages and see failures. Both
teams would need to work together to generate the proper requirements.
Finally, the software is shipped to customers, who have many different
configurations and software installed, leading to further breakage of
the application.

[]{#01.htm_pgfId-1031669}Container images solve the dependency
management problem by bundling all the software needed to run your
application together into a unit. You ship all the libraries,
executables, and configuration files together. The software is isolated
from the host via container technology. Usually the only part of the
host system that your application interacts with is the host kernel.

[]{#01.htm_pgfId-1031670}The developer, quality engineers, and customer
all run the exact same containerized environment along with the
application. This helps guarantee consistency and limits the number of
bugs caused by misconfiguration.

[]{#01.htm_pgfId-1031671}Containers are often compared to VMs in that
they both can run multiple isolated applications on a single node. When
using VMs, you need to manage the entire VM operating system as well as
the isolated application. You need to manage the life cycle of the
different kernel, init system, logging, security updates, backups, and
so on. The system also has to deal with the overhead of the entire
running operation system, not just the application. In the container
world, all you run is the containerized application---there is no
overhead and no additional OS management. Figure 1.4 shows three
applications running in three different VMs.

::: figure
![](images/01-04.png){.calibre18}

[]{#01.htm_pgfId-1041065}Figure 1.4 Physical machine running three
applications in three VMs
:::

[]{#01.htm_pgfId-1031678}With VMs you end up needing to manage four
operations systems, whereas with containers the three applications run
with just their required user spaces. You end up managing just one
operating system, as shown in
[]{#01.htm_marker-1031679}[]{#01.htm_marker-1031680}figure 1.5.

::: figure
![](images/01-05.png){.calibre18}

[]{#01.htm_pgfId-1041103}Figure 1.5 Physical machine running three
applications in three containerized applications
:::

### []{#01.htm_pgfId-1031688}1.2.2 Container images lead to microservices {#01.htm_heading_id_6 .fm-head1}

[]{#01.htm_pgfId-1031692}Packing
[]{#01.htm_marker-1031689}[]{#01.htm_marker-1031690}[]{#01.htm_marker-1031691}applications
inside of container images allows the installation of multiple
applications with conflicting requirements on the same host. For
example, one application might require a different version of the C
library than another, which prevents them from being installed at the
same time. Figure 1.6 shows a traditional application running within an
operating system without use of containers.

::: figure
![](images/01-06.png){.calibre18}

[]{#01.htm_pgfId-1041150}Figure 1.6 Traditional LAMP stack (Linux,
Apache, MariaDB, and PHP/PERL application) running on a server
:::

[]{#01.htm_pgfId-1031699}Containers can have the correct C library
within their container image, with each image potentially having
different versions of the library specific to the container's
application. You can run applications from totally different
distributions.

[]{#01.htm_pgfId-1031700}Containers make it easy to run multiple
instances of the same application, as shown in figure 1.7. Container
images encourage the packaging of a single service or application into a
single container. Containers allow you to easily wire multiple
applications together via the network.

::: figure
![](images/01-07.png){.calibre18}

[]{#01.htm_pgfId-1041172}Figure 1.7 LAMP stack packaged individually
into microservice containers. As containers communicate via the network,
they can be easily moved to other VMs, making reuse much easier.
:::

[]{#01.htm_pgfId-1031707}Instead of designing monolithic applications in
which you have a web frontend, a load balancer, and a database, you can
build three different container images and then wire them together to
build microservices. Microservices allow you and other users to
experiment with running multiple databases and web frontends, then
orchestrate them together. Containerized microservices make the sharing
and reuse of software
[]{#01.htm_marker-1031708}[]{#01.htm_marker-1031709}[]{#01.htm_marker-1031710}possible.

### []{#01.htm_pgfId-1031712}1.2.3 Container image format {#01.htm_heading_id_7 .fm-head1}

[]{#01.htm_pgfId-1031715}A
[]{#01.htm_marker-1031713}[]{#01.htm_marker-1031714}container image
consists of three components:

- []{#01.htm_pgfId-1031716 .calibre17}A directory tree containing all
  the software required to run your application

- []{#01.htm_pgfId-1031717 .calibre17}A JSON file that describes the
  contents of the rootfs

- []{#01.htm_pgfId-1031718 .calibre17}Another JSON file called a
  manifest list that links multiple images together to support different
  architectures

[]{#01.htm_pgfId-1031720}The directory tree is called a *rootfs* (root
filesystem[]{#01.htm_marker-1031719}). The software is laid out like it
was the root (/) of a Linux system.

[]{#01.htm_pgfId-1031722}[]{#01.htm_id_Hlk113277572}The executable to be
run within the rootfs, the working directory, the environment variables
to be used, the maintainer of the executable, and other labels to help
identify the content of the image are defined in the first JSON file.
You can see this JSON file using the `podman`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#01.htm_marker-1031723}:

``` programlisting
$ podman inspect docker:/ /registry.access.redhat.com/ubi8
{
...
  "created": "2022-01-27T16:00:30.397689Z",      ❶
  "architecture": "amd64",                       ❷
  "os": "linux",                                 ❸
  "config": {
         "Env": [                                ❹
            "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
            "container=oci"
         ],
         "Cmd": [                                ❺
                   "/bin/bash"
         ],
         "Labels": {                             ❻
                     "architecture": "x86_64",
                     "build-date": "2022-01-27T15:59:52.415605",
       ...
}
```

[]{#01.htm_pgfId-1039834}[❶]{.fm-combinumeral} Date the image was
created

[]{#01.htm_pgfId-1039855}[❷]{.fm-combinumeral} Architecture for this
image

[]{#01.htm_pgfId-1039872}[❸]{.fm-combinumeral} Operating system for this
image

[]{#01.htm_pgfId-1039889}[❹]{.fm-combinumeral} Environment variables
that the developer of the image wants to be set within the container

[]{#01.htm_pgfId-1039906}[❺]{.fm-combinumeral} Default command to be
executed when the container starts

[]{#01.htm_pgfId-1039923}[❻]{.fm-combinumeral} Labels to help describe
the contents of the image. These fields can be free-form and do not
affect the way images are run but can be used to search for and describe
the image.

[]{#01.htm_pgfId-1031750}The second JSON file, the manifest list, allows
users on an arm64 machine[]{#01.htm_marker-1031749} to pull an image
with the same name as they would if they were on an arm64 machine.
Podman pulls the image based on the default architecture of the machine,
using this manifest list. Skopeo[]{#01.htm_marker-1031751} is a tool
that uses the same underlying libraries as Podman and is available at
[github.com/containers/skopeo](http://github.com/containers/skopeo){.url}
(see appendix A). Skopeo provides lower-level output examining the
structures of a container image. In the following example, use the
`skopeo`{.fm-code-in-text} command[]{#01.htm_marker-1031752} with the
`--raw`{.fm-code-in-text} option[]{#01.htm_marker-1031753} to examine
the registry.access.redhat.com/ ubi8 image manifest specification:

``` programlisting
$ skopeo inspect --raw docker:/ /registry.access.redhat.com/ubi8
{
    "manifests": [
      {
              "digest": "sha256:cbc1e8cea
➥ 8c78cfa1490c4f01b2be59d43ddbb
➥ ad6987d938def1960f64bcd02c",                                                   ❶
              "mediaType": "application/vnd.docker.distribution.manifest.v2+json",❷
              "platform": {
              "architecture": "amd64",                                            ❸
              "os": "linux"                                                       ❹
              },
              "size": 737
      },
      {
              "digest":                                                           ❺
➥ "sha256:f52d79a9d0a3c23e6ac4c3c8f2ed8d6337ea47f4e2dfd46201756160ca193308",
              "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
              "platform": {
              "architecture": "arm64", 
              "os": "linux"
              },
              "size": 737
      },
...
}
```

[]{#01.htm_pgfId-1039391}[❶]{.fm-combinumeral} Digest of the exact image
pulled when the architecture and OS match

[]{#01.htm_pgfId-1039434}[❷]{.fm-combinumeral} mediaType describes the
type of the image, OCI, Docker, and so on.

[]{#01.htm_pgfId-1039451}[❸]{.fm-combinumeral} The architecture of this
image digest: amd64

[]{#01.htm_pgfId-1039468}[❹]{.fm-combinumeral} The OS of this image
digest: Linux

[]{#01.htm_pgfId-1039392}[❺]{.fm-combinumeral} This stanza points to a
different image for a different architecture: arm64.

[]{#01.htm_pgfId-1031785}Images use the []{#01.htm_id_Hlk113279303}Linux
tar utility to pack the rootfs and the JSON files together. These images
are then stored on web servers called container registries (e.g.,
docker.io, quay.io, and Artifactory). Container engines like Podman can
copy these images to a host and unpack them onto the filesystem. Then
the engine merges the image's JSON file, the engine's built-in defaults,
and the user's input to create a new container OCI runtime specification
JSON file. The JSON file describes how to run the containerized
application.

[]{#01.htm_pgfId-1031786}In the last step, the container engine launches
a small program called a container runtime (e.g.,
`runc`{.fm-code-in-text},
`crun`{.fm-code-in-text}[]{#01.htm_marker-1031787},
`kata`{.fm-code-in-text}[]{#01.htm_marker-1031788}, or
`givisord`{.fm-code-in-text}[]{#01.htm_marker-1031789}). The container
runtime reads the container's JSON and instruments, kernel cgroups,
security constraints, and namespaces before finally launching the
primary process of the
[]{#01.htm_marker-1031790}[]{#01.htm_marker-1031791}container.

### []{#01.htm_pgfId-1031793}1.2.4 Container standards {#01.htm_heading_id_8 .fm-head1}

[]{#01.htm_pgfId-1031796}The
[]{#01.htm_marker-1031794}[]{#01.htm_marker-1031795}OCI standards body
defined the standard formats for storing and defining container images.
They also defined the standard for container engines running containers.
The OCI created the []{#01.htm_id_Hlk113291509}OCI Image Format, which
standardizes the format of the container images and the images' JSON
file. They also created the[]{#01.htm_id_Hlk113291597} OCI Runtime
Specification, which standardized the container's JSON file to be used
by OCI runtimes. The OCI standards allow other container engines, like
Podman,[^1^](#01.htm_pgfId-1031801){.footnote} to follow the standards
and be able to work with all the images stored at container registries
and to run them in the exact same way as all other container engines,
including []{#01.htm_marker-1031802}[]{#01.htm_marker-1031803}Docker
[]{#01.htm_marker-1031804}[]{#01.htm_marker-1031805}(see figure 1.7).

## []{#01.htm_pgfId-1031807}1.3 Why use Podman when you have Docker? {#01.htm_heading_id_9 .fm-head}

[]{#01.htm_pgfId-1031809}I []{#01.htm_marker-1031808}often get asked the
question, "Why do you need Podman when you already have Docker?" Well
one reason is that *open source is all about choice*. Operating systems
have more than one editor, more than one shell, more than one
filesystem, and more than one internet web browser. I believe that
Podman's design is fundamentally better than Docker's and offers
features that advance the security and use of containers.

### []{#01.htm_pgfId-1031810}1.3.1 Why have only one way to run containers? {#01.htm_heading_id_10 .fm-head1}

[]{#01.htm_pgfId-1031813}One
[]{#01.htm_marker-1031811}[]{#01.htm_marker-1031812}of Podman's
advantages was that it was created long after Docker existed. Podman
developers looked at ways to improve on Docker's design from a totally
different perspective. Because Docker was written as open source, Podman
shares some of the code and takes advantage of new standards, like the
Open Container Initiative. Podman works with the open source community
to concentrate on developing new features.

[]{#01.htm_pgfId-1031814}In the rest of this section, I cover some of
these improvements. Table 1.2 describes and compares features available
in Podman and
[]{#01.htm_marker-1031815}[]{#01.htm_marker-1031816}Docker.

[]{#01.htm_pgfId-1033743}Table 1.2 Podman and Docker feature comparison

+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033751}Feature       | []{#01.htm_pgfId-1033753}Podman      | []{#01.htm_pgfId-1033755}Docker      | []{#01.htm_pgfId-1033757}Description |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033759}Supports all  | []{#01.htm_pgfId-1033761}[✔]{.segoe} | []{#01.htm_pgfId-1033763}[✔]{.segoe} | []{#01.htm_pgfId-1033765}Pulls and   |
| OCI and Docker images                  |                                      |                                      | runs container images from container |
|                                        |                                      |                                      | registries (i.e., quay.io and        |
|                                        |                                      |                                      | docker.io). See chapter 2.           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033767}Launches OCI  | []{#01.htm_pgfId-1033769}[✔]{.segoe} | []{#01.htm_pgfId-1033771}[✔]{.segoe} | []{#01.htm_pgfId-1033773}Launches    |
| container engines                      |                                      |                                      | `runc`{.fm-code-in-text1},           |
|                                        |                                      |                                      | `crun`{.fm-code-in-text1}, Kata,     |
|                                        |                                      |                                      | gVisor, and OCI container engines.   |
|                                        |                                      |                                      | See appendix B.                      |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033775}Simple        | []{#01.htm_pgfId-1033777}[✔]{.segoe} | []{#01.htm_pgfId-1033779}[✔]{.segoe} | []{#01.htm_pgfId-1033781}Podman and  |
| command-line interface                 |                                      |                                      | Docker share the same CLI. See       |
|                                        |                                      |                                      | chapter 2.                           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033783}Integration   | []{#01.htm_pgfId-1033785}[✔]{.segoe} | []{#01.htm_pgfId-1033787}[✘]{.segoe} | []{#01.htm_pgfId-1033789}Podman      |
| with systemd                           |                                      |                                      | supports running systemd inside the  |
|                                        |                                      |                                      | container as well as many systemd    |
|                                        |                                      |                                      | features. See chapter 7.             |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033791}Fork/exec     | []{#01.htm_pgfId-1033793}[✔]{.segoe} | []{#01.htm_pgfId-1033795}[✘]{.segoe} | []{#01.htm_pgfId-1033797}The         |
| model                                  |                                      |                                      | container is a child of the command. |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033799}Fully         | []{#01.htm_pgfId-1033801}[✔]{.segoe} | []{#01.htm_pgfId-1033803}[✘]{.segoe} | []{#01.htm_pgfId-1033805}Only Podman |
| supports user namespace                |                                      |                                      | supports running containers in       |
|                                        |                                      |                                      | separate user namespaces. See        |
|                                        |                                      |                                      | chapter 6.                           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033807}Client-server | []{#01.htm_pgfId-1033809}[✔]{.segoe} | []{#01.htm_pgfId-1033811}[✔]{.segoe} | []{#01.htm_pgfId-1033813}Docker is a |
| model                                  |                                      |                                      | REST API daemon. Podman supports     |
|                                        |                                      |                                      | REST APIs via a systemd              |
|                                        |                                      |                                      | socket-activated service. See        |
|                                        |                                      |                                      | chapter 9.                           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033815}Supports      | []{#01.htm_pgfId-1033817}[✔]{.segoe} | []{#01.htm_pgfId-1033819}[✔]{.segoe} | []{#01.htm_pgfId-1033821}Compose     |
| `docker-compose`{.fm-code-in-text1}    |                                      |                                      | scripts work against both REST APIs. |
|                                        |                                      |                                      | Podman works in rootless mode. See   |
|                                        |                                      |                                      | chapter 9.                           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033823}Supports      | []{#01.htm_pgfId-1033825}[✔]{.segoe} | []{#01.htm_pgfId-1033827}[✔]{.segoe} | []{#01.htm_pgfId-1033829}Docker-py   |
| docker-py                              |                                      |                                      | Python bindings work against both    |
|                                        |                                      |                                      | REST APIs. Podman works in rootless  |
|                                        |                                      |                                      | mode. Podman also supports podman-py |
|                                        |                                      |                                      | for running advanced features. See   |
|                                        |                                      |                                      | chapter 9.                           |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033831}Daemonless    | []{#01.htm_pgfId-1033833}[✔]{.segoe} | []{#01.htm_pgfId-1033835}[✘]{.segoe} | []{#01.htm_pgfId-1033837}The Podman  |
|                                        |                                      |                                      | command runs like a traditional      |
|                                        |                                      |                                      | command-line tool, while Docker      |
|                                        |                                      |                                      | requires multiple root-running       |
|                                        |                                      |                                      | daemons.                             |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033839}Supports      | []{#01.htm_pgfId-1033841}[✔]{.segoe} | []{#01.htm_pgfId-1033843}[✘]{.segoe} | []{#01.htm_pgfId-1033845}Podman      |
| Kubernetes-like pods                   |                                      |                                      | supports running multiple containers |
|                                        |                                      |                                      | within the same pod. See chapter 4.  |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033847}Supports      | []{#01.htm_pgfId-1033849}[✔]{.segoe} | []{#01.htm_pgfId-1033851}[✘]{.segoe} | []{#01.htm_pgfId-1033853}Podman can  |
| Kubernetes YAML                        |                                      |                                      | launch containers and pods based on  |
|                                        |                                      |                                      | Kubernetes YAML. It can also         |
|                                        |                                      |                                      | generate Kubernetes YAML from        |
|                                        |                                      |                                      | running containers. See chapter 8.   |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033855}Supports      | []{#01.htm_pgfId-1033857}[✘]{.segoe} | []{#01.htm_pgfId-1033859}[✔]{.segoe} | []{#01.htm_pgfId-1033861}Podman      |
| Docker Swarm                           |                                      |                                      | believes the future for orchestrated |
|                                        |                                      |                                      | multinode containers is Kubernetes   |
|                                        |                                      |                                      | and does not plan on implementing    |
|                                        |                                      |                                      | Swarm.                               |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033863}Customizable  | []{#01.htm_pgfId-1033865}[✔]{.segoe} | []{#01.htm_pgfId-1033867}[✘]{.segoe} | []{#01.htm_pgfId-1033869}Podman      |
| registries                             |                                      |                                      | allows you to configure registries   |
|                                        |                                      |                                      | for short-name expansion. Docker is  |
|                                        |                                      |                                      | hardcoded to docker.io when you      |
|                                        |                                      |                                      | specify a short name. See chapter 5. |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033871}Customizable  | []{#01.htm_pgfId-1033873}[✔]{.segoe} | []{#01.htm_pgfId-1033875}[✘]{.segoe} | []{#01.htm_pgfId-1033877}Podman      |
| defaults                               |                                      |                                      | supports fully customizing all of    |
|                                        |                                      |                                      | its defaults, including security,    |
|                                        |                                      |                                      | namespaces, and volumes. See chapter |
|                                        |                                      |                                      | 5.                                   |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033879}macOS support | []{#01.htm_pgfId-1033881}[✔]{.segoe} | []{#01.htm_pgfId-1033883}[✔]{.segoe} | []{#01.htm_pgfId-1033885}Podman and  |
|                                        |                                      |                                      | Docker support running containers on |
|                                        |                                      |                                      | a Mac via a VM running Linux. See    |
|                                        |                                      |                                      | appendix E.                          |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033887}Windows       | []{#01.htm_pgfId-1033889}[✔]{.segoe} | []{#01.htm_pgfId-1033891}[✔]{.segoe} | []{#01.htm_pgfId-1033893}Podman and  |
| support                                |                                      |                                      | Docker support running containers on |
|                                        |                                      |                                      | a Windows WSL 2 or a VM running      |
|                                        |                                      |                                      | Linux. See appendix F.               |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033895}Linux support | []{#01.htm_pgfId-1033897}[✔]{.segoe} | []{#01.htm_pgfId-1033899}[✔]{.segoe} | []{#01.htm_pgfId-1033901}Podman and  |
|                                        |                                      |                                      | Docker are supported on all major    |
|                                        |                                      |                                      | Linux distributions. See appendix C. |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#01.htm_pgfId-1033903}Containers    | []{#01.htm_pgfId-1033905}[✔]{.segoe} | []{#01.htm_pgfId-1033907}[✘]{.segoe} | []{#01.htm_pgfId-1033909}Podman is   |
| aren't stopped on software upgrade.    |                                      |                                      | not required to remain running when  |
|                                        |                                      |                                      | containers are running. Since the    |
|                                        |                                      |                                      | Docker daemon is monitoring          |
|                                        |                                      |                                      | containers, by default, when it      |
|                                        |                                      |                                      | stops, all containers stop.          |
+----------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+

### []{#01.htm_pgfId-1031982}1.3.2 Rootless containers {#01.htm_heading_id_11 .fm-head1}

[]{#01.htm_pgfId-1031986}Probably
[]{#01.htm_marker-1031983}[]{#01.htm_marker-1031984}[]{#01.htm_marker-1031985}the
most significant feature of Podman is its ability to run in rootless
mode. In many situations, you do not want to give full root access to
your users, but users and developers still need to run containers and
build container images. Requiring root access prevents lots of
security-conscious companies from widespread adoption of Docker. Podman,
on the other hand, can run containers with no additional security
features in Linux other than a standard login account.

[]{#01.htm_pgfId-1031987}You can run the Docker client as a normal user
by adding the user to the Docker user group (/etc/group), but I believe
granting this access is one of the most dangerous things you can do on a
Linux machine. Access to the docker.sock allows you to gain full root
access on the host by running the following command. In the command, you
are mounting the entire host operating system / on the /host directory
within the container. The `--privileged`{.fm-code-in-text}
flag[]{#01.htm_marker-1031988} turns off all container security, and
then you `chroot`{.fm-code-in-text} to /host. After the
`chroot`{.fm-code-in-text}, you are in a root shell at / of the
operating system, with full root privileges:

``` programlisting
$ docker run -ti --name hacker --privileged -v /:/host ubi8  chroot /host
#
```

[]{#01.htm_pgfId-1031991}At this point, you have full root privileges on
the machine, and you can do whatever you want. When you are done hacking
the machine, you can simply execute the `docker`{.fm-code-in-text}
`rm`{.fm-code-in-text} command[]{#01.htm_marker-1031992} to remove the
container and all records of what you did:

``` programlisting
$ docker rm hacker
```

[]{#01.htm_pgfId-1031994}When Docker is configured with default file
logging, all records of your launching the container are erased. I
believe this is far worse than setting up `sudo`{.fm-code-in-text}
without root, in that at least with `sudo`{.fm-code-in-text}, you have
the chance to see that `sudo`{.fm-code-in-text} was run in your log
files.

[]{#01.htm_pgfId-1031995}With Podman the processes running on the system
are always owned by the user and have no capabilities greater than a
normal user. Even if you break out of the container, the process is
still running as your UID, and all actions on the system are recorded in
the audit logs. Users of Podman cannot simply remove the container and
cover up their tracks. See chapter 6 for more
[]{#01.htm_marker-1031996}[]{#01.htm_marker-1031997}[]{#01.htm_marker-1031998}information.

[]{#01.htm_pgfId-1031999}[Note]{.fm-callout-head} Docker now has the
ability to run rootless similarly to Podman, but almost no one runs it
that way. Starting up multiple services in your home directory just to
launch a single container has not caught on.

### []{#01.htm_pgfId-1032001}1.3.3 Fork/exec model {#01.htm_heading_id_12 .fm-head1}

[]{#01.htm_pgfId-1032010}Docker
[]{#01.htm_marker-1032008}[]{#01.htm_marker-1032009}is built as a REST
API server. Fundamentally Docker is a client-server architecture
including multiple daemons. When a user executes the Docker client, they
execute a command-line tool that connects to the Docker daemon. The
Docker daemon then pulls images to its storage and then connects to the
containerd daemon, which finally executes an OCI runtime that creates
the container. The Docker daemon, then, is a communication platform that
communicates reads and writes of `stdin`{.fm-code-in-text},
`stdout`{.fm-code-in-text}, and `stderr`{.fm-code-in-text} from the
initial process (PID1) created in the container. The daemon relays all
of the output back to the Docker client. Users imagine the container's
processes are just children of the current session, but there is a lot
of communication going on behind the scenes. Figure 1.8 shows the Docker
client-server architecture.

::: figure
![](images/01-08.png){.calibre18}

[]{#01.htm_pgfId-1041223}Figure 1.8 Docker client-server architecture.
The container is a direct descendant of containerd, not the Docker
client. The kernel sees no relationship between the client program and
the container.
:::

[]{#01.htm_pgfId-1032011}The bottom line is the Docker client
communicates with the Docker daemon, which then communicates with the
containerd daemon, which finally launches an OCI runtime like
`runc`{.fm-code-in-text}[]{#01.htm_marker-1032012} to launch PID1 of the
container. There is a lot of complexity involved in running containers
in this way. Over the years, failures in any of the Daemons have led to
all containers shutting down, and it is often difficult to diagnose what
happened. The core Podman engineering team comes from an operating
system background grounded in the Unix philosophy.

[]{#01.htm_pgfId-1032021}Unix and C were designed with the fork/exec
model of computing. Basically, when you execute a new program, a parent
program like the Bash shell forks a new process and then executes the
new program as a child of the old program. The Podman engineering team
thought they could make containers simpler by building a tool that pulls
container images from a container registry, configures container
storage, and then launches an OCI runtime, which starts the container as
a child of your container engine.

[]{#01.htm_pgfId-1032022}In the Unix operating system, processes can
share content via the filesystem and inter-process communication (IPC)
mechanisms. These features of the operating system enable multiple
container engines to share storage without requiring a daemon to be
running to control access and share content. The engines do not need to
communicate together aside from using locking mechanisms provided by the
operating system's filesystems. Future chapters examine the advantages
and disadvantages of this mechanism. Figure 1.9 shows the Podman
architecture and communication
[]{#01.htm_marker-1032023}[]{#01.htm_marker-1032024}flow.

::: figure
![](images/01-09.png){.calibre18}

[]{#01.htm_pgfId-1041268}Figure 1.9 Podman fork/exec architecture. The
user launches Podman, which executes the OCI runtime, which then
launches the container. The container is a direct descendant of Podman.
:::

### []{#01.htm_pgfId-1032026}1.3.4 Podman is daemonless {#01.htm_heading_id_13 .fm-head1}

[]{#01.htm_pgfId-1032029}Podman
[]{#01.htm_marker-1032027}[]{#01.htm_marker-1032028}is fundamentally
different from Docker because it is daemonless. Podman can run all of
the same container images as Docker and launch containers with the same
container runtimes. However, Podman does this without having multiple
continuously root-running daemons.

[]{#01.htm_pgfId-1032030}Imagine you have a web service that you want to
run at boot time. The web service is packaged in a container, so you
need a container engine. In the Docker case, you need to set it up to be
running on your machine with each of the daemons running and accepting
connections. Next, launch the Docker client to start the web service.
Now you have your containerized application running as well as all of
the Docker daemons. In the Podman case, use the Podman command to launch
your container, and Podman will go away. Your container will continue to
run without the overhead of running the multiple daemons. Less overhead
is incredibly popular on low-end machines like IOT devices and edge
[]{#01.htm_marker-1032031}[]{#01.htm_marker-1032032}servers.

### []{#01.htm_pgfId-1032034}1.3.5 User-friendly command line {#01.htm_heading_id_14 .fm-head1}

[]{#01.htm_pgfId-1032037}One
[]{#01.htm_marker-1032035}[]{#01.htm_marker-1032036}of the great
features of Docker is the simple command-line interface. There have been
other container command lines like `RKT`{.fm-code-in-text},
`lxc`{.fm-code-in-text}, and `lxcd`{.fm-code-in-text}, but they have
their own command-line interfaces. The Podman team realized early on
that it wouldn't gain market share if Podman had its own command-line
interface. Docker was the dominant tool, and almost everyone who had
played with containers had done it with its CLI. In addition, if you
were to search how to do something with a container online, invariably
you would get an example using the Docker command line. Right from the
start, Podman had to match the Docker command line. A motto for
replacing Docker with Podman was quickly developed:
`alias`{.fm-code-in-text} `Docker`{.fm-code-in-text}
`=`{.fm-code-in-text} `Podman`{.fm-code-in-text}.

[]{#01.htm_marker-1032050}[]{#01.htm_pgfId-1032038}With this command,
you can continue to type in your Docker commands, but Podman runs your
containers. If the Podman command line differs from Docker, it is
considered a bug in Podman, and users demand Podman to be fixed to make
the tools match. There are a few commands, such as Docker Swarm, that
Podman doesn't support, but for the most part, Podman is a complete
replacement for the Docker CLI.

[]{#01.htm_pgfId-1032040}Many distributions supply a package called
`podman-docker`{.fm-code-in-text}[]{#01.htm_marker-1040308}, which
changes the alias from *docker* to *podman* and links the man page. The
alias means when you type `docker`{.fm-code-in-text}
`ps`{.fm-code-in-text}, the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#01.htm_marker-1040310} runs. If you
execute `man`{.fm-code-in-text} `docker`{.fm-code-in-text}
`ps`{.fm-code-in-text}, the Podman `ps`{.fm-code-in-text} man pages show
up. Figure 1.10 is a twitter message from a Podman user who aliased the
`docker`{.fm-code-in-text} command to `podman`{.fm-code-in-text}, and
was surprised to remember he had been using Podman for two months while
thinking he was using Docker.

::: figure
![](images/01-10.png){.calibre18}

[]{#01.htm_pgfId-1041309}Figure 1.10 Tweet about "alias docker='podman'"
:::

[]{#01.htm_pgfId-1032048}Back in 2018, Alan Moran tweeted, "I completely
forgot that \~2 months ago I set up 'alias docker="podman"' and it has
been a dream. #nobigfatdaemons\...". Joe Thomson responded, "So, what
reminded you?" and Alan Moran answered "docker help." And Podman help
showed []{#01.htm_marker-1040318}[]{#01.htm_marker-1040319}up.

### []{#01.htm_pgfId-1032052}1.3.6 Support for REST API {#01.htm_heading_id_15 .fm-head1}

[]{#01.htm_pgfId-1032055}Podman
[]{#01.htm_marker-1032053}[]{#01.htm_marker-1032054}can be run as a
socket-activated REST API service. This allows remote clients to manage
and launch Podman containers. Podman supports the Docker API as well as
the Podman API for advanced Podman features. Through the use of the
Docker API, Podman supports `docker-compose`{.fm-code-in-text} and other
users of the docker-py Python bindings[]{#01.htm_marker-1032056}. This
means that even if you built your infrastructure around using the Docker
socket for launching containers, you can simply replace Docker with the
Podman service and continue to use your existing scripts and tools.
Chapter 9 covers the Podman service.

[]{#01.htm_pgfId-1032057}The Podman REST API also allows remote Podman
clients on Mac, Windows, and Linux systems to interact with Podman
containers on a Linux machine. Appendixes E and F cover Podman use on
Mac and Windows
[]{#01.htm_marker-1032058}[]{#01.htm_marker-1032059}machines.

### []{#01.htm_pgfId-1032061}1.3.7 Integration with systemd {#01.htm_heading_id_16 .fm-head1}

[]{#01.htm_pgfId-1032064}Systemd
[]{#01.htm_marker-1032062}[]{#01.htm_marker-1032063}is the fundamental
init system in the operating systems. The init process on a Linux system
is the first process that is started by the kernel on boot. Therefore,
the init system is the ancestor of all processes and can monitor them
all. Podman wants to fully integrate the running of containers with the
init system. Users want to use systemd to start and stop containers at
boot time. Containers should do the following:

- []{#01.htm_pgfId-1032065 .calibre17}Support systemd within a container

- []{#01.htm_pgfId-1032066 .calibre17}Support socket activation

- []{#01.htm_pgfId-1032067 .calibre17}Support systemd notifications that
  a containerized application is fully activated

- []{#01.htm_pgfId-1032068 .calibre17}Allow systemd to fully manage the
  cgroups and lifespan of a containerized application

[]{#01.htm_pgfId-1032069}Basically, containers work as services in
systemd unit files. Many developers want to run systemd within a
container to run multiple system-defined services within a container.

[]{#01.htm_pgfId-1032070}However, the upstream Docker community
disagrees with this and has denied all pull requests that attempt to
integrate systemd into Docker. They believe Docker should manage the
life cycle of the container, and they do not want to accommodate users
who want to run systemd in a container.

[]{#01.htm_pgfId-1032077}The upstream Docker community believes the
Docker daemon, as opposed to systemd, should be the controller of
processes, it should manage the life cycle of containers, and it should
start and stop them at boot time. The problem is there are many more
features in systemd than in Docker, including startup ordering, socket
activation, service ready notifications, and so on. Figure 1.11 is an
actual badge of a Docker employee at the first DockerCon, illustrating
their hostility towards systemd.

::: figure
![](images/01-11.png){.calibre18}

[]{#01.htm_pgfId-1041347}Figure 1.11 Docker employee badge at DockerCon
EU
:::

[]{#01.htm_pgfId-1032078}When Podman was designed, the developers wanted
to make sure it fully integrated with systemd. When you run systemd
inside a container, Podman sets up the container the way systemd expects
and allows it to simply run as PID1 of the container with limited
privileges. Podman allows you to run services within the container the
same way they run on a system or in a VM: via systemd unit files. Podman
supports socket activation, service notifications, and many other
systemd unit file features. Podman makes it simple to generate systemd
unit files with best practices for running containers within a systemd
service. For more information, see chapter 7 on systemd integration.

[]{#01.htm_pgfId-1032079}The Containers project
([https://github.com/containers](https://github.com/containers){.url})
where Podman, container libraries, and other container management tools
reside, wants to embrace all features of the operating system and fully
integrate it. Chapter 7 explains Podman integration with
[]{#01.htm_marker-1032080}[]{#01.htm_marker-1032081}systemd.

### []{#01.htm_pgfId-1032083}1.3.8 Pods {#01.htm_heading_id_17 .fm-head1}

[]{#01.htm_pgfId-1032092}One
[]{#01.htm_marker-1032090}[]{#01.htm_marker-1032091}advantage of Podman
is described in its name. As mentioned earlier, *Podman* is actually
short for *Pod Manager*. As the official Kubernetes documentation puts
it, "A pod (as in a pod of seals, hence the logo, or pea pod) is a group
of one or more containers, with shared storage/network resources, and a
specification for how to run the containers." Podman works with either a
single container at a time, like Docker, or it can manage groups of
containers together in a pod. One of the design goals of containers is
to separate services into single containers: microservices. Then you
combine containers together to build larger services. Pods allow you to
group multiple services together to form a larger service managed as a
single entity. One of the goals of Podman is allowing you to experiment
with pods. Figure 1.12 shows two pods running on a system, each pod
containing three containers.

::: figure
![](images/01-12.png){.calibre18}

[]{#01.htm_pgfId-1041385}Figure 1.12 Two pods running on a host. Each
pod runs two different containers along with the infra container.
:::

[]{#01.htm_pgfId-1032094}Podman has the `podman`{.fm-code-in-text}
`generate`{.fm-code-in-text} `kube`{.fm-code-in-text}
command[]{#01.htm_marker-1032093}, which allows you to generate
Kubernetes YAML files from running containers and pods, as you can see
in chapter 7. Similarly, it has the `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}
command[]{#01.htm_marker-1032095}, which allows you to play Kubernetes
YAML files and generate pods and containers on your host. I suggest
using Podman for running pods and containers on a single host and using
Kubernetes to take your pods and containers and run them on multiple
machines and all through your infrastructure. Other projects, like kind
([https://kind.sigs.k8s.io/docs/user/rootless](https://kind.sigs.k8s.io/docs/user/rootless){.url}),
are experimenting with running pods with Podman under the guidance of
[]{#01.htm_marker-1032096}[]{#01.htm_marker-1032097}Kubernetes.

### []{#01.htm_pgfId-1032099}1.3.9 Customizable registries {#01.htm_heading_id_18 .fm-head1}

[]{#01.htm_pgfId-1032102}Container
[]{#01.htm_marker-1039161}[]{#01.htm_marker-1039162}engines like Podman
support the concept of pulling images using short names, such as ubi8,
without specifying the registry in which they reside:
[registry.access.redhat.com](http://registry.access.redhat.com){.url}.
Complete image names include the name of the container registry they
were pulled from:
[registry.access.redhat.com/library/ubi8:latest](http://registry.access.redhat.com/library/ubi8:latest){.url}.
Table 1.3 shows the components of the image name broken out.

[]{#01.htm_pgfId-1034593}Table 1.3 Short name to container image name
table

+-----------------------------------+-----------------------------------------------------+----------------------------------+-------------------------------+------------------------------------------------------+
| []{#01.htm_pgfId-1034603}Name     | []{#01.htm_pgfId-1034605}Registry                   | []{#01.htm_pgfId-1034607}Repo    | []{#01.htm_pgfId-1034609}Name | []{#01.htm_pgfId-1034611}Tag                         |
+-----------------------------------+-----------------------------------------------------+----------------------------------+-------------------------------+------------------------------------------------------+
| []{#01.htm_pgfId-1034613}Short    | []{#01.htm_pgfId-1034615}                           | []{#01.htm_pgfId-1034617}        | []{#01.htm_pgfId-1034619}ubi8 | []{#01.htm_pgfId-1034621}                            |
| name                              |                                                     |                                  |                               |                                                      |
+-----------------------------------+-----------------------------------------------------+----------------------------------+-------------------------------+------------------------------------------------------+
| []{#01.htm_pgfId-1034623}Complete | []{#01.htm_pgfId-1034625}registry.access.redhat.com | []{#01.htm_pgfId-1034627}library | []{#01.htm_pgfId-1034629}ubi8 | []{#01.htm_pgfId-1034631}`latest`{.fm-code-in-text1} |
| name                              |                                                     |                                  |                               |                                                      |
+-----------------------------------+-----------------------------------------------------+----------------------------------+-------------------------------+------------------------------------------------------+

[]{#01.htm_pgfId-1032137}Docker is hardcoded to always pull from
[https://docker.io](https://docker.io){.url} when using a short name. If
you want to pull an image from a different container registry, you must
fully specify the image. In the following example, I attempt to pull
ubi8/httpd-24, and it fails because the container image is not on
docker.io. The image is on
[registry.access.redhat.com](http://registry.access.redhat.com){.url}:

``` programlisting
# docker pull ubi8/httpd-24
Using default tag: latest
Error response from daemon: pull access denied for ubi8/httpd-24, 
repository does not exist or may require 'docker login': denied: requested 
access to the resource is denied
```

[]{#01.htm_pgfId-1032143}So if I want to use ubi8/httpd-24, I am forced
to type the entire name, including the registry:

``` programlisting
# docker pull registry.access.redhat.com/ubi8/httpd-24
```

[]{#01.htm_pgfId-1032145}The Docker engine gives docker.io an advantage
over other container registries as the preferred registry. Podman was
designed to allow you to specify multiple registries, like what you can
do with `dnf`{.fm-code-in-text}[]{#01.htm_marker-1032146},
`yum`{.fm-code-in-text}[]{#01.htm_marker-1032147}, and
`apt`{.fm-code-in-text} tools[]{#01.htm_marker-1032148} for installing
packages. You can even remove docker.io from the list. If you attempt to
pull ubi8/httpd-24 with Podman, Podman presents you with a list of
registries to choose from:

``` programlisting
$ podman pull ubi8/httpd-24
? Please select an image:  
    registry.fedoraproject.org/ubi8/httpd-24:latest
       ▸ registry.access.redhat.com/ubi8/httpd-24:latest
    docker.io/ubi8/httpd-24:latest
    quay.io/ubi8/httpd-24:latest
```

[]{#01.htm_pgfId-1032155}Once you make your decision, Podman records the
short-name alias and no longer prompts and uses the previously selected
registry. Podman supports lots of other features, like blocking
registries, only pulling signed images, setting up image mirrors, and
specifying hardcoded short names, so specific short names map directly
to the long names
[]{#01.htm_marker-1032156}[]{#01.htm_marker-1032157}(see chapter 5).

### []{#01.htm_pgfId-1032159}1.3.10 Multiple transports {#01.htm_heading_id_19 .fm-head1}

[]{#01.htm_pgfId-1032162}Podman
[]{#01.htm_marker-1032160}[]{#01.htm_marker-1032161}supports many
different container image sources and targets called *transports* (see
table 1.4). Podman can pull images from container registries and from
local containers storage but also supports images stored in OCI format,
OCI []{#01.htm_id_Hlk113306446}TAR format, legacy Docker TAR format,
directory format, and images directly from the Docker daemon. Podman
commands can easily run images from each of the
[]{#01.htm_marker-1032164}[]{#01.htm_marker-1032165}formats.

[]{#01.htm_pgfId-1035235}Table 1.4 Podman-supported transports

+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035239}Transport                                                                              | []{#01.htm_pgfId-1035241}Description                   |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035243}Container registry(`docker`{.fm-code-in-text1}[]{#01.htm_marker-1035270})              | []{#01.htm_pgfId-1035245}References a container image  |
|                                                                                                                 | stored in a remote container image registry website.   |
|                                                                                                                 | Registries store and share container images (e.g.,     |
|                                                                                                                 | docker.io and quay.io).                                |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035247}`oci`{.fm-code-in-text1}[]{#01.htm_marker-1035271}                                     | []{#01.htm_pgfId-1035249}References a container image  |
|                                                                                                                 | compliant with OCI layout specifications. The manifest |
|                                                                                                                 | and layer tarballs are located in the local directory  |
|                                                                                                                 | as individual files.                                   |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035251}`dir`{.fm-code-in-text1}[]{#01.htm_marker-1035272}                                     | []{#01.htm_pgfId-1035253}References a container image  |
|                                                                                                                 | compliant with the Docker image layout, similar to the |
|                                                                                                                 | `oci`{.fm-code-in-text1} transport but storing the     |
|                                                                                                                 | files using the legacy `docker`{.fm-code-in-text1}     |
|                                                                                                                 | format.                                                |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035255}`docker-archive`{.fm-code-in-text1}[]{#01.htm_marker-1035273}                          | []{#01.htm_pgfId-1035257}References a container image  |
|                                                                                                                 | in a Docker image layout that is packed into a TAR     |
|                                                                                                                 | archive.                                               |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035259}`oci-archive`{.fm-code-in-text1}                                                       | []{#01.htm_pgfId-1035261}References a container image  |
|                                                                                                                 | compliant with OCI layout specifications that is       |
|                                                                                                                 | packed into a TAR archive.                             |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035263}`docker-daemon`{.fm-code-in-text1}[]{#01.htm_marker-1035274}[]{#01.htm_marker-1035275} | []{#01.htm_pgfId-1035265}References an image stored in |
|                                                                                                                 | the Docker daemon's internal storage.                  |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+
| []{#01.htm_pgfId-1035267}`container-storage`{.fm-code-in-text1}[]{#01.htm_marker-1035276}                       | []{#01.htm_pgfId-1035269}References a container image  |
|                                                                                                                 | located in a local storage. Podman defaults to using   |
|                                                                                                                 | container storage for local images.                    |
+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------+

### []{#01.htm_pgfId-1032211}1.3.11 Complete customizability {#01.htm_heading_id_20 .fm-head1}

[]{#01.htm_pgfId-1032214}Container
[]{#01.htm_marker-1032212}[]{#01.htm_marker-1032213}engines tend to have
lots of built-in constants, like the namespaces they run with, whether
or not SELinux is enabled, and which capabilities containers run with.
With Docker, most of these values are hardcoded and cannot be changed by
default. Podman, on the other hand, has a very customizable
configuration.

[]{#01.htm_pgfId-1032215}Podman has its built-in defaults but defines
three locations for its configuration files to be stored:

- []{#01.htm_pgfId-1032216
  .calibre17}*/usr/share/containers/containers.conf*---Where a
  distribution can define the changes the distribution likes to use

- []{#01.htm_pgfId-1032217
  .calibre17}*/etc/containers/containers.conf*---Where they can set up
  system overrides

- []{#01.htm_pgfId-1032218
  .calibre17}*\$HOME/.config/containers/containers.conf*---Can be
  specified only in rootless mode

[]{#01.htm_pgfId-1032219}The configuration files allow you to configure
Podman to run the way you want by default. You can even run with more
security by default if you
[]{#01.htm_marker-1032220}[]{#01.htm_marker-1032221}choose.

### []{#01.htm_pgfId-1032223}1.3.12 User-namespace support {#01.htm_heading_id_21 .fm-head1}

[]{#01.htm_pgfId-1032226}Podman
[]{#01.htm_marker-1032224}[]{#01.htm_marker-1032225}is fully integrated
with the user namespace. Rootless mode relies on user namespaces, which
allows for multiple UIDs to be assigned to a user. User namespaces
provide isolation between users on a system, so you can have multiple
rootless users running containers with multiple user IDs, all isolated
from each other.

[]{#01.htm_pgfId-1032227}A user namespace can be used to isolate
containers from each other. Podman makes it simple to launch multiple
containers, each with a unique user namespace. The kernel then isolates
the processes from host users as well as each other based on UID
separation.

[]{#01.htm_pgfId-1032228}Docker only supports running containers in a
single, separate, user namespace, meaning all containers run within the
same user namespace. Root in one container is the same as root in
another container. It does not support running each container in a
different user namespace, which means containers attack each other from
a user-namespace perspective. Even though Docker supports this mode,
almost no one runs containers with Docker in a separate
[]{#01.htm_marker-1032229}[]{#01.htm_marker-1032230}user
[]{#01.htm_marker-1032231}namespace.

## []{#01.htm_pgfId-1032233}1.4 When not to use Podman {#01.htm_heading_id_22 .fm-head}

[]{#01.htm_pgfId-1032235}Like []{#01.htm_marker-1032234}Docker, Podman
is not a container orchestrator. Podman is a tool for running container
workloads on a single host in either rootless or rootful mode.
Higher-level tools are required if you want to orchestrate running
containers on multiple machines.

[]{#01.htm_pgfId-1032236}I believe the best tool for doing this now is
Kubernetes. Kubernetes won the container orchestrator war when it comes
to mind share. Docker has an orchestrator called Swarm, which had some
popularity, but it now seems to be out of favor. Because the Podman team
believes Kubernetes is the way to go for containers on multiple
machines, Podman does not support Swarm functionality. Podman has been
used for different orchestrators and is used for grid/HPC computing, and
open source developers have even added it to Kubernetes
[]{#01.htm_marker-1032237}frontends.

## []{#01.htm_pgfId-1032239}Summary {#01.htm_heading_id_23 .fm-head}

- []{#01.htm_pgfId-1032240 .calibre17}Containers technology has been
  around for many years, but the introduction of container images and
  container registries allows developers a better way to ship software.

- []{#01.htm_pgfId-1032241 .calibre17}Podman is an excellent container
  engine, suitable for almost all of your single-node container
  projects. It is useful for developing, building, and running
  containerized applications.

- []{#01.htm_pgfId-1032242 .calibre17}Podman is as simple to use as
  Docker, with the exact same command-line interface.

- []{#01.htm_pgfId-1032243 .calibre17}Podman supports a REST API, which
  allows remote tools and languages, including
  `docker-compose`{.fm-code-in-text}, to work with Podman containers.

- []{#01.htm_pgfId-1032244 .calibre17}Unlike Docker, Podman includes
  such notable features as user-namespace support, multiple transports,
  customizable registries, integration with systems, the fork/exec
  model, and out-of-the-box rootless mode.

- []{#01.htm_pgfId-1032247 .calibre17}Podman is a more secure way to run
  []{#01.htm_marker-1032245
  .calibre17}containers.[]{#01.htm_id_ozj4usjlhjc6 .calibre17}

------------------------------------------------------------------------

^1^ []{#01.htm_pgfId-1031801}Other container engines include Buildah,
CRI-O, containerd, and many others.

[]{#02.htm}

# []{#02.htm_pgfId-1040189}[]{#02.htm_id_sira8yl9f04n}[]{#02.htm_pgfId-1037520}2 Command line {#02.htm_heading_id_2 .tochead}

[]{#02.htm_pgfId-1037523}[]{#02.htm_id_z8ffg99snoiy}This chapter
[]{#02.htm_marker-1040231}covers

- []{#02.htm_pgfId-1037524 .calibre17}The Podman command line
- []{#02.htm_pgfId-1037525 .calibre17}Running an OCI application
- []{#02.htm_pgfId-1037526 .calibre17}Comparing containers and images
- []{#02.htm_pgfId-1037527 .calibre17}Building an OCI-based image

[]{#02.htm_pgfId-1037528}Podman is an excellent tool for running and
building containerized applications. In this chapter, you'll get started
by building a simple web application to demonstrate commonly used
features of the Podman command line.

[]{#02.htm_pgfId-1037529}If you don't have Podman installed on your
machine, you can jump to appendix C, and then return here. This chapter
assumes that Podman 4.1 or later is already installed. Older versions of
Podman probably work fine, but all examples were tested with Podman 4.1.
The example base image I use is the
registry.access.redhat.com/ubi8/httpd-24 image.

[]{#02.htm_pgfId-1037531}[Note]{.fm-callout-head} Universal Base Images
(UBI[]{#02.htm_marker-1037530}) can be used anywhere, but container
software maintained and vetted by Red Hat as well as run on a Red Hat
operating system is fully supported. There are hundreds of Apache images
that work similarly to this image that you can also try out.

[]{#02.htm_pgfId-1037535}Chapter 2 shows how Podman is a great tool for
working with containers. In this chapter, I walk you through running the
scenario you might use to build a containerized application. You launch
a container, modify its contents, create an image, and ship it to a
registry. Then I explain how you can do this in an automated way to
maintain the security of your container image. Through it all, you will
be exposed to many of the Podman command-line interfaces and get a good
understanding of how to work with Podman.

[]{#02.htm_pgfId-1037536}If you are an experienced Docker user, you
probably just want to skim through this chapter. You will know a lot of
it, but there are many features unique to Podman, such as the ability to
mount container images (section 2.2.10) and different transports
(section 2.2.4). Let's start by running our first container.

[]{#02.htm_pgfId-1037539}[Note]{.fm-callout-head} Podman is an open
source project under heavy development. Podman is packaged and provided
on many different Linux distributions as well as Mac and Windows. These
distributions might be shipping older versions of Podman without some of
the current features covered in this book. Some examples in this book
assume you are using Podman 4.1 or later. If an example does not work,
please update your version of Podman to the latest version. Refer to
appendix C for further information on installing Podman.

## []{#02.htm_pgfId-1037546}2.1 Working with containers {#02.htm_heading_id_3 .fm-head}

[]{#02.htm_pgfId-1037549}There
[]{#02.htm_marker-1037547}[]{#02.htm_marker-1037548}are thousands of
different container images sitting at container registries. Developers,
administrators, quality engineers, and general users primarily use the
`podman`{.fm-code-in-text} `run`{.fm-code-in-text}
command[]{#02.htm_marker-1037550} to pull down and run, test, or explore
these container images. To start building out containerized
applications, the first thing you need to do is start working with a
base image. In our examples, you pull and run the
registry.access.redhat.com/ubi8/httpd-24 image to container storage in
your home directory and start exploring inside the container.

### []{#02.htm_pgfId-1037552}2.1.1 Exploring containers {#02.htm_heading_id_4 .fm-head1}

[]{#02.htm_pgfId-1037555}In
[]{#02.htm_marker-1037553}[]{#02.htm_marker-1037554}this section, you
will examine a typical Podman command, step by step. You will execute
the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
command[]{#02.htm_marker-1037556}, which reaches out to the
registry.access.redhat.com container registry[]{#02.htm_marker-1037557}
and begins pulling down the image and storing it locally in your home
directory:

``` programlisting
$ podman run -ti --rm registry.access.redhat.com/ubi8/httpd-24 bash
```

[]{#02.htm_pgfId-1037559}Now I will break down the command you just
executed. By default the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#02.htm_marker-1037560} executes the
containerized command in the foreground until the container exits. In
this case, you end up at a Bash prompt running within the container and
showing the `bash-4.4$`{.fm-code-in-text} prompt. When you exit this
Bash prompt, Podman stops the container.

[]{#02.htm_pgfId-1037563}In this example, you used two options:
`-t`{.fm-code-in-text}[]{#02.htm_marker-1037561} and
`-i`{.fm-code-in-text}[]{#02.htm_marker-1037562}, as
`-ti`{.fm-code-in-text}, which tells Podman to hook up to the terminal.
This connects to the input, output, and error stream of the
`bash`{.fm-code-in-text} process within the container to your screen,
which allows you to interact within the container:

``` programlisting
$ podman run -ti --rm registry.access.redhat.com/ubi8/httpd-24 bash
```

[]{#02.htm_pgfId-1037569}The `--rm`{.fm-code-in-text}
option[]{#02.htm_marker-1037568} tells Podman to delete the container as
soon as the container exits, freeing up all of the container's storage:

``` programlisting
$ podman run -ti --rm registry.access.redhat.com/ubi8/httpd-24 bash
```

[]{#02.htm_pgfId-1037571}Next, specify the container image,
registry.access.redhat.com/ubi8/httpd-24, you are working with. The
`podman`{.fm-code-in-text} command[]{#02.htm_marker-1037572} reaches out
to the container registry at registry.access.redhat.com and begins
copying down the ubi8/httpd-24:latest image. Podman copies multiple
layers (aka blobs), as shown in the following listing, and stores them
in the local container storage. You see the progress as the image layers
are pulled down. Some images are rather large and can take a long time
while being pulled down. If you later run a different container on the
same image, Podman skips the image-pulling step, since you already have
the correct image in local container storage.

[]{#02.htm_pgfId-1037573}Listing 2.1 Pulling and running a container
image from a registry

``` programlisting
$ podman run -ti --rm registry.access.redhat.com/ubi8/httpd-24 bash
Trying to pull registry.access.redhat.com/
➥ ubi8/httpd-24:latest...                                   ❶
Getting image source signatures
Checking if image destination supports signatures        
Copying blob 296e14ee2414 skipped: already exists            ❷
Copying blob 356f18f3a935 skipped: already exists            ❷
Copying blob 359fed170a21                                    ❷
➥ [========================>---------] 11.8MiB / 16.2MiB    ❷
Copying blob 226cafc3a0c6                                    ❷
➥ [=====>----------------------------]                      ❷
➥ 10.1MiB / 61.1MiB                                         ❷
```

[]{#02.htm_pgfId-1051969}[❶]{.fm-combinumeral} Contact with the registry

[]{#02.htm_pgfId-1051997}[❷]{.fm-combinumeral} Layer pulling is skipped.

[]{#02.htm_pgfId-1037588}Finally, specify the executable to be run
within the container, in this case, `bash`{.fm-code-in-text}:

``` programlisting
$ podman run -ti --rm registry.access.redhat.com/ubi8/httpd-24 bash 
...
bash-4.4$
```

[]{#02.htm_pgfId-1037592}[Note]{.fm-callout-head} Images almost always
have default commands they execute. You only have to specify a command
if you want to override the default application the image runs with. In
the case of the registry.access.redhat.com/ubi8/httpd-24 image, it runs
the Apache web server.

[]{#02.htm_pgfId-1037593}While inside the bash shell container, cat
/etc/os-release, and notice it is likely a different OS or a different
version than the /etc/os-release outside the container. Explore around
in the container, and notice how different it is from your host
environment:

``` programlisting
bash-4.4$ grep PRETTY_NAME /etc/os-release 
PRETTY_NAME="Red Hat Enterprise Linux 8.4 (Ootpa)"
```

[]{#02.htm_pgfId-1037596}On my host on a different terminal, the same
command outputs

``` programlisting
$ grep PRETTY_NAME /etc/os-release 
PRETTY_NAME="Fedora Linux 35 (Workstation Edition Prerelease)"
```

[]{#02.htm_pgfId-1037599}Back inside the container, you will notice
there are a lot fewer commands available:

``` programlisting
bash-4.4$ ls /usr/bin | wc -l
525
```

[]{#02.htm_pgfId-1037602}However, on the host you see

``` programlisting
$ ls -l /usr/bin | wc -l
3303
```

[]{#02.htm_pgfId-1037606}Execute the `ps`{.fm-code-in-text}
command[]{#02.htm_marker-1037605} to see what processes are running
inside of the container:

``` programlisting
$ ps
PID TTY        TIME CMD
1 pts/0    00:00:00 bash
2 pts/0    00:00:00 ps
```

[]{#02.htm_pgfId-1037613}You only see two processes: the
`bash`{.fm-code-in-text} script[]{#02.htm_marker-1037611} and the
`ps`{.fm-code-in-text} command[]{#02.htm_marker-1037612}. Needless to
say, on my host machine, there are hundreds of processes running
(including these two processes). You can further explore the inside of
the container to gain an understanding of what is going on within a
container.

[]{#02.htm_pgfId-1037614}When you are done, you exit the
`bash`{.fm-code-in-text} script, and the container shuts down. Since you
ran with the `--rm`{.fm-code-in-text} option[]{#02.htm_marker-1037615},
Podman removes all the container storage and deletes the container. The
container image remains in container/storage. Now that you have explored
the inner workings of a container, it is time to start working with the
default application within the
[]{#02.htm_marker-1037616}[]{#02.htm_marker-1037617}container.

### []{#02.htm_pgfId-1037619}2.1.2 Running the containerized application {#02.htm_heading_id_5 .fm-head1}

[]{#02.htm_pgfId-1037623}In
[]{#02.htm_marker-1037620}[]{#02.htm_marker-1037621}[]{#02.htm_marker-1037622}the
previous example, you pulled and ran `bash`{.fm-code-in-text} within a
containerized application, but you did not run the application the
developer intended you to run. In this next example, you will run the
actual application by removing the command and running with a couple of
new options.

[]{#02.htm_pgfId-1037624}First, remove the `-ti`{.fm-code-in-text} and
the `--rm`{.fm-code-in-text} options, since you want the container to
remain running when the `podman`{.fm-code-in-text}
command[]{#02.htm_marker-1037625} exits. You are not a shell running
within the container interactively, since it is just running the
containerized web service:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp registry.access.redhat.com/ubi8/httpd-24
37a1d2e31dbf4fa311a5ca6453f53106eaae2d8b9b9da264015cc3f8864fac22
```

[]{#02.htm_pgfId-1037629}The first option to notice is the
`-d`{.fm-code-in-text} `(--detach)`{.fm-code-in-text}
option[]{#02.htm_marker-1037628}, which tells Podman to launch the
container and then detach from it. Basically, run the container in the
background. The Podman command actually exits and leaves the container
running. Chapter 6 goes much deeper into what is going on behind the
scenes:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp registry.access.redhat.com/ubi8/httpd-24
```

[]{#02.htm_pgfId-1037633}The `-p`{.fm-code-in-text}
`(--publish)`{.fm-code-in-text} option tells Podman to publish or bind
the container port `8080`{.fm-code-in-text} to the host port
`8080`{.fm-code-in-text} when the container is running. With the
`-p`{.fm-code-in-text} option[]{#02.htm_marker-1037634}, the field
before the colon refers to the host port, while the field after the
colon refers to the container port. In this case, you see that the ports
are the same. If you specify only one port[]{#02.htm_marker-1037635},
Podman considers this port a container port and randomly picks a host
port on which the container port is bound. You can use the
`podman`{.fm-code-in-text} `port`{.fm-code-in-text}
command[]{#02.htm_marker-1037638} to discover which ports are bound to a
container.

[]{#02.htm_pgfId-1037639}Listing 2.2 Example of the
`podman`{.fm-code-in-text} `port`{.fm-code-in-text} command

``` programlisting
$ podman port myapp
8080/tcp -> 0.0.0.0:8080    ❶
```

[]{#02.htm_pgfId-1051889}[❶]{.fm-combinumeral} Shows that port 8080/tcp
inside the container is bound to all of the host networks (0.0.0.0) at
port 8080

[]{#02.htm_pgfId-1037643}By default, containers are created within their
own network namespace, meaning they are not bound to the host network
but to their virtualized network. Suppose I execute the container
without the `-p`{.fm-code-in-text} option[]{#02.htm_marker-1037644}. In
that case, the Apache server within the container binds to the network
interface within the container's network namespace, but Apache is not
bound to the host network.

[]{#02.htm_pgfId-1037645}Only processes within the container are able to
connect to port `8080`{.fm-code-in-text} to communicate with the web
server. By executing the command with the `-p`{.fm-code-in-text}
option,[]{#02.htm_marker-1037646} Podman connects the port from inside
the container to the host network at the specified port. The connection
allows external processes like a web browser to read from the web
service.

[]{#02.htm_pgfId-1037647}[Note]{.fm-callout-head} If you are running
containers in rootless mode, covered in chapter 3, Podman users are by
default not permitted to bind to ports \< 1024 by the kernel. Some
containers want to bind to lower ports like port 80, which is allowed
inside the container, but `-p`{.fm-code-in-text1}
`80:80`{.fm-code-in-text1} fails, since 80 is less than 1024. Using
`-p`{.fm-code-in-text1} `8080:80`{.fm-code-in-text1} causes Podman to
bind the host's port `8080`{.fm-code-in-text1} to port
`80`{.fm-code-in-text1} within the container. The upstream Podman repo
contains troubleshooting information on problems like binding to ports
less than 1024 and many others (see
[http://mng.bz/69ry](http://mng.bz/69ry){.url}).

[]{#02.htm_pgfId-1037649}The `-p`{.fm-code-in-text}
option[]{#02.htm_marker-1046818} can map port numbers inside the
container to different port numbers outside the container:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp registry.access.redhat.com/ubi8/httpd-24
```

[]{#02.htm_pgfId-1037652}In the example name, the container
`myapp`{.fm-code-in-text} is using the `--name`{.fm-code-in-text}
`myapp`{.fm-code-in-text} option[]{#02.htm_marker-1037651}. Specifying a
name makes it easier to find the container, and it allows you to specify
a name that can then be used for other commands (e.g.,
`podman`{.fm-code-in-text} `stop`{.fm-code-in-text}
`myapp`{.fm-code-in-text}[]{#02.htm_marker-1037653}). If you don't
specify a name, Podman automatically generates a unique container name
along with a container ID. All of the Podman commands that interact with
containers can use either the name or the ID:

``` programlisting
$ podman run -d --name myapp -p 8080:8080 registry.access.redhat.com/ubi8/httpd-24
```

[]{#02.htm_pgfId-1037656}When the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#02.htm_marker-1037655} completes, the
container is running. Since this container is running in detached mode,
Podman prints out the container ID and exits, but the container remains
running:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp registry.access.redhat.com/ubi8/httpd-24
37a1d2e31dbf4fa311a5ca6453f53106eaae2d8b9b9da264015cc3f8864fac22
```

[]{#02.htm_pgfId-1037659}Now that the container is running, you can
launch a web browser to communicate with the web server inside of the
container at localhost port `8080`{.fm-code-in-text} (see figure 2.1):

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/02-01.png){.calibre18}

[]{#02.htm_pgfId-1052898}Figure 2.1 Web browser window connecting to the
ubi8/httpd-24 container running in Podman
:::

[]{#02.htm_pgfId-1037667}Congratulations! You have launched your first
containerized application.

[]{#02.htm_pgfId-1037668}Now imagine you want to start another
container. You can execute a similar command with just a couple of
changes:

``` programlisting
$ podman run -d -p 8081:8080 --name myapp1 \ 
➥ registry.access.redhat.com/ubi8/httpd-24
fa41173e4568a8fa588690d3177150a454c63b53bdfa52865b5f8f7e4d7de1e1
```

[]{#02.htm_pgfId-1037671}Notice you need to change the name of the
container to `myapp1`{.fm-code-in-text}; otherwise, the
`podman`{.fm-code-in-text} `run`{.fm-code-in-text} command fails with
the `myapp`{.fm-code-in-text} name because the container previously
existed. Also you need to change the `-p`{.fm-code-in-text} option to
use `8081`{.fm-code-in-text} for the host port because the previous
container, `myapp`{.fm-code-in-text}[]{#02.htm_marker-1037672}, is
currently running and is bound to port `8080`{.fm-code-in-text}. The
second container isn't allowed to bind to port `8080`{.fm-code-in-text}
until the first container exits:

``` programlisting
$ podman run -d -p 8081:8080 --name myapp1  
     registry.access.redhat.com/ubi8/httpd-24
```

[]{#02.htm_pgfId-1037676}The `podman`{.fm-code-in-text}
`create`{.fm-code-in-text} command[]{#02.htm_marker-1037674} is almost
identical to the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
command[]{#02.htm_marker-1037675}. The `create`{.fm-code-in-text}
command pulls the image if it is not in container storage and configures
the container information to make it ready to run but never executes the
container. It is often used together with the `podman`{.fm-code-in-text}
`start`{.fm-code-in-text} command[]{#02.htm_marker-1037677} described in
section 2.1.4. You might want to create a container and then later use a
systemd unit file to start and stop the container.

[]{#02.htm_pgfId-1037679}[]{#02.htm_id_qoinjfin0ayc1111}Some notable
`podman`{.fm-code-in-text} `run`{.fm-code-in-text} options include the
following:

- []{#02.htm_pgfId-1037681 .calibre17}\--`user`{.fm-code-in-text}
  `USERNAME`{.fm-code-in-text}[]{#02.htm_marker-1037680
  .calibre17}---This tells Podman to run the container as a specific
  user defined in the image. By default, Podman will run the container
  as root, unless the container image specifies a default user.

- []{#02.htm_pgfId-1037683
  .calibre17}`--rm`{.fm-code-in-text}[]{#02.htm_marker-1037682
  .calibre17}---This automatically removes the container when it exits.

- []{#02.htm_pgfId-1037685 .calibre17}`--tty`{.fm-code-in-text}
  `-(t`{.fm-code-in-text}[]{#02.htm_marker-1037684
  .calibre17}`)`{.fm-code-in-text}---This allocates a pseudo
  `-tty`{.fm-code-in-text} and attaches it to the standard input of the
  container.

- []{#02.htm_pgfId-1037687 .calibre17}`--interactive`{.fm-code-in-text}
  `(-i`{.fm-code-in-text}[]{#02.htm_marker-1037686
  .calibre17}`)`{.fm-code-in-text}---This connects
  `stdin`{.fm-code-in-text} to the primary process of the container.
  These options give you an interactive shell within the container.

[]{#02.htm_pgfId-1037688}[Note]{.fm-callout-head} There are dozens of
`podman`{.fm-code-in-text1} `run`{.fm-code-in-text1} options available,
allowing you to change security features, namespaces, volumes, and so
on. Some of these I use and explain throughout the book. Refer to the
`podman-run`{.fm-code-in-text1} man page[]{#02.htm_marker-1037689} for a
description of all of the options. Most of the
`podman`{.fm-code-in-text1} `create`{.fm-code-in-text1} options defined
in table 2.1 are also available for `podman`{.fm-code-in-text1}
`run`{.fm-code-in-text1}.

[]{#02.htm_pgfId-1037691}Use the `man`{.fm-code-in-text}
`podman-run`{.fm-code-in-text} command[]{#02.htm_marker-1037690} for
information about all options. Now that the container is up and running,
it is time to stop the container and go to the next
[]{#02.htm_marker-1037692}[]{#02.htm_marker-1037693}[]{#02.htm_marker-1037694}step.

### []{#02.htm_pgfId-1037696}2.1.3 Stopping containers {#02.htm_heading_id_6 .fm-head1}

[]{#02.htm_pgfId-1037700}You
[]{#02.htm_marker-1037697}[]{#02.htm_marker-1037698}[]{#02.htm_marker-1037699}have
two containers running and have tested them by running a web browser
against them. To continue the development by actually adding some
content to the web page, you can stop the containers using the
`podman`{.fm-code-in-text} `stop`{.fm-code-in-text}
command[]{#02.htm_marker-1037701}:

``` programlisting
$ podman stop myapp
```

[]{#02.htm_pgfId-1037704}The `stop`{.fm-code-in-text} command stops the
container started with the previous `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#02.htm_marker-1043634}.

[]{#02.htm_pgfId-1037705}When stopping a container, Podman examines the
running container and sends a stop signal, usually
`SIGTERM`{.fm-code-in-text}, to the primary process (PID1) of the
container, and then by default it waits 10 seconds for the container to
stop. The stop signal tells the primary process within the container to
exit gracefully. If the container doesn't stop within 10 seconds, Podman
sends the `SIGKILL`{.fm-code-in-text} signal[]{#02.htm_marker-1037706}
to the process, forcing the container to stop. The 10-second wait gives
the processes in the container time to clean up and commit changes.

[]{#02.htm_pgfId-1037707}The default stop signal can be changed for a
container using the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
`--stop-signal`{.fm-code-in-text} option[]{#02.htm_marker-1037708}.
Sometimes the primary or init process of a container ignores
`SIGTERM`{.fm-code-in-text} (e.g., containers that use systemd as the
primary process inside a container). systemd ignores
`SIGTERM`{.fm-code-in-text} and specifies that it shuts down using the
`SIGRTMIN+3`{.fm-code-in-text} `(signal`{.fm-code-in-text}
`#37)`{.fm-code-in-text} signal. The stop signal can be embedded in
container images, as I describe in section 2.3.

[]{#02.htm_pgfId-1037710}Some containers ignore the
`SIGTERM`{.fm-code-in-text} stop signal[]{#02.htm_marker-1037709}, which
means you have to wait 10 seconds for the container to exit. If you know
the container ignores the default stop signal, and you don't care about
the container cleaning up, you can just add the `-t`{.fm-code-in-text}
`0`{.fm-code-in-text} option[]{#02.htm_marker-1037711} to
`podman`{.fm-code-in-text} `stop`{.fm-code-in-text} to send the
`SIGKILL`{.fm-code-in-text} signal[]{#02.htm_marker-1037712} right away:

``` programlisting
$ podman stop -t 0 myapp1
myapp1
```

[]{#02.htm_pgfId-1037716}Podman has a similar command,
`podman`{.fm-code-in-text}
`kill`{.fm-code-in-text}[]{#02.htm_marker-1037715}, which sends the
specified kill signal. The `podman`{.fm-code-in-text}
`kill`{.fm-code-in-text} command[]{#02.htm_marker-1037717} can be useful
when you want to send signals into the container without actually
stopping the container.

[]{#02.htm_pgfId-1037720}[]{#02.htm_id_26vkzzhe5enr}Some notable Podman
stop options[]{#02.htm_marker-1037719} include the following:

- []{#02.htm_pgfId-1037722 .calibre17}`--timeout`{.fm-code-in-text}
  `(-t`{.fm-code-in-text}[]{#02.htm_marker-1037721
  .calibre17}`)`{.fm-code-in-text}---This sets the timeout;
  `-t`{.fm-code-in-text} `0`{.fm-code-in-text} sends the
  `SIGKILL`{.fm-code-in-text} without waiting for the container to stop.

- []{#02.htm_pgfId-1037724 .calibre17}`--latest`{.fm-code-in-text}
  `(-l`{.fm-code-in-text}[]{#02.htm_marker-1048907
  .calibre17}`)`{.fm-code-in-text}---This is a useful option to allow
  you to stop the last created container rather than having to use the
  container name or container ID. Most Podman commands that require you
  to specify a container name or ID also accept the
  `--latest`{.fm-code-in-text} option[]{#02.htm_marker-1048909
  .calibre17}. This is only available on Linux machines.

- []{#02.htm_pgfId-1037727
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1048910
  .calibre17}---This tells Podman to stop all running containers.
  Similarly to `--latest`{.fm-code-in-text}, Podman commands that
  require a container name or container ID parameter also take the
  `--all`{.fm-code-in-text} option[]{#02.htm_marker-1048912 .calibre17}.

[]{#02.htm_pgfId-1037731}[]{#02.htm_id_lgnto058jplf}Use the
`man`{.fm-code-in-text} `podman-stop`{.fm-code-in-text}
command[]{#02.htm_marker-1037730} for information about all options.

[]{#02.htm_pgfId-1037732}Eventually, your system will have lots of
stopped containers, and sometimes you will need to restart them (e.g.,
if the system was rebooted). Another common use case is to first create
a container and later start it. The next section explains how to start a
[]{#02.htm_marker-1037733}[]{#02.htm_marker-1037734}[]{#02.htm_marker-1037735}container.

### []{#02.htm_pgfId-1037737}2.1.4 Starting containers {#02.htm_heading_id_7 .fm-head1}

[]{#02.htm_pgfId-1037741}The
[]{#02.htm_marker-1037738}[]{#02.htm_marker-1037739}[]{#02.htm_marker-1037740}container
you created has now been stopped. Next, you may want to start it back up
again using the command in the following listing.

[]{#02.htm_pgfId-1037742}Listing 2.3 Example of starting a container

``` programlisting
$ podman start myapp
myapp                  ❶
```

[]{#02.htm_pgfId-1051810}[❶]{.fm-combinumeral} The start command prints
the names of the containers that were started.

[]{#02.htm_pgfId-1037747}The `podman`{.fm-code-in-text}
`start`{.fm-code-in-text} command[]{#02.htm_marker-1037746} starts one
or more containers. This command will output the container ID,
indicating that your container is up and running. You can now reconnect
to it with a web browser. One common use case for
`podman`{.fm-code-in-text} `start`{.fm-code-in-text} is starting a
container after a reboot to start all of the containers that were
stopped during shutdown.

[]{#02.htm_pgfId-1037749}Some favorite Podman start options include
these:

- []{#02.htm_pgfId-1037752
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1037750
  .calibre17}---This []{#02.htm_marker-1037751 .calibre17}starts all of
  the stopped containers in container storage.

- []{#02.htm_pgfId-1037754
  .calibre17}`--attach`{.fm-code-in-text}[]{#02.htm_marker-1037753
  .calibre17}---This attaches your terminal to the output of the
  container.

- []{#02.htm_pgfId-1037756 .calibre17}`--interactive`{.fm-code-in-text}
  `(-i`{.fm-code-in-text}[]{#02.htm_marker-1037755
  .calibre17}`)`{.fm-code-in-text}---This attaches the terminal input to
  the container.

[]{#02.htm_pgfId-1037758}Use the `man`{.fm-code-in-text}
`podman-start`{.fm-code-in-text} command[]{#02.htm_marker-1037757} for
information about all options.

[]{#02.htm_pgfId-1037759}After you've been using Podman for a while and
have pulled down and run many different container images, you might want
to figure out which containers are running or which containers you have
in local storage. You will need to be able to list
[]{#02.htm_marker-1037760}these
[]{#02.htm_marker-1037761}[]{#02.htm_marker-1037762}[]{#02.htm_marker-1037763}containers.

### []{#02.htm_pgfId-1037765}2.1.5 Listing containers {#02.htm_heading_id_8 .fm-head1}

[]{#02.htm_pgfId-1037769}You
[]{#02.htm_marker-1037766}[]{#02.htm_marker-1037767}[]{#02.htm_marker-1037768}can
list the running containers and all of the containers that were
previously created. Use the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#02.htm_marker-1037770} to list
containers:

``` programlisting
$ podman ps
CONTAINER ID IMAGE                      COMMAND        CREATED \ 
➥   STATUS         PORTS          NAMES
b1255e94d084 registry.access.redhat.com/ubi8/httpd-24:latest /usr/bin/run-\ 
➥ http... 6 minutes ago Up 4 minutes ago 0.0.0.0:8080->8080/tcp myapp
```

[]{#02.htm_pgfId-1037775}Notice the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#02.htm_marker-1037774} by default
lists the running containers. Use the `--all`{.fm-code-in-text}
option[]{#02.htm_marker-1037776} to see all of the containers:

``` programlisting
$ podman ps --all
CONTAINER ID IMAGE                       COMMAND        CREATED \ 
➥   STATUS          PORTS          NAMES
b1255e94d084 registry.access.redhat.com/ubi8/httpd-24:latest /usr/bin/run-\
➥ http... 9 minutes ago Up 8 minutes ago     0.0.0.0:8080->8080/tcp myapp
3efee4d39965 registry.access.redhat.com/ubi8/httpd-24:latest /usr/bin/run-\
➥ http... 7 minutes ago Exited (0) 3 minutes ago 0.0.0.0:8081->8080/tcp myapp1
```

[]{#02.htm_pgfId-1037782}[]{#02.htm_id_8i6xl26vaon5}Some notable
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text} options include the
following:

- []{#02.htm_pgfId-1037784
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1037783
  .calibre17}---This tells Podman to list all containers rather than
  just running containers.

- []{#02.htm_pgfId-1037786
  .calibre17}`--quiet`{.fm-code-in-text}[]{#02.htm_marker-1037785
  .calibre17}---This tells Podman to only print the container IDs.

- []{#02.htm_pgfId-1037788
  .calibre17}`--size`{.fm-code-in-text}[]{#02.htm_marker-1037787
  .calibre17}---This tells Podman to return the amount of disk space
  currently used for each container other than the images they are based
  on.

[]{#02.htm_pgfId-1037790}Use the `man`{.fm-code-in-text}
`podman-ps`{.fm-code-in-text} command[]{#02.htm_marker-1037789} for
information about all options. Now that you know all of the containers
you have on the system, you might want to inspect their
[]{#02.htm_marker-1037791}[]{#02.htm_marker-1037792}[]{#02.htm_marker-1037793}internals.

### []{#02.htm_pgfId-1037795}2.1.6 Inspecting containers {#02.htm_heading_id_9 .fm-head1}

[]{#02.htm_pgfId-1037799}To
[]{#02.htm_marker-1037796}[]{#02.htm_marker-1037797}[]{#02.htm_marker-1037798}fully
understand a container, sometimes you want to know which image a
container was based on, which environment variables a container gets by
default, or what the security settings used for a container are. The
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text}
command[]{#02.htm_marker-1037800} gives us some data about the
containers, but if you want to really examine information about the
container, you can use the `podman`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#02.htm_marker-1037801}.

[]{#02.htm_pgfId-1037803}The `podman`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#02.htm_marker-1037802} can also
be used to inspect images, networks, volumes, and pods. The
`podman`{.fm-code-in-text} `container`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#02.htm_marker-1037804} is also
available and specific to containers. But most users just type the
shorter `podman`{.fm-code-in-text} `inspect`{.fm-code-in-text}
command[]{#02.htm_marker-1037805}:

``` programlisting
$ podman inspect myapp
[
  {
      "Id": "240271ae90480d3836b1477e5c0b49fbd3883846ca474e3f6effdfb271f4ff54",
      "Created": "2021-09-27T05:27:47.163828842-04:00",
      "Path": "container-entrypoint",
      "Args": [
          "/usr/bin/run-httpd"
      ],
...
]
```

[]{#02.htm_pgfId-1037818}As you can see, the `podman`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#02.htm_marker-1037817} outputs a
large JSON file---307 lines on my machine. All of this information is
eventually handed down the OCI runtime to launch the container. When
using the `inspect`{.fm-code-in-text} command, it is often better to
pipe its output to `less`{.fm-code-in-text} or `grep`{.fm-code-in-text}
to find particular fields you are interested in. Alternatively, you can
use the format option. If you want to examine the command executed when
you start the container, execute the following.

[]{#02.htm_pgfId-1037819}Listing 2.4 Inspecting a specified command to
execute the container

``` programlisting
$ podman inspect --format '{{ .Config.Cmd }}' myapp     ❶
[/usr/bin/run-httpd]
```

[]{#02.htm_pgfId-1051739}[❶]{.fm-combinumeral} inspect is displaying
data from the OCI image specification.

[]{#02.htm_pgfId-1037823}Or if you want to see the stop signal, execute
the following.

[]{#02.htm_pgfId-1037824}Listing 2.5 Inspecting the stop signal to be
used when stopping the container

``` programlisting
$ podman inspect --format '{{ .Config.StopSignal }}' myapp
15       ❶
```

[]{#02.htm_pgfId-1051675}[❶]{.fm-combinumeral} The default stop signal
for all containers is 15 (SIGTERM).

[]{#02.htm_pgfId-1037830}[]{#02.htm_id_c6rw1dirvvel}Some notable
`podman`{.fm-code-in-text} `inspect`{.fm-code-in-text}
options[]{#02.htm_marker-1037829} include the following:

- []{#02.htm_pgfId-1037832 .calibre17}`--latest`{.fm-code-in-text}
  `(-l`{.fm-code-in-text}[]{#02.htm_marker-1037831
  .calibre17}`)`{.fm-code-in-text}---This is handy in that it allows you
  to quickly inspect the last created container rather than specifying
  the container name or container ID.

- []{#02.htm_pgfId-1037834
  .calibre17}`--format`{.fm-code-in-text}[]{#02.htm_marker-1037833
  .calibre17}---This is useful, as shown previously, to extract
  particular fields out of the JSON.

- []{#02.htm_pgfId-1037836
  .calibre17}`--size`{.fm-code-in-text}[]{#02.htm_marker-1037835
  .calibre17}---This adds the amount of disk space the container is
  using. Gathering this information takes a long time, so it is not done
  by default.

[]{#02.htm_pgfId-1037838}Use the `man`{.fm-code-in-text}
`podman-inspect`{.fm-code-in-text} command[]{#02.htm_marker-1037837} for
information about all options. After you inspect a container, you might
realize you no longer need that container taking up storage, so you need
to remove
[]{#02.htm_marker-1037839}[]{#02.htm_marker-1037840}[]{#02.htm_marker-1037841}it.

### []{#02.htm_pgfId-1037843}2.1.7 Removing containers {#02.htm_heading_id_10 .fm-head1}

[]{#02.htm_pgfId-1037847}If
[]{#02.htm_marker-1037844}[]{#02.htm_marker-1037845}[]{#02.htm_marker-1037846}you
are done using a container, you may want to remove the container to free
up disk space or reuse the container name. Remember when you started a
second container called `myapp1`{.fm-code-in-text}? You no longer need
it, so you can remove it. Make sure to stop the container (section
2.1.3) before removing it. Then use the `podman`{.fm-code-in-text}
`rm`{.fm-code-in-text} command[]{#02.htm_marker-1037848} to remove
container:

``` programlisting
$ podman rm myapp1
3efee4d3996532769356ffea23e1f50710019d4efc704d39026c5bffd6aa18be
```

[]{#02.htm_pgfId-1037852}[]{#02.htm_id_t4e49sbt7wo71111}Some notable
`podman`{.fm-code-in-text} `rm`{.fm-code-in-text} options include the
following:

- []{#02.htm_pgfId-1037854
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1037853
  .calibre17}---This option is useful if you want to remove all your
  containers.

- []{#02.htm_pgfId-1037856
  .calibre17}`--force`{.fm-code-in-text}[]{#02.htm_marker-1037855
  .calibre17}---This option tells Podman to stop all the running
  containers when removing.

[]{#02.htm_pgfId-1037858}Use the `man`{.fm-code-in-text}
`podman-rm`{.fm-code-in-text} command[]{#02.htm_marker-1037857} for
information about all options. Now that you understand a few commands,
it is time to start modifying the running
[]{#02.htm_marker-1037859}[]{#02.htm_marker-1037860}[]{#02.htm_marker-1037861}container.

### []{#02.htm_pgfId-1037863}2.1.8 exec-ing into a container {#02.htm_heading_id_11 .fm-head1}

[]{#02.htm_pgfId-1037867}Often,
[]{#02.htm_marker-1037864}[]{#02.htm_marker-1037865}[]{#02.htm_marker-1037866}when
a container is running, you might want to start another process within
the container to debug or examine what is going on. In some cases, you
may want to modify some of the content the container is using.

[]{#02.htm_pgfId-1037868}Imagine you want to go into your container and
modify the web page it is showing. You can `exec`{.fm-code-in-text} into
the container using the `podman`{.fm-code-in-text}
`exec`{.fm-code-in-text} command[]{#02.htm_marker-1037869}. Use the
`--interactive`{.fm-code-in-text} (`-i`{.fm-code-in-text})
option[]{#02.htm_marker-1037870} to allow you to execute commands within
the container. You need to specify the name of the container
`myapp`{.fm-code-in-text}[]{#02.htm_marker-1037871} and execute the Bash
script while in the container. If you stopped the
`myapp`{.fm-code-in-text} container,[]{#02.htm_marker-1037872} you need
to restart it, since `podman`{.fm-code-in-text} `exec`{.fm-code-in-text}
only works on running containers.

[]{#02.htm_pgfId-1037873}In the following example, you will
`exec`{.fm-code-in-text} a `bash`{.fm-code-in-text} process into the
container to create the /var/www/html/index.html file. You will write
HTML content that causes the containerized website to display
`Hello`{.fm-code-in-text} `World`{.fm-code-in-text}:

``` programlisting
 $ podman exec -i myapp bash -c 'cat > /var/www/html/index.html' << _EOF
<html>
 <head>
 </head>
 <body>
  <h1>Hello World</h1>
 </body>
</html>
_EOF
```

[]{#02.htm_pgfId-1037883}`exec`{.fm-code-in-text}-ing back into the
container a second time, you can see that the file was successfully
modified. This shows that modifications to a container via
`exec`{.fm-code-in-text} are permanent to the container and will remain
even if you stopped and restarted the container. A key difference
between `podman`{.fm-code-in-text} `run`{.fm-code-in-text} and
`podman`{.fm-code-in-text} `exec`{.fm-code-in-text} is that
`run`{.fm-code-in-text} creates a new container off of an image with
processes running inside, while `exec`{.fm-code-in-text} starts
processes inside of existing containers:

``` programlisting
$ podman exec myapp cat /var/www/html/index.html
<html>
 <head>
 </head>
 <body>
  <h1>Hello World</h1>
 </body>
</html>
```

[]{#02.htm_pgfId-1037892}Now let's connect a web browser to the
container to see if the content has changed (see figure 2.2):

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/02-02.png){.calibre18}

[]{#02.htm_pgfId-1052948}Figure 2.2 Web browser window connecting to the
ubi8/httpd-24 container running in Podman with updated Hello World HTML
:::

[]{#02.htm_pgfId-1037903}[]{#02.htm_id_gb8ykx98avmq}Some notable
`podman`{.fm-code-in-text} `exec`{.fm-code-in-text}
options[]{#02.htm_marker-1037902} include the following:

- []{#02.htm_pgfId-1037905
  .calibre17}`--tty`{.fm-code-in-text}[]{#02.htm_marker-1037904
  .calibre17}---This connects a `-tty`{.fm-code-in-text} to the
  `exec`{.fm-code-in-text} session.

- []{#02.htm_pgfId-1037908
  .calibre17}`--interactive`{.fm-code-in-text}[]{#02.htm_marker-1037906
  .calibre17}---The `-i`{.fm-code-in-text}
  option[]{#02.htm_marker-1037907 .calibre17} tells Podman to run in
  interactive mode, meaning you can interact with an
  `exec`{.fm-code-in-text}-ed program, like a shell.

[]{#02.htm_pgfId-1037910}Use the `man`{.fm-code-in-text}
`podman-exec`{.fm-code-in-text} command[]{#02.htm_marker-1037909} for
information about all options.

[]{#02.htm_pgfId-1037911}Now that you have created an application, you
might want to share it with others. First, you need to commit the
container to an
[]{#02.htm_marker-1037912}[]{#02.htm_marker-1037913}[]{#02.htm_marker-1037914}image.

### []{#02.htm_pgfId-1037916}2.1.9 Creating an image from a container {#02.htm_heading_id_12 .fm-head1}

[]{#02.htm_pgfId-1037920}Developers
[]{#02.htm_marker-1037917}[]{#02.htm_marker-1037918}[]{#02.htm_marker-1037919}often
run containers from a base image to create a new container environment.
Once they are done, they pack this environment into a container image to
be able to share it with other users. Those users can then use Podman to
launch the containerized application. You can do this with Podman by
committing the container to an OCI image.

[]{#02.htm_pgfId-1037921}First, stop or pause the container to make sure
nothing gets modified while you are committing it:

``` programlisting
$ podman stop myapp
```

[]{#02.htm_pgfId-1037924}Now you can execute the
`podman`{.fm-code-in-text} `commit`{.fm-code-in-text}
command[]{#02.htm_marker-1049110} to take your application container,
`myapp`{.fm-code-in-text}[]{#02.htm_marker-1049112}, and commit it,
creating a new image named `myimage`{.fm-code-in-text}:

``` programlisting
$ podman commit myapp myimage
Getting image source signatures
Copying blob e39c3abf0df9 skipped: already exists
Copying blob 8f26704f753c skipped: already exists
Copying blob 83310c7c677c skipped: already exists
Copying blob 654b3bf1361e skipped: already exists
Copying blob 9e816183404c done              Copying config e38084bb8a done
Writing manifest to image destination
Storing signatures
e38084bb8a76104a7cac22b919f67646119aff235bb1cfcba5478cc1fbf1c9eb
```

[]{#02.htm_pgfId-1037937}Now you can continue running the existing
`myapp`{.fm-code-in-text} container[]{#02.htm_marker-1037936} by calling
`podman`{.fm-code-in-text} `start`{.fm-code-in-text}, or you can create
a new container based on `myimage`{.fm-code-in-text}:

``` programlisting
$ podman run -d --name myapp1 -p 8080:8080 myimage
0052cb32c8e63b845ac5dfd5ba176b8204535c2c6cafa3277453424de601263f
```

[]{#02.htm_pgfId-1037941}[Note]{.fm-callout-head} Using the
`podman`{.fm-code-in-text1} `commit`{.fm-code-in-text1}
command[]{#02.htm_marker-1037940} to create an image is not a common
method. The entire process of building container images can be scripted
and automated using `podman`{.fm-code-in-text1}
`build`{.fm-code-in-text1}. See section 2.3 for more information on this
process.

[]{#02.htm_pgfId-1037944}[]{#02.htm_id_rll08y12fcy}Some notable
`podman`{.fm-code-in-text} `commit`{.fm-code-in-text}
options[]{#02.htm_marker-1037943} include the following:

- []{#02.htm_pgfId-1037946
  .calibre17}`--pause`{.fm-code-in-text}[]{#02.htm_marker-1037945
  .calibre17}---This pauses a running container during the commit.
  Notice I stopped the container before doing the commit, while I could
  have simply paused it. The `podman`{.fm-code-in-text}
  `pause`{.fm-code-in-text} and `podman`{.fm-code-in-text}
  `unpause`{.fm-code-in-text} commands[]{#02.htm_marker-1037947
  .calibre17} allow you to pause and unpause containers directly.

- []{#02.htm_pgfId-1037949
  .calibre17}`--change`{.fm-code-in-text}[]{#02.htm_marker-1037948
  .calibre17}---This option allows you to commit instructions on using
  the image. The instructions are
  `CMD`{.fm-code-in-text}[]{#02.htm_marker-1037950 .calibre17},
  `ENTRYPOINT`{.fm-code-in-text}[]{#02.htm_marker-1037951 .calibre17},
  `ENV`{.fm-code-in-text}[]{#02.htm_marker-1037952 .calibre17},
  `EXPOSE`{.fm-code-in-text}[]{#02.htm_marker-1037953 .calibre17},
  `LABEL`{.fm-code-in-text}[]{#02.htm_marker-1037954 .calibre17},
  `ONBUILD`{.fm-code-in-text}[]{#02.htm_marker-1037955 .calibre17},
  `STOPSIGNAL`{.fm-code-in-text}[]{#02.htm_marker-1037956 .calibre17},
  `USER`{.fm-code-in-text}[]{#02.htm_marker-1037957 .calibre17},
  `VOLUME`{.fm-code-in-text}[]{#02.htm_marker-1037958 .calibre17}, and
  `WORKDIR`{.fm-code-in-text}. These instructions match up with the
  directives in the Containerfile or Dockerfile.

[]{#02.htm_pgfId-1037961}Use the `man`{.fm-code-in-text}
`podman-commit`{.fm-code-in-text} command[]{#02.htm_marker-1037960} for
information about all options. Table 2.1 lists all the Podman container
commands.

[]{#02.htm_pgfId-1037962}Now that you have committed your container to
an image, it is time to show how Podman can work
[]{#02.htm_marker-1037963}[]{#02.htm_marker-1037964}[]{#02.htm_marker-1037965}with
[]{#02.htm_marker-1037966}[]{#02.htm_marker-1037967}images.

[]{#02.htm_pgfId-1037968}[Note]{.fm-callout-head} You have examined a
few of the Podman container commands, but there are many more. Use the
`podman-container(1)`{.fm-code-in-text1} man
pages[]{#02.htm_marker-1037969} to explore all of them as well as a full
description of commands specified in this section.

[]{#02.htm_pgfId-1044663}Table 2.1 Podman container commands

+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044669}Command                                                   | []{#02.htm_pgfId-1044671}Man page                                            | []{#02.htm_pgfId-1044673}Description |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044675}`attach`{.fm-code-in-text1}[]{#02.htm_marker-1044866}     | []{#02.htm_pgfId-1044677}`podman-container-attach(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044679}Attach to a |
|                                                                                    |                                                                              | running container.                   |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044681}`checkpoint`{.fm-code-in-text1}[]{#02.htm_marker-1044867} | []{#02.htm_pgfId-1044683}`podman-container-checkpoint(1)`{.fm-code-in-text1} | []{#02.htm_pgfId-1044685}Checkpoint  |
|                                                                                    |                                                                              | a container.                         |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044687}`cleanup`{.fm-code-in-text1}[]{#02.htm_marker-1044868}    | []{#02.htm_pgfId-1044689}`podman-container-cleanup(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044691}Clean up    |
|                                                                                    |                                                                              | network and mount points of a        |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044693}`commit`{.fm-code-in-text1}[]{#02.htm_marker-1044869}     | []{#02.htm_pgfId-1044695}`podman-container-commit(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044697}Commit a    |
|                                                                                    |                                                                              | container into an image.             |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044699}`cp`{.fm-code-in-text1}[]{#02.htm_marker-1044870}         | []{#02.htm_pgfId-1044701}`podman-container-cp(1)`{.fm-code-in-text1}         | []{#02.htm_pgfId-1044703}Copy files  |
|                                                                                    |                                                                              | or folders into and out of           |
|                                                                                    |                                                                              | containers.                          |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044705}`create`{.fm-code-in-text1}[]{#02.htm_marker-1044871}     | []{#02.htm_pgfId-1044707}`podman-container-create(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044709}Create a    |
|                                                                                    |                                                                              | new container.                       |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044711}`diff`{.fm-code-in-text1}[]{#02.htm_marker-1044872}       | []{#02.htm_pgfId-1044713}`podman-container-diff(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044715}Inspect     |
|                                                                                    |                                                                              | changes in a container's filesystem. |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044717}`exec`{.fm-code-in-text1}[]{#02.htm_marker-1044873}       | []{#02.htm_pgfId-1044719}`podman-container-exec(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044721}Run a       |
|                                                                                    |                                                                              | process in a container.              |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044723}`exists`{.fm-code-in-text1}                               | []{#02.htm_pgfId-1044725}`podman-container-exists(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044727}Check if a  |
|                                                                                    |                                                                              | container                            |
|                                                                                    |                                                                              | exists[]{#02.htm_marker-1044874}.    |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044729}`export`{.fm-code-in-text1}[]{#02.htm_marker-1044875}     | []{#02.htm_pgfId-1044731}`podman-container-export(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044733}Export a    |
|                                                                                    |                                                                              | container\'s filesystem as a TAR     |
|                                                                                    |                                                                              | archive.                             |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044735}`init`{.fm-code-in-text1}[]{#02.htm_marker-1044876}       | []{#02.htm_pgfId-1044737}`podman-container-init(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044739}Init a      |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044741}`inspect`{.fm-code-in-text1}[]{#02.htm_marker-1044877}    | []{#02.htm_pgfId-1044743}`podman-container-inspect(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044745}Display     |
|                                                                                    |                                                                              | detailed information on a container. |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044747}`kill`{.fm-code-in-text1}[]{#02.htm_marker-1044878}       | []{#02.htm_pgfId-1044749}`podman-container-kill(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044751}Send a      |
|                                                                                    |                                                                              | signal to the primary process in the |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044753}`List`{.fm-code-in-text1}                                 | []{#02.htm_pgfId-1044755}`podman-container-list(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044757}List all of |
| `(ps`{.fm-code-in-text1}[]{#02.htm_marker-1044879}`)`{.fm-code-in-text1}           |                                                                              | the containers.                      |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044759}`logs`{.fm-code-in-text1}                                 | []{#02.htm_pgfId-1044761}`podman-container-logs(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044763}Fetch       |
|                                                                                    |                                                                              | logs[]{#02.htm_marker-1044880} for a |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044765}`mount`{.fm-code-in-text1}[]{#02.htm_marker-1044881}      | []{#02.htm_pgfId-1044767}`podman-container-mount(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1044769}Mount a     |
|                                                                                    |                                                                              | container\'s root filesystem.        |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044771}`pause`{.fm-code-in-text1}[]{#02.htm_marker-1044882}      | []{#02.htm_pgfId-1044773}`podman-container-pause(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1044775}Pause       |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044777}`port`{.fm-code-in-text1}                                 | []{#02.htm_pgfId-1044779}`podman-container-port(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044781}List port   |
|                                                                                    |                                                                              | mappings for a container.            |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044783}`prune`{.fm-code-in-text1}[]{#02.htm_marker-1044883}      | []{#02.htm_pgfId-1044785}`podman-container-prune(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1044787}Remove all  |
|                                                                                    |                                                                              | non-running containers.              |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044789}`rename`{.fm-code-in-text1}[]{#02.htm_marker-1044884}     | []{#02.htm_pgfId-1044791}`podman-container-rename(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1044793}Rename an   |
|                                                                                    |                                                                              | existing container.                  |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044795}`restart`{.fm-code-in-text1}[]{#02.htm_marker-1044885}    | []{#02.htm_pgfId-1044797}`podman-container-restart(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044799}Restart a   |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044801}`restore`{.fm-code-in-text1}[]{#02.htm_marker-1044886}    | []{#02.htm_pgfId-1044803}`podman-container-restore(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044805}Restore a   |
|                                                                                    |                                                                              | checkpointed container.              |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044807}`rm`{.fm-code-in-text1}[]{#02.htm_marker-1044887}         | []{#02.htm_pgfId-1044809}`podman-container-rm(1)`{.fm-code-in-text1}         | []{#02.htm_pgfId-1044811}Remove a    |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044813}`run`{.fm-code-in-text1}                                  | []{#02.htm_pgfId-1044815}`podman-container-run(1)`{.fm-code-in-text1}        | []{#02.htm_pgfId-1044817}Run a       |
|                                                                                    |                                                                              | command in a new container.          |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044819}`runlabel`{.fm-code-in-text1}[]{#02.htm_marker-1044888}   | []{#02.htm_pgfId-1044821}`podman-container-runlabel(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1044823}Execute the |
|                                                                                    |                                                                              | command described by an image label. |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044825}`start`{.fm-code-in-text1}[]{#02.htm_marker-1044889}      | []{#02.htm_pgfId-1044827}`podman-container-start(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1044829}Start a     |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044831}`stats`{.fm-code-in-text1}[]{#02.htm_marker-1044890}      | []{#02.htm_pgfId-1044833}`podman-container-stats(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1044835}Display     |
|                                                                                    |                                                                              | statistics for a container.          |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044837}`stop`{.fm-code-in-text1}[]{#02.htm_marker-1044891}       | []{#02.htm_pgfId-1044839}`podman-container-stop(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044841}Stop a      |
|                                                                                    |                                                                              | container.                           |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044843}`top`{.fm-code-in-text1}[]{#02.htm_marker-1044892}        | []{#02.htm_pgfId-1044845}`podman-container-top(1)`{.fm-code-in-text1}        | []{#02.htm_pgfId-1044847}Display     |
|                                                                                    |                                                                              | running process in a container.      |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044849}`unmount`{.fm-code-in-text1}[]{#02.htm_marker-1044893}    | []{#02.htm_pgfId-1044851}`podman-container-unmount(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044853}Unmount a   |
|                                                                                    |                                                                              | container\'s root filesystem.        |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044855}`unpause`{.fm-code-in-text1}[]{#02.htm_marker-1044894}    | []{#02.htm_pgfId-1044857}`podman-container-unpause(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1044859}Unpause all |
|                                                                                    |                                                                              | the containers in a pod.             |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1044861}`wait`{.fm-code-in-text1}                                 | []{#02.htm_pgfId-1044863}`podman-container-wait(1)`{.fm-code-in-text1}       | []{#02.htm_pgfId-1044865}Wait for a  |
|                                                                                    |                                                                              | container to exit.                   |
+------------------------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------+

## []{#02.htm_pgfId-1038202}2.2 Working with container images {#02.htm_heading_id_13 .fm-head}

[]{#02.htm_pgfId-1038205}In
[]{#02.htm_marker-1038203}[]{#02.htm_marker-1038204}the previous
section, you tried basic operations with containers, including
inspecting and committing to a container image. In this section, you
will try working with container images, learn how they differ from
containers, and learn how to share them through container registries.

### []{#02.htm_pgfId-1038207}2.2.1 Differences between a container and an image {#02.htm_heading_id_14 .fm-head1}

[]{#02.htm_pgfId-1038211}One
[]{#02.htm_marker-1038208}[]{#02.htm_marker-1038209}[]{#02.htm_marker-1038210}of
the problems with computer programming is that the same names are
constantly used for different purposes. In the container world, there is
no more overused term than *container*. Often *container* refers to the
running processes launched by Podman. But *container* can also refer to
container data as the non-running objects sitting in container storage.
As you saw in the previous section[]{#02.htm_marker-1038212},
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text}
`--all`{.fm-code-in-text} shows running and non-running containers.

[]{#02.htm_pgfId-1038214}Another example is the term
*namespace*[]{#02.htm_marker-1038213}, which is used in many different
ways. I often get confused when people talk about namespaces within
Kubernetes. Some people hear the term and think of *virtual clusters*,
but when I hear it I think of Linux namespaces used with Pods and
Containers. Similarly, *image* can refer to a VM image, a container
image, an OCI image, or a Docker image stored at a container registry.

[]{#02.htm_pgfId-1038215}I think of containers as executing processes
within an environment or something that is being prepared to run. In
contrast, images are *committed* *containers*, which are prepared to be
shared with others. Other users or systems can use these images to
create new containers.

[]{#02.htm_pgfId-1038216}Container images are just committed containers.
The OCI defines the format of an image. Podman uses the container/image
library
([https://github.com/containers/image](https://github.com/containers/image){.url})
for all of its interaction with images. Container images can be stored
in different types of storage or transports, as *container/image* refers
to them. These transports can be container registries, Docker archives,
OCI archives, `docker-daemon`{.fm-code-in-text}, as well as
containers/storage. See section 2.2.4 for more information on
transports.

[]{#02.htm_pgfId-1038217}In the context of Podman, I usually refer to
images as the content stored locally in a container storage or in
container registries like docker.io and quay.io. Podman uses the GitHub
container/storage library
([https://github.com/containers/storage](https://github.com/containers/storage){.url})
for handling locally stored images. Let's take a closer look at it.

[]{#02.htm_pgfId-1038218}The container/storage library provides the
concept of a storage container. Basically, storage containers are
intermediate storage content that hasn't been committed yet. Think of
them as files on disk and some JSON describing the content. Podman has
its own datastore of data related to a Podman container, and Podman
needs to deal with multiple users of its containers at the same time. It
relies on filesystem locking provided by containers/storage to make sure
hundreds of Podman executables can reliably share the same datastore.

[]{#02.htm_pgfId-1038219}When you commit a container to storage, Podman
copies the container storage to the image storage. Images are stored in
a series of layers, with every commit creating a new layer.

[]{#02.htm_pgfId-1038220}I like to think of an image like a wedding cake
(figure 2.3). In our previous example, you used the ubi8/httpd-24 image,
which is two layers: the base layer is ubi8, and then the image provided
added the `httpd`{.fm-code-in-text} package and a few others to create
the ubi8/httpd-24. Now when you commit your container in the previous
section, Podman adds another layer on top of the ubi8/httpd-24 image
called `myimage`{.fm-code-in-text}[]{#02.htm_marker-1038221}.

::: figure
![](images/02-03.png){.calibre18}

[]{#02.htm_pgfId-1052986}Figure 2.3 A wedding cake display showing the
images making up our Hello World application.
:::

[]{#02.htm_pgfId-1038228}One handy Podman command for showing the layers
of an image is the `podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`tree`{.fm-code-in-text} command:

``` programlisting
$ podman image tree myimage
Image ID: 2c7e43d88038
Tags:   [localhost/myimage:latest]
Size:   461.7MB
Image Layers
├── ID: e39c3abf0df9 Size: 233.6MB
├── ID: 42c81bd2b468 Size: 20.48kB Top Layer of: [registry.access.redhat.com/ubi8:latest]
├── ID: 51a7beaa0b88 Size: 57.43MB
├── ID: 519e681b5702 Size: 170.6MB Top Layer of: [registry.access.redhat.com/ubi8/httpd-24:latest]
└── ID: bc3dcdefdac3 Size: 69.63kB Top Layer of: [localhost/myimage:latest localhost/myapp:latest]
```

[]{#02.htm_pgfId-1038240}You can see that the image
`myimage`{.fm-code-in-text}[]{#02.htm_marker-1038239} consists of five
layers.

[]{#02.htm_pgfId-1038243}Another useful Podman
command[]{#02.htm_marker-1038241}, `podman`{.fm-code-in-text}
`image`{.fm-code-in-text}
`diff`{.fm-code-in-text}[]{#02.htm_marker-1038242}, allows you to see
the actual files and directories that have been changed (C), added (A),
or deleted (D) compared to another image or the lower layer:

``` programlisting
$ podman image diff myimage ubi8/httpd-24 
C /etc/group
C /etc/httpd/conf
C /etc/httpd/conf/httpd.conf
C /etc/httpd/conf.d
C /etc/httpd/conf.d/ssl.conf
C /etc/httpd/tls
C /etc
C /etc/httpd
A /etc/httpd/tls/localhost.crt
A /etc/httpd/tls/localhost.key
...
```

[]{#02.htm_pgfId-1038256}Images are just TAR diffs of software applied
on lower-level images, and container content is an uncommitted layer of
software. Once a container is committed, you can create other containers
on top of your image. You can also share the image with others, so they
can create other containers on your image. Now let's look at all the
images in your container
[]{#02.htm_marker-1038257}[]{#02.htm_marker-1038258}[]{#02.htm_marker-1038259}storage.

### []{#02.htm_pgfId-1038261}2.2.2 Listing images {#02.htm_heading_id_15 .fm-head1}

[]{#02.htm_pgfId-1038265}In
[]{#02.htm_marker-1038262}[]{#02.htm_marker-1038263}[]{#02.htm_marker-1038264}the
container section, you were working with images and used command
`podman`{.fm-code-in-text}
`images`{.fm-code-in-text}[]{#02.htm_marker-1038266} to list the images
in local storage:

``` programlisting
$ podman images
REPOSITORY                   TAG        IMAGE ID       CREATED     SIZE
localhost/myimage         latest    2c7e43d88038  46 hours ago   462 MB
registry.access.redhat
➥.com/ubi8/httpd-24      latest    8594be0a0b57   5 weeks ago   462 MB
registry.access.redhat
➥.com/ubi8               latest    ad42391b9b46   5 weeks ago   234 MB
```

[]{#02.htm_pgfId-1038272}Let's look at the different fields in the
default output. Table 2.2 describes the different fields and data
available with the `podman`{.fm-code-in-text} `images`{.fm-code-in-text}
command[]{#02.htm_marker-1038273}. You will use the
`podman`{.fm-code-in-text} `images`{.fm-code-in-text}
command[]{#02.htm_marker-1038274} throughout this section.

[]{#02.htm_pgfId-1044968}Table 2.2 Default fields listed by the
`podman`{.fm-code-in-text} `images`{.fm-code-in-text} command

+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044972}Heading                                                   | []{#02.htm_pgfId-1044974}Description                |
+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044976}`Repository`{.fm-code-in-text1}[]{#02.htm_marker-1044995} | []{#02.htm_pgfId-1044978}Complete name of the       |
|                                                                                    | image.                                              |
+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044980}`TAG`{.fm-code-in-text1}[]{#02.htm_marker-1044996}        | []{#02.htm_pgfId-1044982}Version (tag) of the       |
|                                                                                    | image. Image tagging is covered in section 2.2.6.   |
+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044984}`IMAGE ID`{.fm-code-in-text1}[]{#02.htm_marker-1044997}   | []{#02.htm_pgfId-1044986}Unique identifier of the   |
|                                                                                    | image. It is generated by Podman as a SHA256 hash   |
|                                                                                    | of the image\'s JSON configuration object.          |
+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044988}`CREATED`{.fm-code-in-text1}[]{#02.htm_marker-1044998}    | []{#02.htm_pgfId-1044990}Elapsed time since the     |
|                                                                                    | image was created. Images are sorted by this field  |
|                                                                                    | by default.                                         |
+------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1044992}`SIZE`{.fm-code-in-text1}[]{#02.htm_marker-1044999}       | []{#02.htm_pgfId-1044994}The amount of storage      |
|                                                                                    | being used by the image.                            |
+------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#02.htm_pgfId-1038308}[Note]{.fm-callout-head} Over time, the amount
of storage used by all the images you pull grows. It is relatively
common for users to run out of disk space, so you should monitor the
size of images and containers, removing them when you are no longer
using them. Use the `man`{.fm-code-in-text1}
`podman-system-prune`{.fm-code-in-text1} command for more information on
cleaning up.

[]{#02.htm_pgfId-1038311}[]{#02.htm_id_u8l9oyck7hrk}One notable
`podman`{.fm-code-in-text} `image`{.fm-code-in-text} option
is[]{#02.htm_marker-1038310} the following:

- []{#02.htm_pgfId-1038313
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1038312
  .calibre17}---This option is useful for listing all images. By
  default, `podman-images`{.fm-code-in-text} lists only the images
  currently in use. When an image is replaced by a newer image with the
  same tag, the previous image is tagged as
  `<none><none>`{.fm-code-in-text}; These images are called dangling
  images. I cover dangling images in section 2.3.1.

[]{#02.htm_pgfId-1038315}Use the `man`{.fm-code-in-text}
`podman-images`{.fm-code-in-text} command[]{#02.htm_marker-1038314} for
information about all options. Similarly to containers, you will likely
want to examine the configuration information associated with an image
by inspecting
[]{#02.htm_marker-1038316}[]{#02.htm_marker-1038317}[]{#02.htm_marker-1038318}it.

### []{#02.htm_pgfId-1038320}2.2.3 Inspecting images {#02.htm_heading_id_16 .fm-head1}

[]{#02.htm_pgfId-1038324}In
[]{#02.htm_marker-1038321}[]{#02.htm_marker-1038322}[]{#02.htm_marker-1038323}the
previous sections, I mentioned a couple of commands to examine images. I
used the `podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`diff`{.fm-code-in-text} to examine files and directories created or
deleted between images. I also showed you a way to see the image
hierarchy or wedding cake layers of images using the
`podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`tree`{.fm-code-in-text} command[]{#02.htm_marker-1038325}.

[]{#02.htm_pgfId-1038326}Sometimes you may want to examine the
configuration of an image; use the `podman`{.fm-code-in-text}
`image`{.fm-code-in-text} `inspect`{.fm-code-in-text}
command[]{#02.htm_marker-1038327}[]{#02.htm_marker-1038328} for this.
The `podman`{.fm-code-in-text} `inspect`{.fm-code-in-text}
command[]{#02.htm_marker-1038329} can also be used to inspect images,
but the names can conflict with containers, so I prefer to use the
specific image command:

``` programlisting
$ podman image inspect myimage
[
  {
      "Id": "3b8fcf9081b4c4e6c16d763b8d02684df0737f3557a1e03ebfe4cc7cd6562135",
      "Digest":
"sha256:ff49aa6253ae47569d5aadbd73d70e7d0431bcf3a2f57b1b56feecdb531029a3",
      "RepoTags": [
          "localhost/myimage:latest"
      ],
      "RepoDigests": [       "localhost/myimage@sha256:ff49aa6253ae47569d5aadbd73d70e7d0431bcf3a2f57b1b\
➥ 56feecdb531029a3"
      ],
...
]
```

[]{#02.htm_pgfId-1038343}As you can see, this command outputs a large
JSON array---153 lines in the previous example---that includes the data
used for the OCI Image Format specification. When you create a container
from an image, this information is used as one of the inputs to create
the container.

[]{#02.htm_pgfId-1038344}When using the `inspect`{.fm-code-in-text}
command, it is often better to pipe its output to
`less`{.fm-code-in-text} or `grep`{.fm-code-in-text} to find particular
fields you are interested in. Alternatively, you can use the
`--format`{.fm-code-in-text} option[]{#02.htm_marker-1038345}.

[]{#02.htm_pgfId-1038346}If you want to to examine the default command
to be executed from this image, execute the following:

``` programlisting
$ podman image inspect --format '{{ .Config.Cmd }}' myimage
[/usr/bin/run-httpd]
```

[]{#02.htm_pgfId-1038349}Or if you want to see the stop signal, execute

``` programlisting
$ podman image inspect --format '{{ .Config.StopSignal }}' myimage
```

[]{#02.htm_pgfId-1038351}As you can see, nothing is output, meaning the
developer of the application did not specify a
`STOPSIGNAL`{.fm-code-in-text}. When you build a container off of this
image, the `STOPSIGNAL`{.fm-code-in-text} is the default,
`15`{.fm-code-in-text}, unless you override it via the command line.

[]{#02.htm_pgfId-1038354}[]{#02.htm_id_b2ilzpve6pxb}One notable
`podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`inspect`{.fm-code-in-text} option is[]{#02.htm_marker-1038353} the
following:

- []{#02.htm_pgfId-1038356
  .calibre17}`--format`{.fm-code-in-text}[]{#02.htm_marker-1038355
  .calibre17}---This is useful as you see above to extract particular
  fields out of the json.

[]{#02.htm_pgfId-1038358}Use the `man`{.fm-code-in-text}
`podman-image-inspect`{.fm-code-in-text}
command[]{#02.htm_marker-1038357} for information about the command.

[]{#02.htm_pgfId-1038359}Once you are happy with a container and commit
it to an image, the next step is sharing it with others or perhaps
running it on another system. You need to push the image out to other
types of container storage, usually a container
[]{#02.htm_marker-1038360}[]{#02.htm_marker-1038361}[]{#02.htm_marker-1038362}registry.

### []{#02.htm_pgfId-1038364}2.2.4 Pushing images {#02.htm_heading_id_17 .fm-head1}

[]{#02.htm_pgfId-1038369}In
[]{#02.htm_marker-1038365}[]{#02.htm_marker-1038366}[]{#02.htm_marker-1038367}Podman,
you use the `podman`{.fm-code-in-text} `push`{.fm-code-in-text}
command[]{#02.htm_marker-1038368} to copy an image and all of its layers
out of container storage and push it to other forms of container image
storage, like a container registry. Podman supports a few different
types of container storage, which it calls transports.

[]{#02.htm_pgfId-1038371}Container transports

[]{#02.htm_pgfId-1038374}Podman
[]{#02.htm_marker-1038372}[]{#02.htm_marker-1038373}uses the
containers/image library
([https://github.com/containers/image](https://github.com/containers/image){.url})
for pulling and pushing images. I describe the containers/image project
as a library for copying images between different types of container
storage. One storage, as you have seen, is containers/storage.

[]{#02.htm_pgfId-1038375}When pushing an image, the
`[destination]`{.fm-code-in-text} is specified using
`transport:ImageName`{.fm-code-in-text}
format[]{#02.htm_marker-1038376}. If no transport is specified, the
`docker`{.fm-code-in-text} (container registry) transport is used by
default.

[]{#02.htm_pgfId-1038377}One of the novel things that Docker did, as I
explained earlier, was invent the container registry
concept---basically, a web server that contains container images. The
docker.io, quay.io, and Artifactory web servers are all examples of
container registries. The Docker engineering team defined a protocol for
pulling and pushing these images from the container registries, which I
refer to as the container registry or `docker`{.fm-code-in-text}
transport[]{#02.htm_marker-1038378}.

[]{#02.htm_pgfId-1038379}When I want to run a container of an image, I
can fully specify the image name, including the transport like the
following command:

``` programlisting
$ podman run docker://registry.access.redhat.com/ubi8/httpd-24:latest echo hello
hello
```

[]{#02.htm_pgfId-1038382}For Podman, `docker://`{.fm-code-in-text}
transport is the default; it can be skipped for convenience:

``` programlisting
$ podman run registry.access.redhat.com/ubi8/httpd-24:latest echo hello
hello
```

[]{#02.htm_pgfId-1038386}The `myimage`{.fm-code-in-text}
image[]{#02.htm_marker-1038385} you created in the previous section was
created locally, which means it doesn't have a registry associated with
it. By default, locally created images have the localhost registry
associated with them. You can see the images in the containers/storage
using the `podman`{.fm-code-in-text} `images`{.fm-code-in-text} command:

``` programlisting
$ podman images
REPOSITORY                        TAG        IMAGE ID       CREATED    SIZE
localhost/myimage              latest    2c7e43d88038  46 hours ago  462 MB
registry.access.redhat
➥.com/ubi8/httpd-24           latest    8594be0a0b57   5 weeks ago  462 MB
registry.access.redhat
➥.com/ubi8                    latest    ad42391b9b46   5 weeks ago  234 MB
```

[]{#02.htm_pgfId-1038393}If the image has a remote
registry[]{#02.htm_marker-1038392} associated with it (e.g.,
registry.access.redhat.com/ ubi8), it can be pushed without specifying
the `[destination]`{.fm-code-in-text} field. On the contrary, since
localhost/myimage does not have a registry associated with it, remote
registry needs to be specified (e.g., quay.io/rhatdan):

``` programlisting
$ podman push myimage quay.io/rhatdan/myimage
Getting image source signatures
Copying blob 164d51196137 done 
Copying blob 8f26704f753c done 
Copying blob 83310c7c677c done 
Copying blob 654b3bf1361e [==================>-------------------] 82.0MiB / 162.7MiB
Copying blob e39c3abf0df9 [================>---------------------] 100.0MiB / 222.8MiB
```

[]{#02.htm_pgfId-1038402}[Note]{.fm-callout-head} Before executing the
`podman`{.fm-code-in-text1} `push`{.fm-code-in-text1}
command[]{#02.htm_marker-1038401}, I logged into the quay.io/ rhatdan
account using p`odman`{.fm-code-in-text1} `login`{.fm-code-in-text1},
which is covered in the next section.

[]{#02.htm_pgfId-1038403}After the `push`{.fm-code-in-text} command is
finished, the image becomes available for pull for other users, given
they have access to this container registry. Table 2.3 describes the
supported transports for different types of container's storage.

[]{#02.htm_pgfId-1045276}Table 2.3 Podman-supported transports

+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045280}Transport                                                                                  | []{#02.htm_pgfId-1045282}Description                |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045284}Container registry (Docker[]{#02.htm_marker-1045311})                                      | []{#02.htm_pgfId-1045286}Default transport. This    |
|                                                                                                                     | references a container image stored in a remote     |
|                                                                                                                     | container image registry. Container registry is a   |
|                                                                                                                     | place for storing and sharing container images      |
|                                                                                                                     | (e.g., docker.io or quay.io).                       |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045288}`oci`{.fm-code-in-text1}[]{#02.htm_marker-1045312}                                         | []{#02.htm_pgfId-1045290}References a container     |
|                                                                                                                     | image, compliant with the Open Container Image      |
|                                                                                                                     | Layout Specification. The manifest and layer        |
|                                                                                                                     | tarballs as individual files are located in the     |
|                                                                                                                     | local directory.                                    |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045292}`dir`{.fm-code-in-text1}[]{#02.htm_marker-1045313}                                         | []{#02.htm_pgfId-1045294}References a container     |
|                                                                                                                     | image, compliant with the Docker image layout. It   |
|                                                                                                                     | is very similar to the `oci`{.fm-code-in-text1}     |
|                                                                                                                     | transport but stores the files using the legacy     |
|                                                                                                                     | Docker format. It is a nonstandardized format,      |
|                                                                                                                     | primarily useful for debugging or noninvasive       |
|                                                                                                                     | container inspection.                               |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045296}`docker-archive`{.fm-code-in-text1}[]{#02.htm_marker-1045314}                              | []{#02.htm_pgfId-1045298}References a container     |
|                                                                                                                     | image in Docker image layout, which is packed into  |
|                                                                                                                     | a TAR archive.                                      |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045300}`oci-archive`{.fm-code-in-text1}                                                           | []{#02.htm_pgfId-1045302}References an image        |
|                                                                                                                     | compliant with the Open Container Image Layout      |
|                                                                                                                     | Specification, which is packed into a TAR archive.  |
|                                                                                                                     | It is very similar to the                           |
|                                                                                                                     | `docker-archive`{.fm-code-in-text1} transport, but  |
|                                                                                                                     | it stores an image in OCI format.                   |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045304}`docker-daemon`{.fm-code-in-text1}[]{#02.htm_marker-1045315}                               | []{#02.htm_pgfId-1045306}References an image stored |
|                                                                                                                     | in the Docker daemon's internal storage. Since the  |
|                                                                                                                     | Docker daemon requires root privileges, Podman has  |
|                                                                                                                     | to be run by the root user.                         |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#02.htm_pgfId-1045308}`container-storage`{.fm-code-in-text1}[]{#02.htm_marker-1045316}[]{#02.htm_marker-1045317} | []{#02.htm_pgfId-1045310}References an image        |
|                                                                                                                     | located in a local container storage. It is not a   |
|                                                                                                                     | transport but more of a mechanism for storing       |
|                                                                                                                     | images. It can be used to convert other transports  |
|                                                                                                                     | into `container-storage`{.fm-code-in-text1}. Podman |
|                                                                                                                     | defaults to using                                   |
|                                                                                                                     | `container-storage`{.fm-code-in-text1} for local    |
|                                                                                                                     | images.                                             |
+---------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#02.htm_pgfId-1038448}You want to push your image to a container
registry, but if you try to push it, the container registry rejects your
push, since you have not provided login authorization information. You
need to execute `podman`{.fm-code-in-text} `login`{.fm-code-in-text} to
create []{#02.htm_marker-1045225}[]{#02.htm_marker-1045226}the
[]{#02.htm_marker-1045227}[]{#02.htm_marker-1045228}[]{#02.htm_marker-1045229}authorization.

### []{#02.htm_pgfId-1038455}2.2.5 podman login: Logging into a container registry {#02.htm_heading_id_18 .fm-head1}

[]{#02.htm_pgfId-1038459}In
[]{#02.htm_marker-1038456}[]{#02.htm_marker-1038457}[]{#02.htm_marker-1038458}the
previous section, I pushed the image to my container registry by
executing the following:

``` programlisting
$ podman push myimage quay.io/rhatdan/myimage
```

[]{#02.htm_pgfId-1038461}However, I left out a key step: logging into a
container registry using correct credentials. This is a necessary step
for pushing a container image. It is also required for pulling a
container image from a private registry.

[]{#02.htm_pgfId-1038462}To follow along in this section, you need to
set up an account at a container registry; there are several container
registries available to choose from. The
[https://quay.io](https://quay.io){.url} and
[https://docker.io](https://docker.io){.url} registries both provide
free accounts and storage. Your company might have a private registry,
where you can also get an account.

[]{#02.htm_pgfId-1038463}For the examples, I will continue to use my
rhatdan account at quay.io. Log in to get your credentials:

``` programlisting
$ podman login quay.io
Username: rhatdan
Password: 
Login Succeeded!
```

[]{#02.htm_pgfId-1038468}Notice the Podman command prompts you for your
username and password at the registry. The `podman`{.fm-code-in-text}
`login`{.fm-code-in-text} command[]{#02.htm_marker-1038469} has options
to pass the username/password information on the command line to avoid
the prompt, allowing you to automate the login process.

[]{#02.htm_pgfId-1038471}To store authentication information for the
user, the `podman`{.fm-code-in-text} `login`{.fm-code-in-text}
command[]{#02.htm_marker-1038470} creates an auth.json file. By default,
this is stored in the /run/user/\$UID/containers/auth.json file:

``` programlisting
cat /run/user/3267/containers/auth.json 
{
  "auths": {
    "quay.io": {
      "auth": "OBSCURED-BASE64-PASSWORD"
    }
  }
}
```

[]{#02.htm_pgfId-1038480}The auth.json file contains your registry
password in a Base64-encoded string; there is no cryptography involved.
Therefore, the auth.json file needs to be protected. Podman defaults to
storing the file in /run because it is a temporary filesystem and is
destroyed when you log out or the system is rebooted. The
/run/user/\$UID/containers directory is not accessible by other users on
the system.

[]{#02.htm_pgfId-1038482}It is possible to override the location by
specifying the `--auth-file`{.fm-code-in-text}
option[]{#02.htm_marker-1038481}. Alternatively, you can use the
`REGISTRY_AUTH_FILE`{.fm-code-in-text} environment variable to modify
its location. If both are specified, the `--auth-file`{.fm-code-in-text}
option[]{#02.htm_marker-1038483} is used. All container tools use this
file to access the container registry.

[]{#02.htm_pgfId-1038485}It is possible to run the
`podman`{.fm-code-in-text} `login`{.fm-code-in-text}
command[]{#02.htm_marker-1038484} multiple times to log in to multiple
registries, storing the login information in the same authorization file
with a different stanza.

[]{#02.htm_pgfId-1038486}[Note]{.fm-callout-head} Podman supports other
mechanisms for storing the password information. These are called
*credential helpers*[]{#02.htm_marker-1038487}.

[]{#02.htm_pgfId-1038488}After you are done using the registry, you can
log out by executing `podman`{.fm-code-in-text}
`logout`{.fm-code-in-text}. This command deletes the cached credentials
stored in the auth.json file:

``` programlisting
$ podman logout quay.io
Removed login credentials for quay.io
```

[]{#02.htm_pgfId-1038493}[]{#02.htm_id_kl9hru67otu4}Some notable
`podman`{.fm-code-in-text}
`login`{.fm-code-in-text}[]{#02.htm_marker-1038492} and
`logout`{.fm-code-in-text} options include the following:

- []{#02.htm_pgfId-1038495 .calibre17}`--username`{.fm-code-in-text},
  `(-u`{.fm-code-in-text}[]{#02.htm_marker-1038494 .calibre17}---This
  provides the Podman username to use when logging into the registry.

- []{#02.htm_pgfId-1038497
  .calibre17}`--authfile`{.fm-code-in-text}[]{#02.htm_marker-1038496
  .calibre17}---This tells Podman to store the authorization file in a
  different location. You can also use the
  `REGISTRY_AUTH_FILE`{.fm-code-in-text} environment
  variable[]{#02.htm_marker-1038498 .calibre17} to change the location.

- []{#02.htm_pgfId-1038500
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1038499
  .calibre17}---This allows you to log out of all of the registries.

[]{#02.htm_pgfId-1038502}Use the `man`{.fm-code-in-text}
`podman-login`{.fm-code-in-text} and `man`{.fm-code-in-text}
`podman-logout`{.fm-code-in-text} commands[]{#02.htm_marker-1038501} for
information about all options.

[]{#02.htm_pgfId-1038503}Notice when you pushed the image to a container
registry, you renamed `myimage`{.fm-code-in-text} to
quay.io/rhatdan/myimage:

``` programlisting
$ podman push myimage quay.io/rhatdan/myimage
```

[]{#02.htm_pgfId-1038505}It'd be nice to just have the local image named
quay.io/rhatdan/myimage, in which case you could have just executed

``` programlisting
$ podman push quay.io/rhatdan/myimage
```

[]{#02.htm_pgfId-1038510}In the next section, you will learn how to add
names
to[]{#02.htm_marker-1038507}[]{#02.htm_marker-1038508}[]{#02.htm_marker-1038509}
images.

### []{#02.htm_pgfId-1038512}2.2.6 Tagging images {#02.htm_heading_id_19 .fm-head1}

[]{#02.htm_pgfId-1038516}Earlier
[]{#02.htm_marker-1038513}[]{#02.htm_marker-1038514}[]{#02.htm_marker-1038515}in
this chapter, I pointed out that locally created images are created with
a localhost registry. Images get created with the localhost registry
when you commit a container to an image or if you use
`podman`{.fm-code-in-text} `build`{.fm-code-in-text} to build an image.
Podman has a mechanism to add additional names to images; it calls these
names tags, and the command is `podman`{.fm-code-in-text}
`tag`{.fm-code-in-text}[]{#02.htm_marker-1038517}.

[]{#02.htm_pgfId-1038519}Using the `podman`{.fm-code-in-text}
`images`{.fm-code-in-text} command[]{#02.htm_marker-1038518}, list the
image(s) in container/storage:

``` programlisting
$ podman images
REPOSITORY                      TAG        IMAGE ID         CREATED     SIZE
localhost/myimage            latest    2c7e43d88038   46 \hours ago   462 MB
registry.access.redhat
➥.com/ubi8/httpd-24         latest    8594be0a0b57     5 weeks ago   462 MB
registry.access.redhat
➥.com/ubi8                  latest    ad42391b9b46     5 weeks ago   234 MB
```

[]{#02.htm_pgfId-1038525}You will want the final image you plan on
shipping to be referred to as quay.io/rhatdan/ myimage. To achieve this,
add that name with the following `podman`{.fm-code-in-text}
`tag`{.fm-code-in-text} command[]{#02.htm_marker-1038526}:

``` programlisting
$ podman tag myimage quay.io/rhatdan/myimage 
```

[]{#02.htm_pgfId-1038529}Now run[]{#02.htm_marker-1038528}
`podman`{.fm-code-in-text} `images`{.fm-code-in-text} again to examine
the images. You will see that the name is now quay.io/rhatdan/myimage.
Notice that the localhost/myimage and quay.io/ rhatdan/myimage have the
same image ID of `2c7e43d88038`{.fm-code-in-text}:

``` programlisting
$ podman images
REPOSITORY                      TAG        IMAGE ID        CREATED      SIZE
localhost/myimage            latest    2c7e43d88038   46 hours ago    462 MB
quay.io/rhatdan/myimage      latest    2c7e43d88038   46 hours ago    462 MB
registry.access.redhat
➥.com/ubi8/httpd-24         latest    8594be0a0b57    5 weeks ago    462 MB
registry.access.redhat
➥.com/ubi8                  latest    ad42391b9b46    5 weeks ago    234 MB
```

[]{#02.htm_pgfId-1038536}Since the images have the same image ID, they
are the same image with multiple names. Now you can interact directly
with quay.io/rhatdan/myimage. First, you need to log back in to quay.io:

``` programlisting
$ podman login --username rhatdan quay.io
Password: 
Login Succeeded!
```

[]{#02.htm_pgfId-1038540}Now push without requiring the destination
name:

``` programlisting
$ podman push quay.io/rhatdan/myimage
Getting image source signatures
...
Storing signatures
```

[]{#02.htm_pgfId-1038545}That was much simpler.

[]{#02.htm_pgfId-1038546}Let's tag the previously used image with a
version, 1.0:

``` programlisting
$ podman tag quay.io/rhatdan/myimage quay.io/rhatdan/myimage:
```

[]{#02.htm_pgfId-1038548}Once again, examine the images; notice that
`myimage`{.fm-code-in-text} now has three different names/tags. All
three have the same image ID of `2c7e43d88038`{.fm-code-in-text}:

``` programlisting
$ podman images
REPOSITORY                      TAG        IMAGE ID        CREATED     SIZE
localhost/myimage            latest    2c7e43d88038   46 hours ago   462 MB
quay.io/rhatdan/myimage         1.0    2c7e43d88038   46 hours ago   462 MB
quay.io/rhatdan/myimage      latest    2c7e43d88038   46 hours ago   462 MB
registry.access.redhat
➥.com/ubi8/httpd-24         latest    8594be0a0b57    5 weeks ago   462 MB
registry.access.redhat
➥.com/ubi8                  latest    ad42391b9b46    5 weeks ago   234 MB
```

[]{#02.htm_pgfId-1038556}Now you can push the 1.0 version of the
`myimage`{.fm-code-in-text} (application) to the registry:

``` programlisting
$ podman push quay.io/rhatdan/myimage:1.0
Getting image source signatures
Copying blob 8f26704f753c skipped: already exists 
Copying blob e39c3abf0df9 skipped: already exists 
Copying blob 654b3bf1361e skipped: already exists 
Copying blob 83310c7c677c skipped: already exists 
Copying blob 164d51196137 [--------------------------------------] 0.0b / 0.0b
Copying config 2c7e43d880 [--------------------------------------] 0.0b / 4.0KiB
Writing manifest to image destination
Storing signatures
```

[]{#02.htm_pgfId-1038567}Users can pull either the latest image or the
1.0 version. Later, when you build version 2.0 of your application, you
can store both images at the registry. You can run both version 1.0 and
2.0 of your application on the host at the same time.

[]{#02.htm_pgfId-1038568}Use a web browser (e.g., Firefox, Chrome,
Safari, Internet Explorer, or Microsoft Edge) to look at the images at
quay.io. You can see 1.0 and the latest image in figure 2.4:

``` programlisting
$ web-browser quay.io/repository/rhatdan/myimage?tab=tags
```

::: figure
![](images/02-04.png){.calibre18}

[]{#02.htm_pgfId-1053027}Figure 2.4 List of `myimage`{.fm-code-in-text}
tags on quay.io
([https://quay.io/repository/rhatdan/myimage/?tab=tags](https://quay.io/repository/rhatdan/myimage/?tab=tags){.url})
:::

[]{#02.htm_pgfId-1038570}Now that you have pushed your image to a
container registry, you may want to free up storage from your home
directory by removing the
[]{#02.htm_marker-1038571}[]{#02.htm_marker-1038572}[]{#02.htm_marker-1038573}images.

[]{#02.htm_pgfId-1038581}[Note]{.fm-callout-head} Contrary to common
sense, the tag `latest`{.fm-code-in-text1} does not refer to the most
up-to-date image in the repository. It is just another tag with no magic
involved. Even worse, because it is being used as a default tag for
images pushed without tags, it could refer to any random version of an
image. There could be newer images in the container registry than your
local container's storage with this tag. Thus, it is always better to
refer to the specific version of the image you want to use, rather than
relying on the `latest`{.fm-code-in-text1}.

### []{#02.htm_pgfId-1038583}2.2.7 Removing images {#02.htm_heading_id_20 .fm-head1}

[]{#02.htm_pgfId-1038587}Over
[]{#02.htm_marker-1038584}[]{#02.htm_marker-1038585}[]{#02.htm_marker-1038586}time,
images can take up a lot of disk space. Thus, it will be a good idea to
remove images you no longer use. Let's list local images first:

``` programlisting
$ podman images
REPOSITORY                          TAG        IMAGE ID       CREATED    SIZE
localhost/myimage                   1.0    2c7e43d88038  46 hours ago  462 MB
quay.io/rhatdan/myimage             1.0    2c7e43d88038  46 hours ago  462 MB
quay.io/rhatdan/myimage          latest    2c7e43d88038  46 hours ago  462 MB
registry.access.redhat
➥.com/ubi8/httpd-24             latest    8594be0a0b57   5 weeks ago  462 MB
registry.access.redhat
➥.com/ubi8                      latest    ad42391b9b46   5 weeks ago  234 MB
```

[]{#02.htm_pgfId-1038596}Use the `podman`{.fm-code-in-text}
`rmi`{.fm-code-in-text} command[]{#02.htm_marker-1038595} to remove
local images:

``` programlisting
$ podman rmi localhost/myimage
Untagged: localhost/myimage:latest
```

[]{#02.htm_pgfId-1038599}Listing the local images again, you will see
that the command didn't actually remove the image but only the
`localhost`{.fm-code-in-text} tag[]{#02.htm_marker-1038600} from the
image. Podman still has two references to the same image ID: the actual
content of the image has not been removed. None of the disk space was
freed up:

``` programlisting
$ podman images
REPOSITORY                         TAG        IMAGE ID      CREATED     SIZE
quay.io/rhatdan/myimage            1.0    2c7e43d88038  46 hours ago  462 MB
quay.io/rhatdan/myimage         latest    2c7e43d88038  46 hours ago  462 MB
registry.access.redhat
➥.com/ubi8/httpd-24            latest    8594be0a0b57   5 weeks ago  462 MB
registry.access.redhat
➥.com/ubi8                     latest    ad42391b9b46   5 weeks ago   234 MB
```

[]{#02.htm_pgfId-1038608}You can remove the other tags using a short
name (see section 2.2.8). Podman uses the short name and finds the first
name in local storage that matches the short name without a registry and
removes it, which is why I need to remove it twice to get rid of both
images. Tags other than `latest`{.fm-code-in-text} need to be specified
explicitly:

``` programlisting
$ podman rmi myimage
Untagged: quay.io/rhatdan/myimage:latest
$ podman rmi myimage:1.0
Untagged: quay.io/rhatdan/myimage:1.0
Deleted: 2c7e43d88038669e8cdbdff324a9f9605d99697215a0d21c360fe8dfa8471bab
 
```

[]{#02.htm_pgfId-1038614}It is only when the last tag is removed that
the actual disk space is reclaimed:

``` programlisting
$ podman images
REPOSITORY                         TAG        IMAGE ID       CREATED     SIZE
registry.access.redhat
➥.com/ubi8/httpd-24            latest    8594be0a0b57   5 weeks ago   462 MB
registry.access.redhat
➥.com/ubi8                     latest    ad42391b9b46   5 weeks ago   234 MB
```

[]{#02.htm_pgfId-1038619}Alternatively, you can try removing the images
by specifying the image ID:

``` programlisting
$ podman rmi 14119a10abf4
Error: unable to delete image\ 
➥ "2c7e43d88038669e8cdbdff324a9f9605d99697215a0d21c360fe8dfa8471bab" by\ 
➥ ID with more than one tag ([quay.io/rhatdan/myimage:1.0\ 
➥ quay.io/rhatdan/myimage:latest]): please force removal
```

[]{#02.htm_pgfId-1038622}But that fails because there are multiple tags
for the same image. Adding the `--force`{.fm-code-in-text}
option[]{#02.htm_marker-1038623} removes the image and all of its tags:

``` programlisting
$ podman rmi 14119a10abf4 --force
Untagged: quay.io/rhatdan/myimage:1.0
Untagged: quay.io/rhatdan/myimage:latest
Deleted: 2c7e43d88038669e8cdbdff324a9f9605d99697215a0d21c360fe8dfa8471bab
```

[]{#02.htm_pgfId-1038628}As your image sizes and numbers grow and more
containers are created, it becomes harder to figure out which images are
no longer needed. Podman has another useful
command---`podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`prune`{.fm-code-in-text}[]{#02.htm_marker-1038629}---for removing all
dangling images[]{#02.htm_marker-1038630}. *Dangling
images*[]{#02.htm_marker-1038631} are images that no longer have a tag
associated with them or a container using them. The
`prune`{.fm-code-in-text} command[]{#02.htm_marker-1038632} also has the
`--all`{.fm-code-in-text} option[]{#02.htm_marker-1038633}, which
removes all images that are currently not in use by any containers,
including dangling images:

``` programlisting
$ podman image prune -a
WARNING! This command removes all images without at least one container \
➥ associated with them.
Are you sure you want to continue? [y/N] y
6d633c2626113fb4e5aa75babb2af39268948497893f7bb5b4c2043d7a986ba0
B9097177b416944cabdcfcab0e74a319223ad1acaed38ac57a262b2421732355
```

[]{#02.htm_pgfId-1038640}[Note]{.fm-callout-head} Having no containers
running the `podman`{.fm-code-in-text1} `image`{.fm-code-in-text1}
`prune`{.fm-code-in-text1} command[]{#02.htm_marker-1038639} removes all
of the local images. This frees up all of the disk space in the home
directory. You can use the `podman`{.fm-code-in-text1}
`system`{.fm-code-in-text1} `df`{.fm-code-in-text1} command to show all
of the storage in your home directory used by Podman.

``` programlisting
$ podman images
REPOSITORY                              TAG       IMAGE ID    CREATED    SIZE
```

[]{#02.htm_pgfId-1038645}[]{#02.htm_id_k1qw18a94248}Some notable
`podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`prune`{.fm-code-in-text} options[]{#02.htm_marker-1038644} include the
following:

- []{#02.htm_pgfId-1038647
  .calibre17}`--all`{.fm-code-in-text}[]{#02.htm_marker-1038646
  .calibre17}---This tells Podman to remove all images, freeing up all
  storage. Images that have containers running on them are not removed.

- []{#02.htm_pgfId-1038649
  .calibre17}`--force`{.fm-code-in-text}[]{#02.htm_marker-1038648
  .calibre17}---This tells Podman to stop and remove any containers that
  are running on them and remove any images dependent on the image you
  are attempting to remove.

[]{#02.htm_pgfId-1038651}Use the `man`{.fm-code-in-text}
`podman-image-prune`{.fm-code-in-text} command[]{#02.htm_marker-1038650}
for information about all options.

[]{#02.htm_pgfId-1038652}Images pushed to the registry could also be
pulled for various reasons, including but not limited to sharing your
applications with others, testing other versions, getting back removed
local versions, and working on a new version of an
[]{#02.htm_marker-1038653}[]{#02.htm_marker-1038654}[]{#02.htm_marker-1038655}image.

### []{#02.htm_pgfId-1038657}2.2.8 Pulling images {#02.htm_heading_id_21 .fm-head1}

[]{#02.htm_pgfId-1038661}Although
[]{#02.htm_marker-1038658}[]{#02.htm_marker-1038659}[]{#02.htm_marker-1038660}you
previously removed all local images, you can pull the previously pushed
image at quay.io/rhatdan/myimage. Podman has the
`podman`{.fm-code-in-text} `pull`{.fm-code-in-text}
command[]{#02.htm_marker-1038662}[]{#02.htm_marker-1038663} to pull
images from container registries (transports) into local container
storage:

``` programlisting
$ podman pull quay.io/rhatdan/myimage
Trying to pull quay.io/rhatdan/myimage:latest...
Getting image source signatures
Copying blob dfd8c625d022 done 
Copying blob e21480a19686 done 
Copying blob 68e8857e6dcb done 
Copying blob 3f412c5136dd done 
Copying blob fbfcc23454c6 done 
Copying config 2c7e43d880 done 
Writing manifest to image destination
Storing signatures
2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae
```

[]{#02.htm_pgfId-1038676}Does the output look familiar? You probably
remember similar output from the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#02.htm_marker-1038677} from section
2.1.2:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp\ 
➥ registry.access.redhat.com/ubi8/httpd-24
Trying to pull registry.access.redhat.com/ubi8/httpd-24:latest...
Getting image source signatures
Checking if image destination supports signatures
Copying blob 296e14ee2414 skipped: already exists  
Copying blob 356f18f3a935 skipped: already exists  
Copying blob 359fed170a21 done
Copying blob 226cafc3a0c6 done
Writing manifest to image destination
Storing signatures
37a1d2e31dbf4fa311a5ca6453f53106eaae2d8b9b9da264015cc3f8864fac22
```

[]{#02.htm_pgfId-1038690}Many Podman commands implicitly execute the
`podman`{.fm-code-in-text} `pull`{.fm-code-in-text}
command[]{#02.htm_marker-1038689} if the required image is not present
locally.

[]{#02.htm_pgfId-1038691}So executing `podman`{.fm-code-in-text}
`images`{.fm-code-in-text} shows the image back in container storage,
ready to be used for containers:

``` programlisting
$ podman images
REPOSITORY                   TAG        IMAGE ID     CREATED    SIZE
quay.io/rhatdan/myimage   latest    2c7e43d88038  2 days ago  462 MB
```

[]{#02.htm_pgfId-1038695}Up until now, you have been typing the image
with the full names as registry.access .redhat.com/ubi8/httpd-24 or
quay.io/rhatdan/myimage, but if you are like me and not a great typist,
this can be a pain. You really need a way to refer to the images via
short names.

[]{#02.htm_pgfId-1038697}Short names and container registries

[]{#02.htm_pgfId-1038701}When
[]{#02.htm_marker-1045424}[]{#02.htm_marker-1045425}[]{#02.htm_marker-1045426}Docker
first hit the scene, they defined an image reference as a combination of
the container registry where the image was stored, repository, image
name, and a tag or version of the image. In our examples, we have been
using quay.io/rhatdan/myimage. In table 2.4, you can see this image name
breakdown; note that the `latest`{.fm-code-in-text}
tag[]{#02.htm_marker-1045428} was used implicitly, as the image version
wasn't specified.

[]{#02.htm_pgfId-1045368}Table 2.4 Container image name table

+------------------------------------------------------------+-------------------------------------+----------------------------------+------------------------------------------------------+
| []{#02.htm_pgfId-1045376}Registry                          | []{#02.htm_pgfId-1045378}Repository | []{#02.htm_pgfId-1045380}Name    | []{#02.htm_pgfId-1045382}Tag                         |
+------------------------------------------------------------+-------------------------------------+----------------------------------+------------------------------------------------------+
| []{#02.htm_pgfId-1045384}quay.io[]{#02.htm_marker-1045447} | []{#02.htm_pgfId-1045386}rhatdan    | []{#02.htm_pgfId-1045388}myimage | []{#02.htm_pgfId-1045390}`latest`{.fm-code-in-text1} |
+------------------------------------------------------------+-------------------------------------+----------------------------------+------------------------------------------------------+

[]{#02.htm_pgfId-1038724}The Docker command line has internally set the
docker.io registry as the only registry, thus making every short image
name refer to images at docker.io. There is also a special repository
library, which is used for certified images.

[]{#02.htm_pgfId-1038725}So rather than typing

``` programlisting
# docker pull docker.io/library/alpine:latest
```

[]{#02.htm_pgfId-1038727}You can just execute

``` programlisting
# docker pull alpine
```

[]{#02.htm_pgfId-1038729}Conversely, if you want to pull an image from a
different registry, you need to specify the full name of the image:

``` programlisting
# docker pull registry.access.redhat.com/ubi8/httpd-24:latest
```

[]{#02.htm_pgfId-1038731}Table 2.5 shows the difference between the
image name used in a short name versus the fully specified image name.
Notice that when using the short name, the registry, repository, and tag
were not specified.

[]{#02.htm_pgfId-1045492}Table 2.5 Short name to container image name
table

+--------------------------------------------------------------+-------------------------------------+---------------------------------+------------------------------------------------------+
| []{#02.htm_pgfId-1045500}Registry                            | []{#02.htm_pgfId-1045502}Repository | []{#02.htm_pgfId-1045504}Name   | []{#02.htm_pgfId-1045506}Tag                         |
+--------------------------------------------------------------+-------------------------------------+---------------------------------+------------------------------------------------------+
| []{#02.htm_pgfId-1045508}                                    | []{#02.htm_pgfId-1045510}           | []{#02.htm_pgfId-1045512}alpine | []{#02.htm_pgfId-1045514}                            |
+--------------------------------------------------------------+-------------------------------------+---------------------------------+------------------------------------------------------+
| []{#02.htm_pgfId-1045516}docker.io[]{#02.htm_marker-1045523} | []{#02.htm_pgfId-1045518}library    | []{#02.htm_pgfId-1045520}alpine | []{#02.htm_pgfId-1045522}`latest`{.fm-code-in-text1} |
+--------------------------------------------------------------+-------------------------------------+---------------------------------+------------------------------------------------------+

[]{#02.htm_pgfId-1038761}Since I am lazy and hate to type extra
characters, I almost always use short names. With Podman, the developers
did not want to hardcode one registry, docker.io, into the tool. Podman
allows distributions, companies, and you to control which registries to
use and to be able to configure multiple registries. At the same time,
Podman provides support for the easier-to-use short names.

[]{#02.htm_pgfId-1038762}Podman usually comes with multiple registries
defined, controlled by the distribution that packaged Podman. You can
use the `podman`{.fm-code-in-text} `info`{.fm-code-in-text}
command[]{#02.htm_marker-1038763} to see what registries are defined for
your Podman installation:

``` programlisting
$ podman info
...
registries:
  search:
  - registry.fedoraproject.org
  - registry.access.redhat.com
  - docker.io
  - quay.io
```

[]{#02.htm_pgfId-1038772}The list of registries can be modified in the
registries.conf file, which is described in section 5.2.1.

[]{#02.htm_pgfId-1038773}Let's discuss the security side of things using
these commands:

``` programlisting
$ podman pull rhatdan/myimage
$ podman pull quay.io/rhatdan/myimage
```

[]{#02.htm_pgfId-1038776}From a security perspective, it is always
better to specify the full image name when pulling it from a registry.
That way, Podman guarantees that it pulls from the specified registry.
Imagine you are attempting to pull rhatdan/myimage. Using the previous
search order, there is a chance someone could set up an account on
docker.io/rhatdan and trick you into mistakenly pulling
docker.io/rhatdan/myimage.

[]{#02.htm_pgfId-1038777}To help protect against this, on the first pull
of an image, Podman prompts you to select an exact image from the list
of found images in configured registries:

``` programlisting
$ podman create -p 8080:8080 ubi8/httpd-24 
? Please select an image: 
   registry.fedoraproject.org/ubi8/httpd-24:latest
 ▸ registry.access.redhat.com/ubi8/httpd-24:latest
   docker.io/ubi8/httpd-24:latest
   quay.io/ubi8/httpd-24:latest
```

[]{#02.htm_pgfId-1038784}Once you have selected and pulled an image
successfully, Podman records the short name mapping. In the future, when
you run a container with this short name, Podman uses the short name
mapping to pick the correct registry and does not prompt.

[]{#02.htm_pgfId-1038785}Linux distributions also ship mappings of the
most commonly used short names, as they want you to pull from their
supported registries. You can find these short name configuration files
in the /etc/containers/registries.conf.d directory on the Linux host.
Companies can also drop short name alias files in this directory:

``` programlisting
$ cat /etc/containers/registries.conf.d/000-shortnames.conf
[aliases]
  # centos
  "centos" = "quay.io/centos/centos"
  # containers
  "skopeo" = "quay.io/skopeo/stable"
  "buildah" = "quay.io/buildah/stable"
  "podman" = "quay.io/podman/stable"
...
```

[]{#02.htm_pgfId-1038797}[]{#02.htm_id_alh8ymvwn26r}[]{#02.htm_id_xpx7qets8jwc}Some
notable `podman`{.fm-code-in-text} `pull`{.fm-code-in-text} options
include the following:

- []{#02.htm_pgfId-1038799
  .calibre17}`--arch`{.fm-code-in-text}[]{#02.htm_marker-1038798
  .calibre17}---This tells Podman to pull an image for a different
  architecture. For example, on my x86_64 machine, I can pull an arm64
  image. By default, `podman`{.fm-code-in-text} `pull`{.fm-code-in-text}
  pulls images for the native architecture.

- []{#02.htm_pgfId-1038801 .calibre17}`--quiet`{.fm-code-in-text}
  `(-q`{.fm-code-in-text}[]{#02.htm_marker-1038800
  .calibre17}`)`{.fm-code-in-text}---This tells Podman not to print out
  all the progress information. It just prints the image ID when it
  completes.

[]{#02.htm_pgfId-1038803}Use the `man`{.fm-code-in-text}
`podman-pull`{.fm-code-in-text} command[]{#02.htm_marker-1038802} for
information about all options.

[]{#02.htm_pgfId-1038804}I have mentioned a few images in this book, but
there are thousands and thousands of images available. You need a
mechanism to be able to search through these images for the
[]{#02.htm_marker-1038805}[]{#02.htm_marker-1038806}[]{#02.htm_marker-1038807}perfect
[]{#02.htm_marker-1038808}[]{#02.htm_marker-1038809}[]{#02.htm_marker-1038810}match.

### []{#02.htm_pgfId-1038812}2.2.9 Searching for images {#02.htm_heading_id_22 .fm-head1}

[]{#02.htm_pgfId-1038816}You
[]{#02.htm_marker-1038813}[]{#02.htm_marker-1038814}[]{#02.htm_marker-1038815}might
not know the name of a particular image you want to run or use as a base
for your own image. Podman provides the command
`podman`{.fm-code-in-text}
`search`{.fm-code-in-text}[]{#02.htm_marker-1038817}, which allows you
to search container registries for matching names:

``` programlisting
$ podman search registry.access.redhat.com/httpd
INDEX     NAME                                                     
➥   DESCRIPTION                      redhat.com 
➥ registry.access.redhat.com/rhscl/httpd-24-rhel7
➥ Apache HTTP 2.4\ Server                                          
redhat.com  registry.access.redhat.com/ubi8/httpd-24\                
➥ Platform for running Apache httpd 2.4 or bui...                   
redhat.com  registry.access.redhat.com/rhscl/varnish-6-rhel7        Varnish\
➥ available as container is a base pla...
...
```

[]{#02.htm_pgfId-1038828}In this example, we are searching for images
that include the string *httpd* in their name on the repository
registry.access.redhat.com.

[]{#02.htm_pgfId-1038830}[]{#02.htm_id_3adi657j8luj}Some notable
`podman`{.fm-code-in-text} `search`{.fm-code-in-text} options include
the following:

- []{#02.htm_pgfId-1038831
  .calibre17}`--no-trunc`{.fm-code-in-text}---This tells Podman to show
  the full description of the image.

- []{#02.htm_pgfId-1038834
  .calibre17}`--format`{.fm-code-in-text}[]{#02.htm_marker-1038832
  .calibre17}[]{#02.htm_marker-1038833 .calibre17}---This allows you to
  customize which fields are displayed by Podman.

[]{#02.htm_pgfId-1038836}Use the `man`{.fm-code-in-text}
`podman-search`{.fm-code-in-text} command[]{#02.htm_marker-1038835} for
information about all options.

[]{#02.htm_pgfId-1038837}Up until now, you have seen several ways of
managing and manipulating container images, including inspecting,
pushing, pulling, and searching for them. But you have only been able to
look at the contents of an image by running it as a container. One way
to simplify the process is mounting a container
[]{#02.htm_marker-1038838}[]{#02.htm_marker-1038839}[]{#02.htm_marker-1038840}image.

### []{#02.htm_pgfId-1038842}2.2.10 Mounting images {#02.htm_heading_id_23 .fm-head1}

[]{#02.htm_pgfId-1038846}Often
[]{#02.htm_marker-1038843}[]{#02.htm_marker-1038844}[]{#02.htm_marker-1038845}you
might want to examine the contents of a container image, and one way to
do this is launching a shell inside a running container from the image.
The problem with this is that the tools you use to examine the container
image might not be available within the container. There is also a
security risk that the application in the container is malicious, making
use of this container undesirable.

[]{#02.htm_pgfId-1038848}To help with these problems, Podman provides
the `podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`mount`{.fm-code-in-text} command[]{#02.htm_marker-1038847} to mount an
image's root filesystem in a read-only mode without creating a container
from it. The mounted image becomes immediately available on the host
system, allowing you to examine its contents.

[]{#02.htm_pgfId-1038849}Now try mounting the image you pulled
previously:

``` programlisting
$ podman mount quay.io/rhatdan/myimage
Error: cannot run command "podman mount" in rootless mode, must execute `podman unshare` first
```

[]{#02.htm_pgfId-1038852}The reason for this error is that rootless mode
does not allow mounting images. You need to enter a user namespace and
separate mount namespace. Chapter 5 explains how most rootless Podman
commands enter the user namespace and mount namespace when they execute.
For now, it is enough to know that the `podman`{.fm-code-in-text}
`unshare`{.fm-code-in-text} command[]{#02.htm_marker-1038853} enters the
user and mount namespaces and will shut down when you execute the
`exit`{.fm-code-in-text} command[]{#02.htm_marker-1038854} of your
shell.

[]{#02.htm_pgfId-1038855}[Note]{.fm-callout-head} The name
`unshare`{.fm-code-in-text1} comes from the Linux syscall
`unshare`{.fm-code-in-text1} (`man`{.fm-code-in-text1}
`2`{.fm-code-in-text1} `unshare`{.fm-code-in-text1}). Linux also
includes an unshare tool (`man`{.fm-code-in-text1}
`1`{.fm-code-in-text1} `unshare`{.fm-code-in-text1}), which allows you
to create namespaces by hand. Another low-level tool called
`nsenter`{.fm-code-in-text1}[]{#02.htm_marker-1038856}, or namespace
enter (`man`{.fm-code-in-text1} `1`{.fm-code-in-text1}
`nsenter`{.fm-code-in-text1}), allows you to join processes to different
namespaces. Podman `unshare`{.fm-code-in-text1} uses the same kernel
features. It simplifies the process of creating and configuring
namespaces and inserting processes into the namespaces.

[]{#02.htm_pgfId-1038858}The `podman`{.fm-code-in-text}
`unshare`{.fm-code-in-text} command[]{#02.htm_marker-1038857} leaves you
at a `#`{.fm-code-in-text} prompt, where you can actually mount an
image:

``` programlisting
$ podman unshare
#
```

[]{#02.htm_pgfId-1038861}Mount the image, and save the location of the
mounted filesystem in an environment variable:

``` programlisting
# mnt=$(podman image mount quay.io/rhatdan/myimage)
```

[]{#02.htm_pgfId-1038863}Now you can actually examine the content of the
image. Let's print the contents of a file on the terminal:

``` programlisting
# cat $mnt/var/www/html/index.html 
<html>
 <head>
 </head>
 <body>
  <h1>Hello World</h1>
 </body>
</html>
```

[]{#02.htm_pgfId-1038872}When you are done, unmount the image, and exit
the unshare session:

``` programlisting
# podman image unmount quay.io/rhatdan/myimage
# exit
```

[]{#02.htm_pgfId-1038876}[Note]{.fm-callout-head} You have examined
about a half of the `podman`{.fm-code-in-text1}
`image`{.fm-code-in-text1} subcommands[]{#02.htm_marker-1038875},
arguably the most used ones. Refer to the Podman man pages for a full
explanation of these and other subcommands of the
`podman`{.fm-code-in-text1} `image`{.fm-code-in-text1} command:
`$`{.fm-code-in-text1} `man`{.fm-code-in-text1}
`podman-image`{.fm-code-in-text1}.

[]{#02.htm_pgfId-1038877}Now that you have a better understanding of
containers and images, the next important step is updating your image.
The main reasons for this are the need to update your application and
the availability of new versions for the base image you use. You can
build scripts to manually run the commands to build the image, but
luckily, Podman optimized
[]{#02.htm_marker-1038878}[]{#02.htm_marker-1038879}[]{#02.htm_marker-1038880}the
[]{#02.htm_marker-1038881}[]{#02.htm_marker-1038882}experience.

## []{#02.htm_pgfId-1038884}2.3 Building images {#02.htm_heading_id_24 .fm-head}

[]{#02.htm_pgfId-1038887}So
[]{#02.htm_marker-1038885}[]{#02.htm_marker-1038886}far you have been
working with images, which were already created and uploaded to a
container registry. The process of creating a container image is called
*building*.

[]{#02.htm_pgfId-1038888}When building container images, you manage not
only your application but also the image content used by this
application. In the days prior to containers, you shipped applications
as an RPM or DEB package, and then it was up to the distribution to make
sure the other parts of the OS were kept up to date and secure. But in
the container world, the container image includes the application along
with a subset of the OS. It is the developers' responsibility to keep
all of the image contents up to date and secure.

[]{#02.htm_pgfId-1038889}A coworker of mine, Scott McCarty
(smccarty@redhat.com, \@fatherlinux), has a saying, "Container images
don't age like wine but more like cheese. As the image gets older it
gets stinky."

[]{#02.htm_pgfId-1038890}This means that if the developer doesn't keep
up with the security updates, the number of vulnerabilities in the image
will grow at an alarming rate. Luckily for developers, Podman has a
special mechanism for helping you with image building for your
applications. The `podman`{.fm-code-in-text} `build`{.fm-code-in-text}
command[]{#02.htm_marker-1048537} uses the Buildah tool
([https://github.com/containers/buildah](https://github.com/containers/buildah){.url})
as a library to build container images; Buildah is covered in appendix
A.

[]{#02.htm_pgfId-1038892}The `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} uses a special text document called
Containerfile or Dockerfile to automate the building of container
images. This document lists commands used to build a container image.

[]{#02.htm_pgfId-1038893}[Note]{.fm-callout-head} The concept of a
Dockerfile and its syntax was originally created for the Docker tool,
developed by Docker, Inc. Podman defaults to using Containerfile for the
name, which uses the exact same syntax. Dockerfile is supported as well
for legacy purposes. The Docker build command does not support
Containerfile by default but can use the Containerfile. You can specify
the `-f`{.fm-code-in-text1} option: `#`{.fm-code-in-text1}
`docker`{.fm-code-in-text1} `build`{.fm-code-in-text1}
`-f`{.fm-code-in-text1} `Containerfile.`{.fm-code-in-text1}

### []{#02.htm_pgfId-1038895}2.3.1 Format of a Containerfile or Dockerfile {#02.htm_heading_id_25 .fm-head1}

[]{#02.htm_pgfId-1038900}Containerfiles
[]{#02.htm_marker-1038896}[]{#02.htm_marker-1038897}[]{#02.htm_marker-1038898}[]{#02.htm_marker-1038899}take
many directives. I break these down into two categories, adding content
to the container image and describing and documenting how to use the
image[]{#02.htm_id_ozq815u6tf54}.

[]{#02.htm_pgfId-1038902}Adding content to an image

[]{#02.htm_pgfId-1038906}Recall
[]{#02.htm_marker-1038903}[]{#02.htm_marker-1038904}[]{#02.htm_marker-1038905}back
in section 1.1.2 that I described a container image as a tdirectory on
disk that looks like root on a Linux system. This directory is called a
rootfs. Several of the directives in a container job are adding content
to this rootfs. This rootfs eventually contains all of the content used
to create your container image.

[]{#02.htm_pgfId-1038907}Every Containerfile must include a
`FROM`{.fm-code-in-text} line. The `FROM`{.fm-code-in-text} line
specifies the image that the new image is based off, often called a base
image. The `podman`{.fm-code-in-text} `build`{.fm-code-in-text}
command[]{#02.htm_marker-1038908} supports a special image named
`scratch`{.fm-code-in-text}[]{#02.htm_marker-1038909}, which means to
start your image with no content. When Podman sees the
`FROM`{.fm-code-in-text} `scratch`{.fm-code-in-text}
directive[]{#02.htm_marker-1038910}, it just allocates space in
containers/storage for an empty rootfs, then `COPY`{.fm-code-in-text}
can be used to populate the rootfs. More often, the
`FROM`{.fm-code-in-text} directive[]{#02.htm_marker-1038911} uses an
existing image. For example, `FROM`{.fm-code-in-text}
`registry.access.redhat.com/ubi8`{.fm-code-in-text} causes Podman to
pull the ubi8 image from the registry.access.redhat.com container
registry[]{#02.htm_marker-1038912} and copy it to container storage.
`podman`{.fm-code-in-text} `build`{.fm-code-in-text} pulls the same
image as the `podman`{.fm-code-in-text} `pull`{.fm-code-in-text}
command[]{#02.htm_marker-1038913} you learned about in section 2.2.8.
When the image is pulled, Podman uses container storage to mount the
image on the rootfs directory, using a copy on the write filesystem,
like OverlayFS, where the other directives can start to add content.
This image becomes the base layer of the rootfs.

[]{#02.htm_pgfId-1038914}The `COPY`{.fm-code-in-text} directive is often
used to copy files, directories, or tarballs off of the local host into
the newly created rootfs. The `RUN`{.fm-code-in-text}
directive[]{#02.htm_marker-1038915}[]{#02.htm_marker-1038916} is one of
the most commonly used Containerfile directives. `RUN`{.fm-code-in-text}
tells Podman to actually run a container on the image. Package
management tools, like DNF/YUM and `apt-get`{.fm-code-in-text}, are run
to install packages from distributions onto your new image. The
`RUN`{.fm-code-in-text} directive[]{#02.htm_marker-1038917} runs any
command within the container image as a container. The
`podman`{.fm-code-in-text} `build`{.fm-code-in-text}
command[]{#02.htm_marker-1038918} runs the commands with the same
security constraints as the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#02.htm_marker-1038919}.

[]{#02.htm_pgfId-1038921}As an example, imagine you want to add the
`ps`{.fm-code-in-text} command[]{#02.htm_marker-1038920} to a container
image; you can create a directive like the following. The
`RUN`{.fm-code-in-text} command executes a container, which updates all
of the packages from the base image, and then installs the
`procps-ns`{.fm-code-in-text} package, which includes the
`ps`{.fm-code-in-text} command[]{#02.htm_marker-1038922}. Finally the
containerized command[]{#02.htm_marker-1038923} executes
`yum`{.fm-code-in-text} to clean up after itself, so cruft is removed
from the container image:

``` programlisting
RUN yum -y update; yum -y install procps-ng; yum -y clean all
```

[]{#02.htm_pgfId-1038925}Adding content to the container image is only
half of what you need to do when creating a container image. You also
need to describe and document how the image will be used when other
users download and run your
[]{#02.htm_marker-1038926}[]{#02.htm_marker-1038927}[]{#02.htm_marker-1038928}image.

[]{#02.htm_pgfId-1038930}Documenting how to use the image

[]{#02.htm_pgfId-1038934}Recall that
[]{#02.htm_marker-1038931}[]{#02.htm_marker-1038932}[]{#02.htm_marker-1038933}back
in section 1.1.2, I also described the JSON file that included the image
specification. This specification describes how the container image is
to be run, the command, which user to run it with, and other
requirements of the image. The Containerfile also supports many
directives, which tells Podman how to run containers. These include the
following:

- []{#02.htm_pgfId-1038937 .calibre17}*The*
  `ENTRYPOINT`{.fm-code-in-text}[]{#02.htm_marker-1038935 .calibre17}
  *and* `CMD`{.fm-code-in-text} *directives*[]{#02.htm_marker-1038936
  .calibre17}---These instrument the image with the default command to
  be executed when users execute the image with Podman
  `run`{.fm-code-in-text}. `CMD`{.fm-code-in-text} is the actual command
  to run. `ENTRYPOINT`{.fm-code-in-text} can cause the entire image to
  execute as a single command.

- []{#02.htm_pgfId-1038938 .calibre17}*The* `ENV`{.fm-code-in-text}
  *directive*---This sets up the default environment variables to run
  when Podman runs a container on the image.

- []{#02.htm_pgfId-1038941 .calibre17}*The* `EXPOSE`{.fm-code-in-text}
  *directive*[]{#02.htm_marker-1038939
  .calibre17}[]{#02.htm_marker-1038940 .calibre17}---This records the
  network ports for Podman to expose in containers based on the image.
  If you execute `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
  `--publish-all`{.fm-code-in-text} `...`{.fm-code-in-text}, Podman
  looks inside of the image for the `EXPOSE`{.fm-code-in-text} network
  ports and connects them to the host.

[]{#02.htm_pgfId-1038942}Table 2.6 explains the directives used in a
Containerfile to add content to a container image.

[]{#02.htm_pgfId-1045581}Table 2.6 Containerfile directives that update
the image

+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045585}Directive examples          | []{#02.htm_pgfId-1045587}Explanation         |
+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045589}`FROM`{.fm-code-in-text1}   | []{#02.htm_pgfId-1045591}Sets the base image |
| `quay.io/rhatdan/myimage`{.fm-code-in-text1}         | for subsequent instructions. Containerfiles  |
|                                                      | must have `FROM`{.fm-code-in-text1} as their |
|                                                      | first instruction. The                       |
|                                                      | `FROM`{.fm-code-in-text1} may appear         |
|                                                      | multiple times within a single Containerfile |
|                                                      | to create multiple build stages.             |
+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045593}`ADD`{.fm-code-in-text1}    | []{#02.htm_pgfId-1045595}Copies new files,   |
| `start.sh`{.fm-code-in-text1}                        | directories, or remote file URLs to the      |
| `/usr/bin/start.sh`{.fm-code-in-text1}               | filesystem of the container at a specified   |
|                                                      | path.                                        |
+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045597}`COPY`{.fm-code-in-text1}   | []{#02.htm_pgfId-1045599}Copies files to the |
| `start.sh`{.fm-code-in-text1}                        | filesystem of the container at a specified   |
| `/usr/bin/start.sh`{.fm-code-in-text1}               | path.                                        |
+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045601}`RUN`{.fm-code-in-text1}    | []{#02.htm_pgfId-1045603}Executes commands   |
| `dnf`{.fm-code-in-text1} `-y`{.fm-code-in-text1}     | in a new layer on top of the current image   |
| `update`{.fm-code-in-text1}                          | and commits the results. The committed image |
|                                                      | is used for the next step in the             |
|                                                      | Containerfile.                               |
+------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045605}`VOLUME`{.fm-code-in-text1} | []{#02.htm_pgfId-1045607}Creates a mount     |
| `/var/lib/mydata`{.fm-code-in-text1}                 | point with the specified name and marks it   |
|                                                      | as holding externally mounted volumes from   |
|                                                      | the native host or from other containers.    |
|                                                      | For more on volumes, see chapter 3.          |
+------------------------------------------------------+----------------------------------------------+

[]{#02.htm_pgfId-1038972}Table 2.7 explains the directives used in a
Containerfile to populate the OCI Runtime Specifications with
information that tells container engines like Podman information about
the image and how to run the image. You can find much more information
on Containerfiles in the `containerfile(5)`{.fm-code-in-text} man
[]{#02.htm_marker-1038973}[]{#02.htm_marker-1038974}[]{#02.htm_marker-1038975}page.

[]{#02.htm_pgfId-1045699}Table 2.7 Containerfile directives that define
the OCI Runtime Specification

+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045703}Directive examples                                                              | []{#02.htm_pgfId-1045705}Explanation         |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045707}`CMD`{.fm-code-in-text1} `/usr/bin/start.sh`{.fm-code-in-text1}                 | []{#02.htm_pgfId-1045709}Specifies the       |
|                                                                                                          | default command to run when launching a      |
|                                                                                                          | container off this image. If                 |
|                                                                                                          | `CMD`{.fm-code-in-text1} is not specified,   |
|                                                                                                          | the parent image's `CMD`{.fm-code-in-text1}  |
|                                                                                                          | is inherited. Note that                      |
|                                                                                                          | `RUN`{.fm-code-in-text1} and                 |
|                                                                                                          | `CMD`{.fm-code-in-text1} are very different. |
|                                                                                                          | `RUN`{.fm-code-in-text1} runs the commands   |
|                                                                                                          | during the build process, while              |
|                                                                                                          | `CMD`{.fm-code-in-text1} is only used when a |
|                                                                                                          | user launches the image without specifying a |
|                                                                                                          | command.                                     |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045711}`ENTRYPOINT`{.fm-code-in-text1}                                                 | []{#02.htm_pgfId-1045713}Allows you to       |
| `“/bin/sh -c”`{.fm-code-in-text1}[]{#02.htm_marker-1045746}                                              | configure a container to run as an           |
|                                                                                                          | executable. The                              |
|                                                                                                          | `ENTRYPOINT`{.fm-code-in-text1} instruction  |
|                                                                                                          | is not overwritten when arguments are passed |
|                                                                                                          | to `podman run`{.fm-code-in-text1}. This     |
|                                                                                                          | allows arguments to be passed to the         |
|                                                                                                          | entrypoint---for instance,                   |
|                                                                                                          | `podman run <image> -d`{.fm-code-in-text1}   |
|                                                                                                          | passes the `-d`{.fm-code-in-text1} argument  |
|                                                                                                          | to the `ENTRYPOINT`{.fm-code-in-text1}.      |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045715}`ENV`{.fm-code-in-text1} `foo=”bar”`{.fm-code-in-text1}                         | []{#02.htm_pgfId-1045717}Adds an environment |
|                                                                                                          | variable to be used during both the image    |
|                                                                                                          | build and container execution.               |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045719}`EXPOSE`{.fm-code-in-text1} `8080`{.fm-code-in-text1}[]{#02.htm_marker-1045747} | []{#02.htm_pgfId-1045721}Announces the port  |
|                                                                                                          | that containerized applications will be      |
|                                                                                                          | exposing. This does not actually map or open |
|                                                                                                          | any ports.                                   |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045723}`LABEL Description=”Web browser which displays Hello World”`{.fm-code-in-text1} | []{#02.htm_pgfId-1045725}Adds metadata to an |
|                                                                                                          | image.                                       |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045727}`MAINTAINER Daniel Walsh`{.fm-code-in-text1}                                    | []{#02.htm_pgfId-1045729}Sets the            |
|                                                                                                          | `Author`{.fm-code-in-text1} field for the    |
|                                                                                                          | generated images.                            |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045731}`STOPSIGNAL SIGTERM`{.fm-code-in-text1}                                         | []{#02.htm_pgfId-1045733}Sets the default    |
|                                                                                                          | stop signal sent to the container to exit.   |
|                                                                                                          | The signal can be a valid unsigned number or |
|                                                                                                          | a signal name in the format                  |
|                                                                                                          | `SIGNAME`{.fm-code-in-text1}.                |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045735}`USER apache`{.fm-code-in-text1}                                                | []{#02.htm_pgfId-1045737}Sets the user name  |
|                                                                                                          | (or UID) and group name (or GID) to use for  |
|                                                                                                          | any `RUN`{.fm-code-in-text1},                |
|                                                                                                          | `CMD`{.fm-code-in-text1}, and                |
|                                                                                                          | `ENTRYPOINT`{.fm-code-in-text1} specified    |
|                                                                                                          | after it.                                    |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045739}`ONBUILD`{.fm-code-in-text1}[]{#02.htm_marker-1045748}                          | []{#02.htm_pgfId-1045741}Adds a trigger      |
|                                                                                                          | instruction to the image to be executed at a |
|                                                                                                          | later time, when the image is used as the    |
|                                                                                                          | base for another build.                      |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+
| []{#02.htm_pgfId-1045743}`WORKDIR`{.fm-code-in-text1} /var/www/html                                      | []{#02.htm_pgfId-1045745}Sets the working    |
|                                                                                                          | directory for `RUN`{.fm-code-in-text1},      |
|                                                                                                          | `CMD`{.fm-code-in-text1},                    |
|                                                                                                          | `ENTRYPOINT`{.fm-code-in-text1}, and         |
|                                                                                                          | `COPY`{.fm-code-in-text1} directives. A      |
|                                                                                                          | directory will be created if it doesn't      |
|                                                                                                          | exist.                                       |
+----------------------------------------------------------------------------------------------------------+----------------------------------------------+

[]{#02.htm_pgfId-1039029}Committing the image

[]{#02.htm_pgfId-1039034}When
[]{#02.htm_marker-1039030}[]{#02.htm_marker-1039031}[]{#02.htm_marker-1039032}[]{#02.htm_marker-1039033}`podman`{.fm-code-in-text}
`build`{.fm-code-in-text} finishes processing the Containerfile, it
commits the image, using the same code as `podman`{.fm-code-in-text}
`commit`{.fm-code-in-text} you learned about in section 2.1.9.
Basically, Podman TARs up all of the differences between the new content
in the rootfs and the base image, pulled down by the
`FROM`{.fm-code-in-text} directive[]{#02.htm_marker-1039035}. Podman
also commits the JSON file and saves this as an image in container
storage. Now you can take the steps used to build out containerized
applications and automate them using a Containerfile and Podman build.

[]{#02.htm_pgfId-1039037}[Tip]{.fm-callout-head} Use the
`--tag`{.fm-code-in-text1} option[]{#02.htm_marker-1039036} to name the
new image you are creating with `podman`{.fm-code-in-text1}
`build`{.fm-code-in-text1}. This tells Podman to add the specified tag
or name to the image in container storage in the same way as the
[]{#02.htm_marker-1039038}[]{#02.htm_marker-1039039}[]{#02.htm_marker-1039040}[]{#02.htm_marker-1039041}`podman`{.fm-code-in-text1}
`tag`{.fm-code-in-text1}
[]{#02.htm_marker-1039042}[]{#02.htm_marker-1039043}[]{#02.htm_marker-1039044}[]{#02.htm_marker-1039045}command[]{#02.htm_marker-1039046}.

### []{#02.htm_pgfId-1039048}2.3.2 Automating the building of our application {#02.htm_heading_id_26 .fm-head1}

[]{#02.htm_pgfId-1039052}First,
[]{#02.htm_marker-1039049}[]{#02.htm_marker-1039050}[]{#02.htm_marker-1039051}create
a directory to put your Containerfile and any other content for the
container image in. The directory is called a context directory:

``` programlisting
mkdir myapp
```

[]{#02.htm_pgfId-1039054}Next, create the index.html file you plan to
use in the containerized application in the `myapp`{.fm-code-in-text}
directory:

``` programlisting
$ cat > myapp/index.html << _EOF
<html>
 <head>
 </head>
 <body>
 <h1>Hello World</h1>
 </body>
</html>
_EOF
```

[]{#02.htm_pgfId-1039064}Next, create a simple Containerfile to build
your application in the `myapp`{.fm-code-in-text} directory. The first
line of the Containerfile is the `FROM`{.fm-code-in-text}
directive[]{#02.htm_marker-1039065} to pull the ubi8/httpd-24 image you
are treating as your base image. Then add a `COPY`{.fm-code-in-text}
command[]{#02.htm_marker-1039066} to copy the index.html file into the
image. The `COPY`{.fm-code-in-text} directive[]{#02.htm_marker-1039067}
tells Podman to copy the index.html file out of the context directory
(./myapp) and copy it to the /var/www/html/index.html file within the
image:

``` programlisting
$ cat > myapp/Containerfile << _EOF
FROM ubi8/httpd-24
COPY index.html /var/www/html/index.html
_EOF
```

[]{#02.htm_pgfId-1039072}Finally, use `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} to build your containerized application.
Specify the `--tag`{.fm-code-in-text} (`-t`{.fm-code-in-text}) to name
the image quay.io/rhatdan/myimage. You also need to specify the context
directory ./myapp:

``` programlisting
$ podman build -t quay.io/rhatdan/myimage ./myapp
STEP 1/2: FROM ubi8/httpd-24
STEP 2/2: COPY index.html /var/www/html/index.html
COMMIT quay.io/rhatdan/myimage
--> f81b8ace4f1
Successfully tagged quay.io/rhatdan/myimage:latest
F81b8ace4f134d08cedb20a9156ae727444ae4d4ec1ceb3b12d3aff23d18128b
```

[]{#02.htm_pgfId-1039081}When the `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} command[]{#02.htm_marker-1039080} completes,
it commits the image and tags (`-t`{.fm-code-in-text}) it with the
quay.io/rhatdan/myimage name. It is now ready to be pushed to the
container registry using the `podman`{.fm-code-in-text}
`push`{.fm-code-in-text} command[]{#02.htm_marker-1039082}.

[]{#02.htm_pgfId-1039083}Now you can set up a CI/CD system or even a
simple cron job to regularly build and replace
`myapplication`{.fm-code-in-text}:

``` programlisting
$ cat > myapp/automate.sh << _EOF
#!/bin/bash
podman build -t quay.io/rhatdan/myimage ./myapp
podman push quay.io/rhatdan/myimage
_EOF
$ chmod +x myapp/automate.sh
```

[]{#02.htm_pgfId-1039090}Add some test scripts as well to make sure your
application works the way it was designed before replacing the previous
version. Let's take a look at the images that were built:

``` programlisting
$ podman images
REPOSITORY                         TAG        IMAGE ID        CREATED    SIZE
quay.io/rhatdan/myimage         latest    f81b8ace4f13  2 minutes ago  462 MB
<none>                          <none>    2c7e43d88038     2 days ago  462 MB
registry.access.redhat
➥.com/ubi8/httpd-24            latest    8594be0a0b57    5 weeks ago  462 MB
```

[]{#02.htm_pgfId-1039099}Notice the old version of
quay.io/rhatdan/myimage, image ID `2c7e43d88038`{.fm-code-in-text},
still exists in container storage but now has a
`REPOSITORY`{.fm-code-in-text} and `TAG`{.fm-code-in-text} of
`<none>`{.fm-code-in-text} `<none>`{.fm-code-in-text}. Images like these
are called dangling images. Since I have created a new version of
quay.io/rhatdan/myimage with the `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} command[]{#02.htm_marker-1039100}, the
previous image loses that name. You can still use the Podman commands
with the image ID, or if the new image doesn't work, simply use
`podman`{.fm-code-in-text} `tag`{.fm-code-in-text} to rename the old
image back to quay.io/ rhatdan/myimage. If the new image works
correctly, you can remove the old image with `podman`{.fm-code-in-text}
`rmi`{.fm-code-in-text}. These `<none><none>`{.fm-code-in-text} images
tend to build up over time, wasting space, but you can periodically use
the `podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`prune`{.fm-code-in-text} command[]{#02.htm_marker-1039101} to remove
them.

[]{#02.htm_pgfId-1039102}The `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} could really use a chapter or even a book to
itself. People build images in thousands of different ways using the
commands briefly described here.

[]{#02.htm_pgfId-1039104}`--tag`{.fm-code-in-text}[]{#02.htm_id_t7sehvoh2hfl1111}
is a notable `podman`{.fm-code-in-text} `build`{.fm-code-in-text} option
that specifies the image tag or name for the image. Remember that you
can always add additional names after you create the image with the
`podman`{.fm-code-in-text} `tag`{.fm-code-in-text}
command[]{#02.htm_marker-1039105} you used in section 2.2.6. Use the
`man`{.fm-code-in-text} `podman-build`{.fm-code-in-text}
command[]{#02.htm_marker-1039106} for information about all
[]{#02.htm_marker-1039107}[]{#02.htm_marker-1039108}[]{#02.htm_marker-1039109}options
[]{#02.htm_marker-1039110}[]{#02.htm_marker-1039111}(see table 2.8).

[]{#02.htm_pgfId-1045944}Table 2.8 Podman image commands

+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045950}Command                                               | []{#02.htm_pgfId-1045952}Man page                                     | []{#02.htm_pgfId-1045954}Description |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045956}`build`{.fm-code-in-text1}[]{#02.htm_marker-1046087}  | []{#02.htm_pgfId-1045958}`podman-image-build(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1045960}Builds an   |
|                                                                                |                                                                       | image using instructions from        |
|                                                                                |                                                                       | Containerfiles                       |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045962}`diff`{.fm-code-in-text1}[]{#02.htm_marker-1046088}   | []{#02.htm_pgfId-1045964}`podman-image-diff(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1045966}Inspects    |
|                                                                                |                                                                       | changes in image's filesystem        |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045968}`exists`{.fm-code-in-text1}                           | []{#02.htm_pgfId-1045970}`podman-image-exists(1)`{.fm-code-in-text1}  | []{#02.htm_pgfId-1045972}Checks      |
|                                                                                |                                                                       | whether an image                     |
|                                                                                |                                                                       | exists[]{#02.htm_marker-1046089}     |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045974}`history`{.fm-code-in-text1}                          | []{#02.htm_pgfId-1045976}`podman-image-history(1)`{.fm-code-in-text1} | []{#02.htm_pgfId-1045978}Shows a     |
|                                                                                |                                                                       | history[]{#02.htm_marker-1046090} of |
|                                                                                |                                                                       | a specified image                    |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045980}`import`{.fm-code-in-text1}[]{#02.htm_marker-1046091} | []{#02.htm_pgfId-1045982}`podman-image-import(1)`{.fm-code-in-text1}  | []{#02.htm_pgfId-1045984}Imports a   |
|                                                                                |                                                                       | tarball to create a filesystem image |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045986}`inspect`{.fm-code-in-text1}                          | []{#02.htm_pgfId-1045988}`podman-image-inspect(1)`{.fm-code-in-text1} | []{#02.htm_pgfId-1045990}Displays    |
|                                                                                |                                                                       | the configuration of an image        |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045992}`list`{.fm-code-in-text1}[]{#02.htm_marker-1046092}   | []{#02.htm_pgfId-1045994}`podman-image-list(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1045996}Lists all   |
|                                                                                |                                                                       | of the images                        |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1045998}`load`{.fm-code-in-text1}[]{#02.htm_marker-1046093}   | []{#02.htm_pgfId-1046000}`podman-image-load(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046002}Loads       |
|                                                                                |                                                                       | image(s) from a tarball              |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046004}`mount`{.fm-code-in-text1}[]{#02.htm_marker-1046094}  | []{#02.htm_pgfId-1046006}`podman-image-mount(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1046008}Mounts an   |
|                                                                                |                                                                       | image's root filesystem              |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046010}`prune`{.fm-code-in-text1}[]{#02.htm_marker-1046095}  | []{#02.htm_pgfId-1046012}`podman-image-prune(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1046014}Removes     |
|                                                                                |                                                                       | unused images                        |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046016}`pull`{.fm-code-in-text1}                             | []{#02.htm_pgfId-1046018}`podman-image-pull(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046020}Pulls an    |
|                                                                                |                                                                       | image from a registry                |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046022}`push`{.fm-code-in-text1}                             | []{#02.htm_pgfId-1046024}`podman-image-push(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046026}Pushes an   |
|                                                                                |                                                                       | image to a registry                  |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046028}`rm`{.fm-code-in-text1}                               | []{#02.htm_pgfId-1046030}`podman-image-rm(1)`{.fm-code-in-text1}      | []{#02.htm_pgfId-1046032}Removes an  |
|                                                                                |                                                                       | image                                |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046034}`save`{.fm-code-in-text1}                             | []{#02.htm_pgfId-1046036}`podman-image-save(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046038}Saves       |
|                                                                                |                                                                       | image(s) to an archive               |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046040}`scp`{.fm-code-in-text1}                              | []{#02.htm_pgfId-1046042}`podman-image-scp(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1046044}Securely    |
|                                                                                |                                                                       | copies images to other               |
|                                                                                |                                                                       | containers/storage                   |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046046}`search`{.fm-code-in-text1}                           | []{#02.htm_pgfId-1046048}`podman-image-search(1)`{.fm-code-in-text1}  | []{#02.htm_pgfId-1046050}Searches    |
|                                                                                |                                                                       | the registry for an image            |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046052}`sign`{.fm-code-in-text1}                             | []{#02.htm_pgfId-1046054}`podman-image-sign(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046056}Signs an    |
|                                                                                |                                                                       | image                                |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046058}`tag`{.fm-code-in-text1}                              | []{#02.htm_pgfId-1046060}`podman-image-tag(1)`{.fm-code-in-text1}     | []{#02.htm_pgfId-1046062}Adds an     |
|                                                                                |                                                                       | additional name to a local image     |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046064}`tree`{.fm-code-in-text1}                             | []{#02.htm_pgfId-1046066}`podman-image-tree(1)`{.fm-code-in-text1}    | []{#02.htm_pgfId-1046068}Prints the  |
|                                                                                |                                                                       | layer hierarchy of an image in a     |
|                                                                                |                                                                       | tree format                          |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046070}`trust`{.fm-code-in-text1}                            | []{#02.htm_pgfId-1046072}`podman-image-trust(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1046074}Manages     |
|                                                                                |                                                                       | container image trust policy         |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046076}`unmount`{.fm-code-in-text1}                          | []{#02.htm_pgfId-1046078}`podman-image-unmount(1)`{.fm-code-in-text1} | []{#02.htm_pgfId-1046080}Unmounts an |
|                                                                                |                                                                       | image's root filesystem              |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+
| []{#02.htm_pgfId-1046082}`untag`{.fm-code-in-text1}                            | []{#02.htm_pgfId-1046084}`podman-image-untag(1)`{.fm-code-in-text1}   | []{#02.htm_pgfId-1046086}Removes a   |
|                                                                                |                                                                       | name from a local image              |
+--------------------------------------------------------------------------------+-----------------------------------------------------------------------+--------------------------------------+

## []{#02.htm_pgfId-1039265}Summary {#02.htm_heading_id_27 .fm-head}

- []{#02.htm_pgfId-1039266 .calibre17}Podman's simple command-line
  interface makes working with containers easy.

- []{#02.htm_pgfId-1039269 .calibre17}Podman `run`{.fm-code-in-text},
  `stop`{.fm-code-in-text}, `start`{.fm-code-in-text},
  `ps`{.fm-code-in-text},
  `inspect`{.fm-code-in-text}[]{#02.htm_marker-1039267 .calibre17},
  `rm`{.fm-code-in-text}[]{#02.htm_marker-1039268 .calibre17}, and
  `commit`{.fm-code-in-text} are all commands for working with
  containers.

- []{#02.htm_pgfId-1039271 .calibre17}Podman
  `pull`{.fm-code-in-text}[]{#02.htm_marker-1039270 .calibre17},
  `push`{.fm-code-in-text}, `login`{.fm-code-in-text}, and
  `rmi`{.fm-code-in-text} are tools for working with images and sharing
  them via container registries.

- []{#02.htm_pgfId-1039272 .calibre17}Podman `build`{.fm-code-in-text}
  is a great command for automating the build of container images.

- []{#02.htm_pgfId-1039273 .calibre17}Podman's command line is based on
  the Docker CLI and supports it exactly, allowing us to tell people to
  just alias Docker = Podman.

- []{#02.htm_pgfId-1039284 .calibre17}Podman has additional commands and
  options to support more advanced concepts
  like[]{#02.htm_marker-1039274 .calibre17}[]{#02.htm_marker-1039275
  .calibre17}[]{#02.htm_marker-1039276
  .calibre17}[]{#02.htm_marker-1039277
  .calibre17}[]{#02.htm_marker-1039278
  .calibre17}[]{#02.htm_marker-1039279
  .calibre17}[]{#02.htm_marker-1039280
  .calibre17}[]{#02.htm_marker-1039281
  .calibre17}[]{#02.htm_marker-1039282 .calibre17}
  []{#02.htm_marker-1039283 .calibre17}`podman`{.fm-code-in-text}
  `image`{.fm-code-in-text} `mount`{.fm-code-in-text}.

[]{#03.htm}

# []{#03.htm_pgfId-1048578}[]{#03.htm_id_sira8yl9f04n}[]{#03.htm_pgfId-1048580}3 Volumes {#03.htm_heading_id_2 .tochead}

[]{#03.htm_pgfId-1048583}This chapter []{#03.htm_marker-1051546}covers

- []{#03.htm_pgfId-1048584 .calibre17}Using volumes to isolate data from
  the containerized application
- []{#03.htm_pgfId-1048585 .calibre17}Sharing content from your host
  into containers via volumes
- []{#03.htm_pgfId-1048587 .calibre17}Using volumes with the user
  namespace and []{#03.htm_id_Hlk114568025 .calibre17}SELinux
- []{#03.htm_pgfId-1048588 .calibre17}Embedding volumes into container
  images
- []{#03.htm_pgfId-1048590 .calibre17}Exploring different types of
  volumes and the []{#03.htm_id_Hlk114568236 .calibre17}volume commands

[]{#03.htm_pgfId-1048591}Up until now, the containers you have been
working with include all their content within the container image. As I
described in chapter 1, the only thing required to be shared with
traditional containers is the Linux kernel. There are several reasons
you need to isolate application data from the application, including the
following:

- []{#03.htm_pgfId-1048592 .calibre17}Avoiding embedding actual data for
  applications such as databases.

- []{#03.htm_pgfId-1048593 .calibre17}Using the same container image to
  run multiple environments.

- []{#03.htm_pgfId-1048594 .calibre17}Reducing overhead and improving
  storage read/write performance, since volumes write directly to the
  filesystem, while containers use the overlay or
  []{#03.htm_id_Hlk114568472 .calibre17}fuse-overlayfs filesystem to
  mount their layers. *Overlay* is a layered filesystem, meaning the
  kernel needs to copy the previous layer entirely to create a new
  layer, and fuse-overlayfs switches each read and write from kernel
  space to user space and back. All of this creates quite an overhead.

- []{#03.htm_pgfId-1048596 .calibre17}Sharing content available via
  network storage.

[]{#03.htm_pgfId-1048597}[Note]{.fm-callout-head}
`bind`{.fm-code-in-text1} mounts remount parts of the file hierarchy in
a different location on the filesystem. The files and directories in the
`bind`{.fm-code-in-text1} mount are the same as the original (see the
`mount`{.fm-code-in-text1} command[]{#03.htm_marker-1048598} man page
for an explanation of `bind`{.fm-code-in-text1} mounts). A
`bind`{.fm-code-in-text1} mount allows the same content to be accessible
in two places, without any additional overhead. It is important to
understand that `bind`{.fm-code-in-text1} does not copy the data or
create new data.

[]{#03.htm_pgfId-1048599}Supporting volumes also adds complexity,
especially concerning security. A lot of the security features of
containers prevent the container processes from gaining access to the
filesystem outside the container image. In this chapter, you will
discover the ways Podman allows you to work around these obstacles.

## []{#03.htm_pgfId-1048601}3.1 Using volumes with containers {#03.htm_heading_id_3 .fm-head}

[]{#03.htm_pgfId-1048603}Let's []{#03.htm_marker-1048602}go back to your
containerized application. Up until now, you have simply embedded the
web application data into your container filesystem directly. Recall
that in section 2.1.8, you used the `podman`{.fm-code-in-text}
`exec`{.fm-code-in-text} command[]{#03.htm_marker-1048604} to modify the
Hello World index.html data within the container:

``` programlisting
$ podman exec -i myapp bash -c 'cat > /var/www/html/index.html' << _EOF
<html>
 <head>
 </head>
 <body>
 <h1>Hello World</h1>
 </body>
</html>
_EOF 
```

[]{#03.htm_pgfId-1048614}You have made the containerized image more
flexible by allowing users to supply their own content for the web
service or perhaps to update the web service on the fly. At the same
time, while this method is possible, it is error prone and not scalable;
it is where volumes come in handy.

[]{#03.htm_pgfId-1048616}Podman allows you to mount host filesystem
content into containers using the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#03.htm_marker-1048615} via the
`--volume`{.fm-code-in-text} `(-v)`{.fm-code-in-text}
option[]{#03.htm_marker-1048617}.

[]{#03.htm_pgfId-1048619}The `--volume`{.fm-code-in-text}
`HOST-DIR:CONTAINER-DIR`{.fm-code-in-text}
option[]{#03.htm_marker-1048618} tells Podman to
`bind`{.fm-code-in-text} mount `HOST-DIR`{.fm-code-in-text} in the host
to `CONTAINER-DIR`{.fm-code-in-text} in the container. Podman supports
other kinds of volumes as well, but in this section, I will focus on
`bind`{.fm-code-in-text} mount volumes.

[]{#03.htm_pgfId-1048620}It is possible to mount both files or
directories in a single option. Changes of the content on the host will
be seen inside the container. Similarly, if container processes change
the content inside the container, the changes will be seen on the host.

[]{#03.htm_marker-1051591}[]{#03.htm_pgfId-1048621}Let's look at an
example. Create a directory, html, in your home directory, and then
create a new html/index.html file in it:

``` programlisting
$ mkdir html
$ cat > html/index.html << _EOF
<html>
 <head>
 </head>
 <body>
 <h1>Goodbye World</h1>
 </body>
</html>
_EOF
```

[]{#03.htm_pgfId-1048632}Now launch a container with the option
`-v`{.fm-code-in-text} `./html:/var/www/html`{.fm-code-in-text}:

``` programlisting
$ podman run -d -v ./html:/var/www/html:ro,z -p 8080:8080
     quay.io/rhatdan/myimage
94c21a3d8fda740857abc571469aaaa181f4db27a464ceb6743c4a37fb875772
```

[]{#03.htm_pgfId-1048637}Notice the extra `:ro,z`{.fm-code-in-text}
fields in the `--volume`{.fm-code-in-text}
option[]{#03.htm_marker-1048635}. The `ro`{.fm-code-in-text}
option[]{#03.htm_marker-1048636} tells Podman to mount the volume in
read-only mode. The read-only mount means processes within the container
cannot modify any content under /var/www/html, while processes on the
host are still able to modify the content. Podman defaults all volume
mounts to read/write mode. The `z`{.fm-code-in-text} option tells Podman
to relabel the content to a shared label for use by SELinux (see section
3.1.2).

[]{#03.htm_pgfId-1048638}Now that you have launched the container, open
a web browser, and navigate to localhost:8080 to make sure the changes
have taken place (see figure 3.1).

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/03-01.png){.calibre18}

[]{#03.htm_pgfId-1054147}Figure 3.1 Web browser window connecting to the
`myimage`{.fm-code-in-text} Podman container[]{#03.htm_marker-1054148}
with volume mounted L
:::

[]{#03.htm_pgfId-1048647}Now you can shut down and remove the container
you just created. Removing the container does not affect the content at
all. The following command removes the latest
(`--latest`{.fm-code-in-text}) container, yours. The
`--force`{.fm-code-in-text} option[]{#03.htm_marker-1048648} tells
Podman to stop the container and then remove it:

``` programlisting
$ podman rm --latest --force
```

[]{#03.htm_pgfId-1048650}Finally, remove the content with this command:

``` programlisting
$ rm -rf html
```

[]{#03.htm_pgfId-1048653}[Note]{.fm-callout-head} The
`--latest`{.fm-code-in-text1} option[]{#03.htm_marker-1048652} is not
available on Mac and Windows. You must specify the container name or ID.
Remote mode is explained in chapter 9, and Podman on Mac and Windows is
explained in appendixes E and F.

### []{#03.htm_pgfId-1048655}3.1.1 Named volumes {#03.htm_heading_id_4 .fm-head1}

[]{#03.htm_pgfId-1048659}In
[]{#03.htm_marker-1048656}[]{#03.htm_marker-1048657}[]{#03.htm_marker-1048658}the
first volume example, you created a directory on disk and then mounted
it into the container. Similarly, you can take any existing file or
directory and mount it into a container, as long as you have read access
to it.

[]{#03.htm_pgfId-1048660}Another mechanism for persisting Podman
containers data is named `volume`{.fm-code-in-text}. You can create one
of these with the `podman`{.fm-code-in-text} `volume`{.fm-code-in-text}
`create`{.fm-code-in-text} command[]{#03.htm_marker-1048661}. In the
following example you will create a `volume`{.fm-code-in-text} named
`webdata`{.fm-code-in-text}[]{#03.htm_marker-1048662}:

``` programlisting
$ podman volume create webdata
webdata
```

[]{#03.htm_pgfId-1048665}Podman defaults to creating local-named
volumes, with storage allocated in the container storage directories.
You can inspect the volume and look for its mount point using the
following command:

``` programlisting
$ podman volume inspect webdata
[
  {
      "Name": "webdata",
      "Driver": "local",
      "Mountpoint":
➥ "/home/dwalsh/.local/share/containers/storage/volumes/webdata/_data",
      "CreatedAt": "2021-10-11T14:10:48.741367132-04:00",
      "Labels": {},
      "Scope": "local",
      "Options": {}
  }
]
```

[]{#03.htm_pgfId-1048679}Podman actually creates a directory in your
local container storage, /home/dwalsh/
.local/share/containers/storage/volumes/webdata/\_data, to store the
content of the volume. You can create content from the host in this
directory:

``` programlisting
$ cat > /home/dwalsh/.local/share/containers/storage/volumes/webdata/_
data/index.html << _EOL
<html>
 <head>
 </head>
 <body>
 <h1>Goodbye World</h1>
 </body>
</html>
_EOL
```

[]{#03.htm_marker-1051690}[]{#03.htm_pgfId-1048690}Now you can run the
`myimage`{.fm-code-in-text} application[]{#03.htm_marker-1048689} using
this volume:

``` programlisting
$ podman run -d -v webdata :/var/www/html:ro,z -p 8080:8080 quay.io/rhatdan/myimage
0c8eb612831f8fe22438d73d801e5bb664ec3b1d524c5c10759ee0049061cb6b
```

[]{#03.htm_pgfId-1048693}Now refresh the web browser to ensure the file
created in the host directory is displaying "Goodbye World" (see figure
3.2).

::: figure
![](images/03-02.png){.calibre18}

[]{#03.htm_pgfId-1054186}Figure 3.2 Web browser window connecting to the
`myimage`{.fm-code-in-text} Podman container[]{#03.htm_marker-1054187}
with the named volume mounted
:::

[]{#03.htm_pgfId-1048701}Named volumes can be used for more than one
container at a time, and they will stay around even after the container
is removed. If you are done with the named volume and container, you can
first stop the container without waiting for the processes to finish:

``` programlisting
$ podman stop -t 0 0c8eb61283
```

[]{#03.htm_pgfId-1048705}Then remove the volume with the
`podman`{.fm-code-in-text} `volume`{.fm-code-in-text}
`rm`{.fm-code-in-text} command[]{#03.htm_marker-1048703}. Note the
`--force`{.fm-code-in-text} option[]{#03.htm_marker-1048704}, which
tells Podman to remove the volume and all containers that rely on the
volume:

``` programlisting
$ podman volume rm --force webdata 
```

[]{#03.htm_pgfId-1048708}Now you can make sure the volume is gone by
executing the `volume`{.fm-code-in-text} `list`{.fm-code-in-text}
command[]{#03.htm_marker-1048707}:

``` programlisting
$ podman volume list
```

[]{#03.htm_pgfId-1048711}If a named volume doesn\'t exist prior to
executing the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
command[]{#03.htm_marker-1048710}, it will be created automatically. In
the following example, you will specify `webdata1`{.fm-code-in-text} for
the name of the named volume, then list the volumes:

``` programlisting
$ podman run -d -v webdata1:/var/www/html:ro,z -p 8080:8080\ 
➥ quay.io/rhatdan/myimage
58ccaf37958496322e34cd933cd4dd5a61ab06c5ba678beb28fdc29cfb81f407
  
$ podman volume list
DRIVER   VOLUME NAME
local     webdata1
```

[]{#03.htm_pgfId-1048719}Of course, this volume is empty. Remove the
`webdata1`{.fm-code-in-text} volume and container:

``` programlisting
$ podman volume rm --force webdata1 
```

[]{#03.htm_pgfId-1048721}Podman also supports other types of volumes. It
uses the concept of volume plugins so third parties can provide volumes;
see the `podman-volume-create`{.fm-code-in-text} man
pages[]{#03.htm_marker-1048722} for more information.

[]{#03.htm_pgfId-1048724}Podman has other interesting volume features.
The `podman`{.fm-code-in-text} `volume`{.fm-code-in-text}
`export`{.fm-code-in-text} command[]{#03.htm_marker-1048723} exports all
the content of a volume into an external TAR archive. This archive can
be copied to other machines used to recreate the volume on another
machine with the `podman`{.fm-code-in-text} `volume`{.fm-code-in-text}
`import`{.fm-code-in-text} command[]{#03.htm_marker-1048725}. Now that
you understand the handling of volumes, it is time to dig deeper into
volume
[]{#03.htm_marker-1048726}[]{#03.htm_marker-1048727}[]{#03.htm_marker-1048728}options.

### []{#03.htm_pgfId-1048730}3.1.2 Volume mount options {#03.htm_heading_id_5 .fm-head1}

[]{#03.htm_pgfId-1048735}You
[]{#03.htm_marker-1048731}[]{#03.htm_marker-1048732}[]{#03.htm_marker-1048733}have
been using volume mount options throughout this chapter. The
`ro`{.fm-code-in-text} option[]{#03.htm_marker-1048734} tells Podman to
mount the read-only volume, and the lowercase `z`{.fm-code-in-text}
option[]{#03.htm_marker-1048736} tells Podman to relabel the content
with SELinux labels that will allow multiple containers to read and
write in the volume:

``` programlisting
$ podman run -d -v ./html:/var/www/html:ro,z -p 8080:8080 quay.io/rhatdan/myimage
```

[]{#03.htm_pgfId-1048738}Podman supports some other interesting volume
options.

[]{#03.htm_pgfId-1048740}The U volume option

[]{#03.htm_pgfId-1048744}Sometimes
[]{#03.htm_marker-1048741}[]{#03.htm_marker-1048742}[]{#03.htm_marker-1048743}when
you run a rootless container, you need a volume to be owned by the user
of the container. Imagine your application needs to allow the
[]{#03.htm_id_Hlk114570711}web server to write to the volume. In your
container, the Apache Web Server process (`httpd`{.fm-code-in-text}) is
run as the `apache`{.fm-code-in-text} (`UID==60`{.fm-code-in-text})
user. The html directory in your home directory is owned by your UID,
meaning it is owned by root inside the container. The kernel does not
allow a process running as `UID==60`{.fm-code-in-text} inside the
container to make changes to a directory owned by root. You must set the
ownership of the volume to `UID==60`{.fm-code-in-text}.

[]{#03.htm_pgfId-1048746}In rootless containers, the UIDs of the
container are offset by the user namespace. My user namespace mapping
looks like this:

``` programlisting
$ podman unshare cat /proc/self/uid_map
       0     3267      1
       1   100000    65536
```

[]{#03.htm_pgfId-1048750}The `UID==0`{.fm-code-in-text} inside the
container is my `UID`{.fm-code-in-text} `3267`{.fm-code-in-text}, and
`UID`{.fm-code-in-text} `1==100000`{.fm-code-in-text},
`UID`{.fm-code-in-text} `2==10000`{.fm-code-in-text} \...
`UID60==100059`{.fm-code-in-text}, meaning I need to set the ownership
of the html directory to `100059`{.fm-code-in-text}.

[]{#03.htm_pgfId-1048752}I can do this fairly simply, using the
`podman`{.fm-code-in-text} `unshare`{.fm-code-in-text}
command[]{#03.htm_marker-1048751}, as follows:

``` programlisting
$ podman unshare chown 60:60 ./html
```

[]{#03.htm_pgfId-1048754}Now everything works. One problem with this is
that I need to do some mental gymnastics to figure out which UID the
container will run with.

[]{#03.htm_pgfId-1048756}Many container images exist with the default
UID defined in them. The `mariadb`{.fm-code-in-text}
image[]{#03.htm_marker-1048755} is another example of this; it runs with
the `mysql`{.fm-code-in-text} user, `UID=999`{.fm-code-in-text}:

``` programlisting
$ podman run docker.io/mariadb grep mysql /etc/passwd
mysql:x:999:999::/home/mysql:/bin/sh
```

[]{#03.htm_pgfId-1048759}If you created a volume to be used for the
database, you need to figure out what `UID=999`{.fm-code-in-text} mapped
to within the user namespace. On my system this is
`UID=100998`{.fm-code-in-text}.

[]{#03.htm_pgfId-1048760}Podman supplies the `U`{.fm-code-in-text}
command option for this exact situation. The `U`{.fm-code-in-text}
option tells Podman to recursively change ownership
(`chown`{.fm-code-in-text}) the source volume to match the default UID
the container executes with.

[]{#03.htm_pgfId-1048761}Try it out by first creating the directory for
the database. Notice the directory in the home directory is owned by
your user:

``` programlisting
$ mkdir mariadb
$ ls -ld mariadb/
drwxrwxr-x. 1 dwalsh dwalsh 0 Oct 23 06:55 mariadb/
```

[]{#03.htm_pgfId-1048766}Now run the `mariadb`{.fm-code-in-text}
container[]{#03.htm_marker-1048765} with the `--user`{.fm-code-in-text}
`mysql`{.fm-code-in-text}, and `bind`{.fm-code-in-text} mount the
./mariadb directory to /var/lib/mariadb with the `:U`{.fm-code-in-text}
option. Notice that the directory is now owned by the
`mysql`{.fm-code-in-text} user[]{#03.htm_marker-1048767}:

``` programlisting
$ podman run --user mysql -v ./mariadb:/var/lib/mariadb:U \
➥ docker.io/mariadb ls -ld /var/lib/mariadb
drwxrwxr-x. 1 mysql mysql 0 Oct 23 10:55 /var/lib/mariadb
```

[]{#03.htm_pgfId-1048770}If you look at the mariadb directory on the
host again, you will see that it is now owned by `UID`{.fm-code-in-text}
`100998`{.fm-code-in-text} or whatever `UID`{.fm-code-in-text}
`999`{.fm-code-in-text} maps to within your user namespace:

``` programlisting
$ ls -ld mariadb/
drwxrwxr-x. 1 100998 100998 0 Oct 23 06:55 mariadb/
```

[]{#03.htm_pgfId-1048773}User namespace is not the only security
mechanism you need to work around with rootless containers. SELinux,
while great for container security, can cause some problems when working
with
[]{#03.htm_marker-1048774}[]{#03.htm_marker-1048775}[]{#03.htm_marker-1048776}volumes.

[]{#03.htm_pgfId-1048778}The SELinux volume options

[]{#03.htm_pgfId-1048782}In
[]{#03.htm_marker-1048779}[]{#03.htm_marker-1048780}[]{#03.htm_marker-1048781}my
opinion, SELinux is the best mechanism for protecting the filesystem
from hostile container processes. Over the years, several container
escapes have been thwarted by SELinux (see section 10.8 for more
information on SELinux).

[]{#03.htm_pgfId-1048783}As I explained previously, volumes leak files
from the OS into the container, and from an SELinux point of view, these
files and directories must be labeled correctly, or the kernel will
block access.

[]{#03.htm_pgfId-1048785}The lowercase `z`{.fm-code-in-text} command
option[]{#03.htm_marker-1048784} you have been using in this chapter
tells Podman to recursively relabel all content in the source directory
with a label that can be read and written by all containers from an
SELinux point of view. If the volume will not be used by more than one
container, relabeling with the lowercase `z`{.fm-code-in-text} option
isn't what you want. If a different hostile container escapes
confinement, it might be able to access this data and read/write it.
Podman provides an uppercase `Z`{.fm-code-in-text} option that tells
Podman to recursively relabel the content in such a way that only the
processes within the container can read/write the content.

[]{#03.htm_pgfId-1048786}In both previous cases, you relabeled the
content of the directory. Relabeling works great if the directory is
specified for use by containers. Sometimes you may want to use a
container to examine content in a system-specific directory---for
example, if you want to run a container that examines all the logs in
/var/log or examines all your home directories (/home/dwalsh).

[]{#03.htm_pgfId-1048787}[Note]{.fm-callout-head} Using this option on a
home directory can have disastrous effects on the system because it
recursively relabels all content in the directory as if the data was
private to a container. Other confined domains would be prevented from
using the mislabeled data.

[]{#03.htm_pgfId-1048788}For these cases, you need to disable SELinux
enforcement for container separation to allow the containers to use the
volume. Podman provides the command option
`--security-opt`{.fm-code-in-text}
`label=disable`{.fm-code-in-text}[]{#03.htm_marker-1048789} to disable
SELinux support for a single container, basically running the container
with an *unconfined* label[]{#03.htm_marker-1048790} from an SELinux
perspective:

``` programlisting
$ podman run --security-opt label=disable -v /home/dwalsh:/home/dwalsh -p\ 
➥ 8080:8080 quay.io/rhatdan/myimage
```

[]{#03.htm_pgfId-1052208}Table 3.1 lists and describes all of the mount
[]{#03.htm_marker-1053206}[]{#03.htm_marker-1053207}[]{#03.htm_marker-1053208}options
[]{#03.htm_marker-1053223}[]{#03.htm_marker-1053224}[]{#03.htm_marker-1053225}available
[]{#03.htm_marker-1053240}in []{#03.htm_marker-1053255}Podman.

[]{#03.htm_pgfId-1053090}Table 3.1 Volume mount options

+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053094}Volume option                   | []{#03.htm_pgfId-1053096}Description                            |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053098}`nodev`{.fm-code-in-text1}      | []{#03.htm_pgfId-1053100}Prevent container processes from using |
|                                                          | character or block devices on the volume.                       |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053102}`noexec`{.fm-code-in-text1}     | []{#03.htm_pgfId-1053104}Prevent container processes from       |
|                                                          | direct execution of any binaries on the volume.                 |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053106}`nosuid`{.fm-code-in-text1}     | []{#03.htm_pgfId-1053108}Prevent SUID applications from         |
|                                                          | changing their privilege on the volume.                         |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053110}`O`{.fm-code-in-text1}          | []{#03.htm_pgfId-1053112}Mount the directory from the host as a |
|                                                          | temporary storage using the overlay filesystem. Modifications   |
|                                                          | to the mount point are destroyed when the container finishes    |
|                                                          | executing. This option is useful for sharing the package cache  |
|                                                          | from the host into the container to allow speeding up builds.   |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053114}`[r]shared|`{.fm-code-in-text1} | []{#03.htm_pgfId-1053116}Specify mount propagation mode. Mount  |
|                                                          | propagation controls how changes to mounts are propagated       |
| `[r]slave|`{.fm-code-in-text1}                           | across mount boundaries:                                        |
|                                                          |                                                                 |
| `[r]private|`{.fm-code-in-text1}                         | - []{#03.htm_pgfId-1053158}`private`{.fm-code-in-text1}         |
|                                                          |   (default)---Any mounts done inside container will not be      |
| `[r]unbindable`{.fm-code-in-text1}                       |   visible on host and vice versa.                               |
|                                                          |                                                                 |
|                                                          | - []{#03.htm_pgfId-1053140}`shared`{.fm-code-in-text1}---Mounts |
|                                                          |   done under that volume inside container will be visible on    |
|                                                          |   host and vice versa.                                          |
|                                                          |                                                                 |
|                                                          | - []{#03.htm_pgfId-1053143}`slave`{.fm-code-in-text1}---Mounts  |
|                                                          |   done on host under that volume will be visible inside         |
|                                                          |   container but not the other way around.                       |
|                                                          |                                                                 |
|                                                          | - []{#03.htm_pgfId-1053146}`unbindable`{.fm-code-in-text1}---An |
|                                                          |   unbindable version of private mode.                           |
|                                                          |                                                                 |
|                                                          | []{#03.htm_pgfId-1053149}The prefix `r`{.fm-code-in-text1}      |
|                                                          | stands for *recursive*, meaning that any mounts underneath the  |
|                                                          | mount point will also be treated the same way.                  |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053118}`rw|ro`{.fm-code-in-text1}      | []{#03.htm_pgfId-1053120}Mount a volume in read-only            |
|                                                          | (`ro`{.fm-code-in-text1}) or read-write                         |
|                                                          | (`rw`{.fm-code-in-text1}) mode. By default, read/write is       |
|                                                          | implied.                                                        |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053122}`U`{.fm-code-in-text1}          | []{#03.htm_pgfId-1053124}Use the correct host UID and GID based |
|                                                          | on the UID and GID within the container. Use with caution       |
|                                                          | because this will modify the host filesystem.                   |
+----------------------------------------------------------+-----------------------------------------------------------------+
| []{#03.htm_pgfId-1053126}`z|Z`{.fm-code-in-text1}        | []{#03.htm_pgfId-1053128}Relabel file objects on the shared     |
|                                                          | volumes. Choose the `z`{.fm-code-in-text1} option to label      |
|                                                          | volume content as shared among multiple containers. Choose the  |
|                                                          | `Z`{.fm-code-in-text1} option to label content as unshared and  |
|                                                          | private.                                                        |
+----------------------------------------------------------+-----------------------------------------------------------------+

[]{#03.htm_pgfId-1052260}For more information, see the man pages for
`mount`{.fm-code-in-text} and `mount_namespaces(7)`{.fm-code-in-text}.

[]{#03.htm_pgfId-1052261}Most of the time, the simple
`--volume`{.fm-code-in-text} option is powerful enough for mounting
volumes into containers. Over time, the requests for new mount options
grew too complex, so a new option called `--mount`{.fm-code-in-text} was
added.

### []{#03.htm_pgfId-1052263}3.1.3 podman run - -mount command option {#03.htm_heading_id_6 .fm-head1}

[]{#03.htm_pgfId-1052264}The `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} `--mount`{.fm-code-in-text} option is a much
closer option to the underlying Linux mount command. It allows you to
specify all of the mount options that the mount command understands;
Podman passes them down directly to the kernel.

[]{#03.htm_pgfId-1052265}The only mount types currently supported are
`bind`{.fm-code-in-text}, `volume`{.fm-code-in-text},
`image`{.fm-code-in-text}, `tmpfs`{.fm-code-in-text}, and
`devpts`{.fm-code-in-text}. (For more information, see the
`podman-mount(1)`{.fm-code-in-text} man page for more information.)

[]{#03.htm_pgfId-1052267}[]{#03.htm_id_y86zr7tjtxmy}Volumes and mounts
are excellent ways to keep data separate from the container image. In
most cases, the container image should be treated as read-only, and any
data that needs to be written or is not specific to the application
should be stored outside of the container image via volumes. In a lot of
cases, you will get much better performance keeping your data separate,
because reads and writes will not have the overhead of the copy-on-write
filesystem. These mounts also make it easier to use the same container
images with different data (table 3.2).

[]{#03.htm_pgfId-1052432}Table 3.2 Podman volume commands

+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052438}Command                      | []{#03.htm_pgfId-1052440}Man page                                      | []{#03.htm_pgfId-1052442}Description |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052444}`create`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052446}`podman-volume-create(1)`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052448}Create a    |
|                                                       |                                                                        | new volume.                          |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052450}`exists`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052452}`podman-volume-exists(1)`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052454}Check if a  |
|                                                       |                                                                        | volume exists.                       |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052456}`export`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052458}`podman-volume-export(1)`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052460}Export the  |
|                                                       |                                                                        | contents of a volume into a tar      |
|                                                       |                                                                        | ball.                                |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052462}`import`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052464}`podman-volume-import(1)`{.fm-code-in-text1}  | []{#03.htm_pgfId-1052466}Untar a     |
|                                                       |                                                                        | tarball into a volume.               |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052468}`inspect`{.fm-code-in-text1} | []{#03.htm_pgfId-1052470}`podman-volume-inspect(1)`{.fm-code-in-text1} | []{#03.htm_pgfId-1052472}Display     |
|                                                       |                                                                        | detailed information on a volume.    |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052474}`list`{.fm-code-in-text1}    | []{#03.htm_pgfId-1052476}`podman-volume-list(1)`{.fm-code-in-text1}    | []{#03.htm_pgfId-1052478}List all of |
|                                                       |                                                                        | the volumes.                         |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052480}`prune`{.fm-code-in-text1}   | []{#03.htm_pgfId-1052482}`podman-volume-prune(1)`{.fm-code-in-text1}   | []{#03.htm_pgfId-1052484}Remove all  |
|                                                       |                                                                        | unused volumes.                      |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#03.htm_pgfId-1052486}`rm`{.fm-code-in-text1}      | []{#03.htm_pgfId-1052488}`podman-volume-rm(1)`{.fm-code-in-text1}      | []{#03.htm_pgfId-1052490}Remove one  |
|                                                       |                                                                        | or more volumes.                     |
+-------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+

## []{#03.htm_pgfId-1052328}Summary {#03.htm_heading_id_7 .fm-head}

- []{#03.htm_pgfId-1052329 .calibre17}Volumes are useful for separating
  the data used by a container from the application inside an image.

- []{#03.htm_pgfId-1052204 .calibre17}Volumes mount parts of the
  filesystem into a container\'s environment, which means security
  concerns like SELinux and user namespace need to be modified to allow
  access.

[]{#04.htm}

# []{#04.htm_pgfId-1103744}[]{#04.htm_id_sira8yl9f04n}[]{#04.htm_pgfId-1103746}4 Pods {#04.htm_heading_id_2 .tochead}

[]{#04.htm_pgfId-1103748}This chapter []{#04.htm_marker-1104179}covers

- []{#04.htm_pgfId-1103749 .calibre17}An introduction to pods
- []{#04.htm_pgfId-1103750 .calibre17}Managing multiple containers
  within a pod
- []{#04.htm_pgfId-1103751 .calibre17}Using volumes with pods

[]{#04.htm_pgfId-1103753}*Podman* is short for *Pod
Manager*[]{#04.htm_marker-1103752}. A *pod* is a concept popularized by
the Kubernetes project; it is a group of one or more containers working
together for a common purpose and sharing the same namespaces and
cgroups (resource constraints). Additionally, Podman ensures that on
SELinux machines, all container processes within a pod share the same
SELinux labels. This means they can all work together from an SELinux
point of view.

## []{#04.htm_pgfId-1103755}4.1 Running pods {#04.htm_heading_id_3 .fm-head}

[]{#04.htm_pgfId-1103757}Podman []{#04.htm_marker-1103756}pods (see
figure 4.1), just like Kubernetes Pods, always include a container
called the *infra* container[]{#04.htm_marker-1103758}---sometimes
called the *pause* container (not to be confused with the rootless pause
container mentioned in section 5.2). The infra container only holds open
the namespaces and cgroups from the kernel, allowing containers to come
and go within the pod. When Podman adds a container to a pod, it adds
the container process to the cgroups and namespaces. Notice that the
infra container has a container monitor process,
`conmon`{.fm-code-in-text}, monitoring it. Every container within a pod
has its own `conmon`{.fm-code-in-text}.

[]{#04.htm_pgfId-1103759}Conmon is a lightweight C program that monitors
the container until it exits, allowing the Podman executable to exit and
reconnect to the container. Conmon does the following when monitoring
the container:

1.  []{#04.htm_pgfId-1103760 .calibre17}Conmon executes the OCI runtime,
    handing it the path to the OCI spec file as well as pointing to the
    container layer mount point in containers/storage. The mount point
    is called the rootfs[]{#04.htm_marker-1103761 .calibre17}.

2.  []{#04.htm_pgfId-1103762 .calibre17}Conmon monitors the container
    until it exits and reports its exit code back.

3.  []{#04.htm_pgfId-1103763 .calibre17}Conmon handles when the user
    attaches to the container, providing a socket to stream the
    container's `STDOUT`{.fm-code-in-text} and
    `STDERR`{.fm-code-in-text}.

4.  []{#04.htm_pgfId-1103764 .calibre17}The `STDOUT`{.fm-code-in-text}
    and `STDERR`{.fm-code-in-text} are also logged to a file for Podman
    logs.

[]{#04.htm_pgfId-1103771}[Note]{.fm-callout-head} The infra container
(pause container; see figure 4.1) is similar to the rootless pause
container; its only purpose is to hold open the namespaces and cgroups,
while containers come and go. However, each pod will have a different
infra container.

::: figure
![](images/04-01.png){.calibre18}

[]{#04.htm_pgfId-1108956}[]{#04.htm_id_84p7xz75sdgk}Figure 4.1 The
Podman pod launches conmon with the infra container, which will hold
cgroups and Linux namespaces.
:::

[]{#04.htm_pgfId-1103772}Podman pods also support init containers, as
seen in figure 4.2. These containers run before the primary containers
in the pods are executed. An example of an init container is a database
initialization on a volume. This would allow the primary container to
use the database. Podman supports the following two classes of init
containers:

- []{#04.htm_pgfId-1103773 .calibre17}*Once*---Only runs the first time
  the pod is created

- []{#04.htm_pgfId-1103774 .calibre17}*Always*---Runs every time the pod
  is started

[]{#04.htm_pgfId-1103775}The primary container runs the application.

::: figure
![](images/04-02.png){.calibre18}

[]{#04.htm_pgfId-1109098}Figure 4.2 []{#04.htm_id_n238co82eabp}Podman
next launches any init containers with conmon. The init containers
examine the infra container and join its cgroups and namespaces.
:::

[]{#04.htm_pgfId-1103788}Pods also support additional containers, which
are often called *sidecar* containers (see figure 4.4). Sidecar
containers often monitor the primary container, as seen in figure 4.3,
or the environment where the primary container runs. The Kubernetes
documentation
([https://kubernetes.io/docs/concepts/workloads/pods](https://kubernetes.io/docs/concepts/workloads/pods){.url})
describes pods with sidecar containers as follows:

::: figure
![](images/04-03.png){.calibre18}

[]{#04.htm_pgfId-1109134}[]{#04.htm_id_j3t1mdk8ldy}Figure 4.3 Podman
waits until the init containers complete before launching the primary
containers with their `conmon`{.fm-code-in-text} into the pod.
:::

[]{#04.htm_pgfId-1103790 .calibre17}A Pod can encapsulate an application
composed of multiple co-located containers that are tightly coupled and
need to share resources. These co-located containers form a single
cohesive unit of service---for example, one container serving data
stored in a shared volume to the public, while a separate sidecar
container refreshes or updates those files. The Pod wraps these
containers, storage resources, and an ephemeral network identity
together as a single unit.

[]{#04.htm_pgfId-1103791}If you want to dive deeper into sidecar
containers, there are several good articles on the following website:
[https://www.magalix.com/blog/the-sidecar-pattern](https://www.magalix.com/blog/the-sidecar-pattern){.url}.

::: figure
![](images/04-04.png){.calibre18}

[]{#04.htm_pgfId-1109173}[]{#04.htm_id_8bq5c4isrfz1}Figure 4.4 Podman
can launch additional containers called sidecar containers.
:::

[]{#04.htm_pgfId-1103799}[Note]{.fm-callout-head} While pods can support
more than one sidecar container, I recommend you only use one. There is
a real temptation for people to abuse this capability, especially in
Kubernetes, but it can use up more resources and become unwieldy.

[]{#04.htm_pgfId-1103800}A big advantage of using pods is that you can
manage them as discrete units. Starting a pod starts all of the
containers within it, and stopping the pod stops all of the containers.

## []{#04.htm_pgfId-1103802}4.2 Creating a pod {#04.htm_heading_id_4 .fm-head}

[]{#04.htm_pgfId-1103804}In []{#04.htm_marker-1103803}this section, you
will create a pod in which you have the myimage application as the
primary container within the pod. You will also add a second container
to the pod, a sidecar container, which will update the web content used
by your application to show two containers working together within a
pod.

[]{#04.htm_pgfId-1103807}You can create a pod named
`mypod`{.fm-code-in-text}[]{#04.htm_marker-1103805} using the
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`create`{.fm-code-in-text} command[]{#04.htm_marker-1103806}, as
demonstrated in the following command:

``` programlisting
$ podman pod create -p 8080:8080 --name mypod --volume ./html:/var/www/html:z
790fefe97b280e5f67c526e3a421e9c9f958cf5a98f3709373ef1afd91965955
```

[]{#04.htm_pgfId-1103811}The `podman`{.fm-code-in-text}
`pod`{.fm-code-in-text} `create`{.fm-code-in-text}
command[]{#04.htm_marker-1103810} has many of the same options as the
`podman`{.fm-code-in-text} `container`{.fm-code-in-text}
`create`{.fm-code-in-text} command[]{#04.htm_marker-1103812}. When you
create a container within a pod, the container inherits these options as
its default (see figure 4.5).

::: figure
![](images/04-05.png){.calibre18}

[]{#04.htm_pgfId-1109215}[]{#04.htm_id_jxxk1q3so2r7}Figure 4.5 Podman
creates a network namespace and binds port `8080`{.fm-code-in-text}
within the container to port `8080`{.fm-code-in-text} on the host.
Podman creates the infra container with the /var/www/html directory from
the host in the container and joins the cgroups and network namespace.
:::

[]{#04.htm_pgfId-1103813}Notice that, like the previous examples, you
are binding the pod to port `-p`{.fm-code-in-text}
`8080:8080`{.fm-code-in-text}:

``` programlisting
$ podman pod create -p 8080:8080 --name mypod --volume ./html:/var/www/html:z
```

[]{#04.htm_pgfId-1103815}Because the containers within the pod share the
same network namespace, this port binding is shared by all of the
containers. The kernel allows only one process to listen on port
`8080`{.fm-code-in-text}. Lastly, notice that the ./html directory was
volume mounted, `--volume`{.fm-code-in-text}
`./html:/var/www/html:z`{.fm-code-in-text}, into the pod:

``` programlisting
$ podman pod create -p 8080:8080 --name mypod --volume ./html:/var/www/html:z
```

[]{#04.htm_pgfId-1103818}The `:z`{.fm-code-in-text}
parameter[]{#04.htm_marker-1103817} causes Podman to relabel the content
of the directory. Podman will automatically volume mount this directory
into every container that joins the pod. Containers in pods share the
same SELinux label, which means they can share the same
[]{#04.htm_marker-1103819}volumes.

## []{#04.htm_pgfId-1103828}4.3 Adding a container to a pod {#04.htm_heading_id_5 .fm-head}

[]{#04.htm_pgfId-1103832}You
[]{#04.htm_marker-1103829}[]{#04.htm_marker-1103830}create a container
within a pod using the `podman`{.fm-code-in-text}
`create`{.fm-code-in-text} command[]{#04.htm_marker-1103831} (see figure
4.6). Add the quay.io/rhatdan/myimage container to the pod with the
`--pod`{.fm-code-in-text} `mypod`{.fm-code-in-text}
option[]{#04.htm_marker-1103833}:

``` programlisting
$ podman create --pod mypod --name myapp quay.io/rhatdan/myimage
Cec045acb1c2be4a6e4e88e21275076fb1de5519a25fb5a55f192da70708a640
```

::: figure
![](images/04-06.png){.calibre18}

[]{#04.htm_pgfId-1109257}Figure 4.6 []{#04.htm_id_g2ujyja8w08f}Because
the pod does not have any init containers, the first
`myapp`{.fm-code-in-text} container is launched into the pod.
:::

[]{#04.htm_pgfId-1103842}When you add the first container to the pod,
Podman reads the information associated with the infra container and
adds the volume mount to the `myapp`{.fm-code-in-text}
container[]{#04.htm_marker-1103843} and then joins it to the namespaces
held by the infra container. The next step is adding the sidecar
container to the pod. The sidecar container will be updating the
index.html file in the /var/www/html volume, adding a new time stamp
every second.

[]{#04.htm_pgfId-1103845}Create a simple Bash script to update the
index.html used by the `myapp`{.fm-code-in-text}
container,[]{#04.htm_marker-1103844} called html/time.sh. You can create
it in the ./html directory, so it will be available to processes within
the pod:

``` programlisting
$ cat > html/time.sh << _EOL
#!/bin/sh
data() {
  echo "<html><head></head><body><h1>"; date;echo "Hello World</h1></body></html>"
  sleep 1
}
while true; do
   data > index.html
done
_EOL
```

[]{#04.htm_pgfId-1103857}Make sure it is executable. You can do this on
Linux with the `chmod`{.fm-code-in-text}
command[]{#04.htm_marker-1103856}:

``` programlisting
$ chmod +x html/time.sh
```

[]{#04.htm_pgfId-1103859}Now create the second container
(`--name`{.fm-code-in-text} `time`{.fm-code-in-text}), this time using a
different image: ubi8. Containers within pods can use totally different
images, even images from different distributions. Recall that container
images only share the host kernel by default:

``` programlisting
$ podman create --pod mypod --name time --workdir /var/www/html ubi8 ./time.sh
Resolved "ubi8" as an alias (/etc/containers/registries.conf.d/000-shortnames.conf)
Trying to pull registry.access.redhat.com/ubi8:latest...
...
1be0b2fae53029d518e75def71c0d6961b662d0e8b4a1082edea5589d1353af3
```

[]{#04.htm_pgfId-1103865}Remember the concept of short names covered in
chapter 2. You can type the long name, registry.access.redhat.com/ubi8,
but that is a lot of typing. Luckily for us, the short name, ubi8,
already had an alias map to its long name, meaning you do not need to
select it from the list of registries. Podman shows you where it found
the alias for the long name in the output:

``` programlisting
$ podman create --pod mypod --name time --workdir /var/www/html ubi8 ./time.sh
Resolved "ubi8" as an alias (/etc/containers/registries.conf.d/000-shortnames.conf)
```

[]{#04.htm_pgfId-1103869}You also used the `--workdir`{.fm-code-in-text}
command option[]{#04.htm_marker-1104510} to set the default directory
for the container to /var/www/html. When the container starts, the
./time.sh will run in the `workdir`{.fm-code-in-text} and is actually
/var/www/html/time.sh (see figure 4.7):

``` programlisting
$ podman create --pod mypod --name time --workdir /var/www/html ubi8 ./time.sh
```

[]{#04.htm_marker-1104888}[]{#04.htm_pgfId-1103872}Because this
container will be run within the `mypod`{.fm-code-in-text}
pod[]{#04.htm_marker-1103871}, it will inherit the
`-v`{.fm-code-in-text} ./html:/var/www/html option from the pod, meaning
the ./html/time.sh command in the host directory is available to every
container within the pod.

::: figure
![](images/04-07.png){.calibre18}

[]{#04.htm_pgfId-1109296}[]{#04.htm_id_bsufq5aiah2b}Figure 4.7 Finally,
Podman launches the sidecar container named
`time`{.fm-code-in-text}[]{#04.htm_marker-1109297}.
:::

[]{#04.htm_pgfId-1103880}Podman examines the infra container, mounts the
/var/www/html volume, and joins the namespaces when it launches the
sidecar container. Now it is time to start the pod and see what
[]{#04.htm_marker-1103881}[]{#04.htm_marker-1103882}happens.

## []{#04.htm_pgfId-1103884}4.4 Starting a pod {#04.htm_heading_id_6 .fm-head}

[]{#04.htm_pgfId-1103888}You
[]{#04.htm_marker-1103885}[]{#04.htm_marker-1103886}can start the pod
with the `podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`start`{.fm-code-in-text} command[]{#04.htm_marker-1103887}:

``` programlisting
$ podman pod start mypod
790fefe97b280e5f67c526e3a421e9c9f958cf5a98f3709373ef1afd91965955
```

[]{#04.htm_pgfId-1103892}Use the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#04.htm_marker-1103891} to see which
containers the pod started:

``` programlisting
$ podman ps
CONTAINER ID  IMAGE                  COMMAND             CREATED       STATUS          PORTS                 NAMES
b9536ea4a8ab localhost/podman-pause:4.0.3-1648837314                      14 minutes ago  Up 5 seconds ago  0.0.0.0:8080->8080/tcp  8920b1ccd8b0-infra
a978e0005273  quay.io/rhatdan/myimage:latest        /usr/bin/run-http...  14 minutes ago  Up 5 seconds ago  0.0.0.0:8080->8080/tcp  myapp
be86937986e9  registry.access.redhat.com/ubi8:latest  ./time.sh           13 minutes ago  Up 5 seconds ago  0.0.0.0:8080->8080/tcp  time
```

[]{#04.htm_pgfId-1103898}Notice now that three containers have started.
The infra container is based on the k8s.gcr.io/pause image, your
application is based on quay.io/rhatdan/myimage:latest, and the update
container is based on the registry.access.redhat.com/ubi8:latest image.

[]{#04.htm_pgfId-1103899}When the ubi8 sidecar container starts, it
begins modifying the index.html via the time.sh script. Since the
`myapp`{.fm-code-in-text} container[]{#04.htm_marker-1103900} shares the
volume mount, /var/www/html, it can see the changes in the
/var/www/html/index.html file. Launch your favorite web browser, and
navigate to http://localhost:8080 to verify the application is working,
as seen in figure 4.8.

::: figure
![](images/04-08.png){.calibre18}

[]{#04.htm_pgfId-1109339}[]{#04.htm_id_v0n4sa5bdmic}Figure 4.8 The web
browser communicates with `myapp`{.fm-code-in-text} running in a pod.
:::

[]{#04.htm_pgfId-1103913}A couple of seconds later, press the Refresh
button. Notice the date changes, indicating the sidecar container is
running and updating the data used by the `myapp`{.fm-code-in-text} web
server running within the primary container, as seen in figure 4.9.

::: figure
![](images/04-09.png){.calibre18}

[]{#04.htm_pgfId-1109375}[]{#04.htm_id_h58wqqsm5erb}Figure 4.9 The web
browser shows that the content in `myapp`{.fm-code-in-text} has been
changed by the second container running in the pod.
:::

[]{#04.htm_pgfId-1103915}[]{#04.htm_id_vjrr3xilz1pl1}Some notable
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`start`{.fm-code-in-text} options include the following:

- []{#04.htm_pgfId-1103917
  .calibre17}`--all`{.fm-code-in-text}[]{#04.htm_marker-1103916
  .calibre17}---This tells Podman to start all pods.

- []{#04.htm_pgfId-1103919
  .calibre17}`--latest`{.fm-code-in-text}[]{#04.htm_marker-1103918
  .calibre17}---The `-l`{.fm-code-in-text} tells Podman to start the
  last pod created. (This is not available on Mac and Windows.)

[]{#04.htm_pgfId-1103920}Now that you have run the application within a
pod, you might want to stop the
[]{#04.htm_marker-1103921}[]{#04.htm_marker-1103922}application.

## []{#04.htm_pgfId-1103924}4.5 Stopping a pod {#04.htm_heading_id_7 .fm-head}

[]{#04.htm_pgfId-1103927}Now
[]{#04.htm_marker-1103925}[]{#04.htm_marker-1103926}that you see the
application ran successfully, you can stop the pod with the
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`stop`{.fm-code-in-text} command[]{#04.htm_marker-1103928}, as follows:

``` programlisting
$ podman pod stop mypod
790fefe97b280e5f67c526e3a421e9c9f958cf5a98f3709373ef1afd91965955
```

[]{#04.htm_pgfId-1103933}Use the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#04.htm_marker-1103932} to make sure
Podman stopped all the containers within the pod:

``` programlisting
$ podman ps
CONTAINER ID  IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

[]{#04.htm_pgfId-1103937}[]{#04.htm_id_o6adp572edcj1}Some notable
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`stop`{.fm-code-in-text} options include the following:

- []{#04.htm_pgfId-1103939
  .calibre17}`--all`{.fm-code-in-text}[]{#04.htm_marker-1103938
  .calibre17}---This tells Podman to stop all pods.

- []{#04.htm_pgfId-1103941
  .calibre17}`--latest`{.fm-code-in-text}[]{#04.htm_marker-1103940
  .calibre17}---The `-l`{.fm-code-in-text} tells Podman to stop the most
  recently started pod.

- []{#04.htm_pgfId-1103943
  .calibre17}`--timeout`{.fm-code-in-text}[]{#04.htm_marker-1103942
  .calibre17}---The `-t`{.fm-code-in-text} tells Podman to set the
  timeout when attempting to stop the containers within a pod.

[]{#04.htm_pgfId-1103944}Now that you have created, run, and stopped the
pod, you can start examining it. First, list all the pods on your
[]{#04.htm_marker-1103945}[]{#04.htm_marker-1103946}system.

## []{#04.htm_pgfId-1103948}4.6 Listing pods {#04.htm_heading_id_8 .fm-head}

[]{#04.htm_pgfId-1103952}You
[]{#04.htm_marker-1103949}[]{#04.htm_marker-1103950}can list pods with
the `podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`list`{.fm-code-in-text} command[]{#04.htm_marker-1103951}:

``` programlisting
$ podman pod list
POD ID        NAME      STATUS    CREATED         INFRA ID      # OF CONTAINERS
790fefe97b28  mypod     Exited    22 minutes ago  b9536ea4a8ab  3
```

[]{#04.htm_pgfId-1103957}[]{#04.htm_id_qoinjfin0ayc1}Some notable
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`list`{.fm-code-in-text} options include the following:

- []{#04.htm_pgfId-1103959
  .calibre17}`--ctr*`{.fm-code-in-text}[]{#04.htm_marker-1103958
  .calibre17}---This tells Podman to list container information within
  pods.

- []{#04.htm_pgfId-1103961
  .calibre17}`--format`{.fm-code-in-text}[]{#04.htm_marker-1103960
  .calibre17}---This tells Podman to change the output of pods.

[]{#04.htm_pgfId-1103964}Now that you are done with the demonstration,
time to clean up the pods and
[]{#04.htm_marker-1103962}[]{#04.htm_marker-1103963}containers.

## []{#04.htm_pgfId-1103966}4.7 Removing pods {#04.htm_heading_id_9 .fm-head}

[]{#04.htm_pgfId-1103969}In
[]{#04.htm_marker-1103967}[]{#04.htm_marker-1103968}a chapter 8, I
discuss how you can generate Kubernetes YAML files to allow you to
launch your pod on other systems using Podman or within Kubernetes. But
for now, you can remove a pod with the `podman`{.fm-code-in-text}
`pod`{.fm-code-in-text} `rm`{.fm-code-in-text}
command[]{#04.htm_marker-1103970}.

[]{#04.htm_pgfId-1103972}Before you do this, list
`--all`{.fm-code-in-text} the containers on the system. Using the
`--format`{.fm-code-in-text} option[]{#04.htm_marker-1103971} to show
only the ID, image, and pod ID, you will see three containers that make
up your pod:

``` programlisting
$ podman ps --all --format "{{.ID}}  {{.Image}} {{.Pod}}"
b9536ea4a8ab  k8s.gcr.io/pause:3.5 790fefe97b28
a978e0005273  quay.io/rhatdan/myimage:latest 790fefe97b28
be86937986e9  registry.access.redhat.com/ubi8:latest 790fefe97b28
```

[]{#04.htm_pgfId-1103977}Now you can remove the pod with the following
command:

``` programlisting
$ podman pod rm mypod
790fefe97b280e5f67c526e3a421e9c9f958cf5a98f3709373ef1afd91965955
```

[]{#04.htm_pgfId-1103980}Make sure it is gone:

``` programlisting
$ podman pod ls
POD ID    NAME      STATUS    CREATED   INFRA ID  # OF CONTAINERS
```

[]{#04.htm_pgfId-1103983}Good! It looks like your pod is gone. Verify
that Podman removed all of the containers by running the following
command:

``` programlisting
$ podman ps -a --format "{{.ID}} {{.Image}}"
```

[]{#04.htm_pgfId-1103985}The system is fully cleaned up.

[]{#04.htm_pgfId-1103990}[]{#04.htm_id_x5vr0icnbkss}Some notable
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`rm`{.fm-code-in-text} options
include[]{#04.htm_marker-1103987}[]{#04.htm_marker-1103988}
t[]{#04.htm_marker-1103989}he following (also see table 4.1):

- []{#04.htm_pgfId-1103992
  .calibre17}`--all`{.fm-code-in-text}[]{#04.htm_marker-1103991
  .calibre17}---This tells Podman to remove all the pods.

- []{#04.htm_pgfId-1103994
  .calibre17}`--force`{.fm-code-in-text}[]{#04.htm_marker-1103993
  .calibre17}---This tells Podman to first stop all running containers
  before attempting to remove them. Otherwise, Podman will only remove
  non-running pods.[]{#04.htm_id_n2kx94l968 .calibre17}

[]{#04.htm_pgfId-1107258}Table 4.1 `podman`{.fm-code-in-text}
`pod`{.fm-code-in-text} commands

+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107264}Command                                                | []{#04.htm_pgfId-1107266}Man page                                   | []{#04.htm_pgfId-1107268}Description |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107270}`create`{.fm-code-in-text1}[]{#04.htm_marker-1107359}  | []{#04.htm_pgfId-1107272}`podman-pod-create(1)`{.fm-code-in-text1}  | []{#04.htm_pgfId-1107274}Create a    |
|                                                                                 |                                                                     | new pod.                             |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107276}`exists`{.fm-code-in-text1}[]{#04.htm_marker-1107360}  | []{#04.htm_pgfId-1107278}`podman-pod-exists(1)`{.fm-code-in-text1}  | []{#04.htm_pgfId-1107280}Check if a  |
|                                                                                 |                                                                     | pod exists.                          |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107282}`inspect`{.fm-code-in-text1}[]{#04.htm_marker-1107361} | []{#04.htm_pgfId-1107284}`podman-pod-inspect(1)`{.fm-code-in-text1} | []{#04.htm_pgfId-1107286}Display     |
|                                                                                 |                                                                     | detailed information on a pod.       |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107288}`kill`{.fm-code-in-text1}[]{#04.htm_marker-1107362}    | []{#04.htm_pgfId-1107290}`podman-pod-kill(1)`{.fm-code-in-text1}    | []{#04.htm_pgfId-1107292}Send a      |
|                                                                                 |                                                                     | signal to the primary processes of   |
|                                                                                 |                                                                     | the containers in the pod.           |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107294}`list`{.fm-code-in-text1}[]{#04.htm_marker-1107363}    | []{#04.htm_pgfId-1107296}`podman-pod-list(1)`{.fm-code-in-text1}    | []{#04.htm_pgfId-1107298}List all of |
|                                                                                 |                                                                     | the pods.                            |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107300}`logs`{.fm-code-in-text1}[]{#04.htm_marker-1107364}    | []{#04.htm_pgfId-1107302}`podman-pod-logs(1)`{.fm-code-in-text1}    | []{#04.htm_pgfId-1107304}Fetch logs  |
|                                                                                 |                                                                     | for the pod with one or more         |
|                                                                                 |                                                                     | containers.                          |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107306}`pause`{.fm-code-in-text1}[]{#04.htm_marker-1107365}   | []{#04.htm_pgfId-1107308}`podman-pod-pause(1)`{.fm-code-in-text1}   | []{#04.htm_pgfId-1107310}Pause all   |
|                                                                                 |                                                                     | the containers in a pod.             |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107312}`prune`{.fm-code-in-text1}[]{#04.htm_marker-1107366}   | []{#04.htm_pgfId-1107314}`podman-pod-prune(1)`{.fm-code-in-text1}   | []{#04.htm_pgfId-1107316}Remove all  |
|                                                                                 |                                                                     | stopped pods and their containers.   |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107318}`restart`{.fm-code-in-text1}[]{#04.htm_marker-1107367} | []{#04.htm_pgfId-1107320}`podman-pod-restart(1)`{.fm-code-in-text1} | []{#04.htm_pgfId-1107322}Restart a   |
|                                                                                 |                                                                     | pod.                                 |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107324}`rm`{.fm-code-in-text1}[]{#04.htm_marker-1107368}      | []{#04.htm_pgfId-1107326}`podman-pod-rm(1)`{.fm-code-in-text1}      | []{#04.htm_pgfId-1107328}Remove one  |
|                                                                                 |                                                                     | or more pods.                        |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107330}`stats`{.fm-code-in-text1}[]{#04.htm_marker-1107369}   | []{#04.htm_pgfId-1107332}`podman-pod-stats(1)`{.fm-code-in-text1}   | []{#04.htm_pgfId-1107334}Display     |
|                                                                                 |                                                                     | statistics for the containers in a   |
|                                                                                 |                                                                     | pod.                                 |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107336}`start`{.fm-code-in-text1}[]{#04.htm_marker-1107370}   | []{#04.htm_pgfId-1107338}`podman-pod-start(1)`{.fm-code-in-text1}   | []{#04.htm_pgfId-1107340}Start a     |
|                                                                                 |                                                                     | pod.                                 |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107342}`stop`{.fm-code-in-text1}[]{#04.htm_marker-1107371}    | []{#04.htm_pgfId-1107344}`podman-pod-stop(1)`{.fm-code-in-text1}    | []{#04.htm_pgfId-1107346}Stop a pod. |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107348}`top`{.fm-code-in-text1}[]{#04.htm_marker-1107372}     | []{#04.htm_pgfId-1107350}`podman-pod-top(1)`{.fm-code-in-text1}     | []{#04.htm_pgfId-1107352}Display     |
|                                                                                 |                                                                     | running process in the pod.          |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+
| []{#04.htm_pgfId-1107354}`unpause`{.fm-code-in-text1}[]{#04.htm_marker-1107373} | []{#04.htm_pgfId-1107356}`podman-pod-unpause(1)`{.fm-code-in-text1} | []{#04.htm_pgfId-1107358}Unpause all |
|                                                                                 |                                                                     | the containers in a pod.             |
+---------------------------------------------------------------------------------+---------------------------------------------------------------------+--------------------------------------+

## []{#04.htm_pgfId-1104112}Summary {#04.htm_heading_id_10 .fm-head}

- []{#04.htm_pgfId-1104113 .calibre17}Pods are a way of grouping
  containers together into more complex applications, sharing
  namespaces, and sharing resource constraints.

- []{#04.htm_pgfId-1104114 .calibre17}Pods share most of the options
  containers use, and when you add a container to a pod, it shares these
  options with all containers in the []{#04.htm_marker-1104115
  .calibre17}pod.

[]{#p2.htm}

# []{#p2.htm_pgfId-998407} []{#p2.htm_id_Hlk73883217}[]{#p2.htm_pgfId-1015382}Part 2. Design {#p2.htm_heading_id_2 .tochead}

[]{#p2.htm_pgfId-1015384}[P]{.fm-part-initial-cap}art 2 of the book
covers the underlying design of Podman. Chapter 5 explains all of the
different configuration files used with Podman. Podman is developed
using multiple different container libraries, each with a distinct
method of configuration. You learn how to configure your container
storage and where to store your containers as well as images. You also
learn how to configure the container registries you use for pulling and
pushing container images. Finally, you learn about containers.conf,
which allows you to fully customize the way Podman works. Basically, you
can change the default values used by the Podman CLI for every container
you create.

[]{#p2.htm_pgfId-1015385}Chapter 6 then takes a deep dive into how
rootless containers work. Rootless containers are a key feature of
Podman that allows you to fully work with containers and pods as a
normal user, without any additional privileges. This chapter also
introduces you to how the user namespace works and allows you to use
more than a single UID within a container, without being root. Finally,
you will learn some of the problems with rootless containers and how to
work around them. []{#p2.htm_id_u6n877dddx1z}[]{#p2.htm_id_7dubk56duarh}

[]{#05.htm}

# []{#05.htm_pgfId-1105483}[]{#05.htm_id_sira8yl9f04n}[]{#05.htm_pgfId-1105485}5 Customization and configuration files {#05.htm_heading_id_2 .tochead}

[]{#05.htm_pgfId-1105487}This chapter []{#05.htm_marker-1111462}covers

- []{#05.htm_pgfId-1105488 .calibre17}Using Podman configuration files
  based on libraries used
- []{#05.htm_pgfId-1105490 .calibre17}Configuring the storage.conf file
- []{#05.htm_pgfId-1105491 .calibre17}Using the registries.conf and
  policy.json files for configuration
- []{#05.htm_pgfId-1105492 .calibre17}Using the containers.conf file to
  configure other defaults
- []{#05.htm_pgfId-1105493 .calibre17}Using system configuration files
  to allow non-root users namespace access

[]{#05.htm_pgfId-1105494}Container engines like Podman have dozens of
hardcoded defaults built into them. These defaults determine many
aspects of the functional and nonfunctional behaviors of Podman, such as
network and security settings. Podman developers try to pick the maximum
amount of security but still allow most containers to run successfully.
Similarly, I want as much isolation from the host as possible.

[]{#05.htm_pgfId-1105496}The security defaults include which Linux
capabilities to use, which SELinux labels to set, and the set of
syscalls available to the containers. There are defaults for resource
constraints, like memory usage and maximum processes allowed within a
container. Other defaults include the local path for storing images, the
list of container registries, and even system configuration to allow
rootless mode to work. The Podman developers wanted to allow users to
have ultimate control over these defaults, so the container engine
configuration files provide a mechanism for customizing the way Podman
and other container engines run.

[]{#05.htm_pgfId-1105499}The problem with defaults is that they are
best-guess estimates from developers. While most users run Podman in
default configuration, sometimes there is a need to change the
configuration. Not every environment has the same configuration, and you
might want to default certain machines to different levels of security
and different registry configurations. Even rootless users might need
different configurations than rootful users. In this chapter, I will
show you how to customize different parts of Podman and explain where
you can find more information about all of the different knobs available
to you.[]{#05.htm_id_aocnkyr9vpgv}[]{#05.htm_id_qrx0m8lodld}

[]{#05.htm_pgfId-1105502}As you have learned in previous chapters,
Podman uses multiple libraries to perform different tasks when working
with containers. Table 5.1 describes the different libraries Podman
uses.[]{#05.htm_id_md98emseev64}

[]{#05.htm_pgfId-1108137}Table 5.1 Container libraries used by Podman

+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108141}Library                                      | []{#05.htm_pgfId-1108143}Description                |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108145}containers/storage[]{#05.htm_marker-1108160} | []{#05.htm_pgfId-1108147}Defines the storage of     |
|                                                                       | container images and other basic storage used by    |
|                                                                       | container engines                                   |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108149}containers/image[]{#05.htm_marker-1108161}   | []{#05.htm_pgfId-1108151}Defines the mechanisms     |
|                                                                       | used to move container images from different types  |
|                                                                       | of storage; usually used between container          |
|                                                                       | registries and local container storage              |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108153}containers/common[]{#05.htm_marker-1108162}  | []{#05.htm_pgfId-1108155}Defines all of the default |
|                                                                       | configuration options for container engines not     |
|                                                                       | defined in containers/storage or containers/image   |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108157}containers/buildah[]{#05.htm_marker-1108163} | []{#05.htm_pgfId-1108159}As explained in chapter 2, |
|                                                                       | it is used for building container images into local |
|                                                                       | storage using rules defined in a Containerfile or   |
|                                                                       | Dockerfile; for more information on Buildah, see    |
|                                                                       | appendix A.                                         |
+-----------------------------------------------------------------------+-----------------------------------------------------+

[]{#05.htm_pgfId-1105533}Each of these libraries has separate
configuration files used to set the default settings for the particular
library, with the exception of Buildah. The container engines, Podman,
and Buildah share the containers/common configuration file
containers.conf, described in section 5.3.

[]{#05.htm_pgfId-1105534}[Note]{.fm-callout-head} All of the nonsystem
configuration files used by Podman use the TOML format. TOML's syntax
consists of name = "value" pairs, \[section names\], and \# comments.
The format of TOML can be simplified to the following:

- []{#05.htm_pgfId-1105535 .calibre17}`[table]`{.fm-code-in-text1}

- []{#05.htm_pgfId-1105536 .calibre17}`option`{.fm-code-in-text1}
  `=`{.fm-code-in-text1} `value`{.fm-code-in-text1}

- []{#05.htm_pgfId-1105537
  .calibre17}`[table.subtable1]`{.fm-code-in-text1}

- []{#05.htm_pgfId-1105538 .calibre17}`option`{.fm-code-in-text1}
  `=`{.fm-code-in-text1} `value`{.fm-code-in-text1}

- []{#05.htm_pgfId-1105539
  .calibre17}`[table.subtable2]`{.fm-code-in-text1}

- []{#05.htm_pgfId-1105540 .calibre17}`option`{.fm-code-in-text1}
  `=`{.fm-code-in-text1} `value`{.fm-code-in-text1}

[]{#05.htm_pgfId-1105542}See [https://toml.io](https://toml.io){.url}
for a more complete explanation of the TOML language. When configuring
Podman, usually one of the first concerns is where you are going to
store your containers and images.

## []{#05.htm_pgfId-1105544}5.1 Configuration files for storage {#05.htm_heading_id_3 .fm-head}

[]{#05.htm_pgfId-1105548}Podman
[]{#05.htm_marker-1105545}[]{#05.htm_marker-1105546}uses the
[github.com/containers/storage](http://github.com/containers/storage){.url}
library[]{#05.htm_marker-1105547}, which provides methods for storing
filesystem layers, container images, and containers. Configuration of
this library is done using the storage.conf configuration file, which
can be stored in multiple different directories.

[]{#05.htm_pgfId-1105549}Linux distributions often provide a
/usr/share/containers/storage.conf file, which can be overridden by
creating a /etc/containers/storage.conf file. Rootless users can store
their configuration in the \$XDG_CONFIG_HOME/containers/storage.conf
file; if the \$XDG_CONFIG_HOME environment variable is not set, the
\$HOME/.config/ containers/storage.conf file is used. Most users will
never change the storage.conf file, but in a few situations, advanced
users need to do some customizations. The most common reason for changes
is relocating the container's storage.

[]{#05.htm_pgfId-1105550}[Note]{.fm-callout-head} When using Podman in
remote mode, for example on a Mac or Windows box, the Podman service
uses the storage.conf files located in the Linux box. To modify them,
you need to enter the VM. When using the Podman machine, execute the
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1}
`ssh`{.fm-code-in-text1} command[]{#05.htm_marker-1105551} to enter the
VM. See appendixes E and F for more information.

[]{#05.htm_pgfId-1105553}Podman reads only one storage.conf and ignores
all subsequent ones. Podman first attempts to use the storage.conf from
your home directory; next goes the /etc/storage/ storage.conf; and
finally, if both files do not exist, Podman reads the /usr/share/
containers/storage.conf file. You can see the storage.conf file your
Podman command is using via the `podman`{.fm-code-in-text}
`info`{.fm-code-in-text} command[]{#05.htm_marker-1105554}:

``` programlisting
$ podman info --format '{{ .Store.ConfigFile }}'
/home/dwalsh/.config/containers/storage.conf
```

### []{#05.htm_pgfId-1105558}5.1.1 Storage location {#05.htm_heading_id_4 .fm-head1}

[]{#05.htm_pgfId-1105562}By
[]{#05.htm_marker-1109582}[]{#05.htm_marker-1109583}[]{#05.htm_marker-1109584}default
rootless Podman is configured to store your images in the \$HOME/.local/
share/containers/storage directory. The default rootful storage location
is /var/lib/ containers/storage.

[]{#05.htm_pgfId-1105563}Sometimes you need to change this default
location. Perhaps you don't have enough disk space in /var or in the
user's home directory, so you want to store your images on a different
disk. The storage.conf file calls the storage location the
`graphRoot`{.fm-code-in-text}[]{#05.htm_marker-1105564}, and it can be
overridden in /etc/containers/storage.conf for rootful containers.

[]{#05.htm_pgfId-1105565}In this section, you will modify the location
of the graph driver to /var/mystorage. First, become root and make sure
the /etc/containers/storage.conf file exists. If it does not exist, just
copy the /usr/share/containers/storage.conf file into it:

``` programlisting
$ sudo cp /usr/share/containers/storage.conf /etc/containers/storage.conf
```

[]{#05.htm_pgfId-1105567}[Note]{.fm-callout-head} Some distributions
just ship the /etc/containers/storage.conf.

[]{#05.htm_pgfId-1105568}Now, make a backup, and open
/etc/containers/storage.conf file for editing:

``` programlisting
$ sudo cp /etc/containers/storage.conf /etc/containers/storage.conf.orig
$ sudo vi /etc/containers/storage.conf 
```

[]{#05.htm_pgfId-1105571}Set the `graphdriver`{.fm-code-in-text}
variable `graphroot`{.fm-code-in-text} `=`{.fm-code-in-text}
`"/var/lib/containers/storage"`{.fm-code-in-text} to
`graphroot`{.fm-code-in-text} `=`{.fm-code-in-text}
`"/var/mystorage"`{.fm-code-in-text}, and save the file.

[]{#05.htm_pgfId-1105572}Your storage.conf file should include the
following:

``` programlisting
$ grep -B 1 graph /etc/containers/storage.conf 
# Primary Read/Write location of container storage
graphroot = "/var/mystorage"
```

[]{#05.htm_pgfId-1105576}Execute `podman`{.fm-code-in-text}
`info`{.fm-code-in-text} to see if the change took place:

``` programlisting
$ sudo podman info
...
Store:
 configFile: /etc/containers/storage.conf
...
 graphDriverName: overlay
 graphOptions:
  overlay.mountopt: nodev,metacopy=on
 graphRoot: /var/mystorage
...
 volumePath: /var/mystorage/volumes
```

[]{#05.htm_pgfId-1105588}Notice in the storage section that the
`graphRoot`{.fm-code-in-text} is now /var/mystorage. All images and
containers will be stored in this directory.

[]{#05.htm_pgfId-1105590}Now run the `podman`{.fm-code-in-text}
`info`{.fm-code-in-text} command[]{#05.htm_marker-1105589} in rootless
mode. The storage location will not change; it is still
/home/dwalsh/.local/share/containers/storage:

``` programlisting
$ podman info
store:
 configFile: /home/dwalsh/.config/containers/storage.conf
 containerStore:
  number: 27
  paused: 0
  running: 0
  stopped: 27
 graphDriverName: overlay
 graphOptions: {}
 graphRoot: /home/dwalsh/.local/share/containers/storage
```

[]{#05.htm_pgfId-1105602}You can create a
\$HOME/.config/containers/storage.conf and change it there, but this
does not scale well for systems with multiple users. The key
`rootless_storage_ path`{.fm-code-in-text}[]{#05.htm_marker-1105603}
allows you to change the location for all users on your system.

[]{#05.htm_pgfId-1105604}This time, uncomment and modify the
`rootless_storage_path`{.fm-code-in-text} line:

``` programlisting
$ sudo vi /etc/containers/storage.conf 
```

[]{#05.htm_pgfId-1105606}Modify the
`rootless_storage_path`{.fm-code-in-text} line in storage.conf from

``` programlisting
# rootless_storage_path = "$HOME/.local/share/containers/storage"
```

[]{#05.htm_pgfId-1105608}Change it to

``` programlisting
rootless_storage_path = "/var/tmp/$UID/var/mystorage"
```

[]{#05.htm_pgfId-1105610}Save the storage.conf file. When you are done,
it should look like this:

``` programlisting
$ grep -B 3 rootless_storage_path /etc/containers/storage.conf
# Storage path for rootless users
#
rootless_storage_path = "/var/tmp/$UID/var/mystorage"
```

[]{#05.htm_pgfId-1105615}Now run `podman`{.fm-code-in-text}
`info`{.fm-code-in-text} to see the changes. Notice that the
`graphRoot`{.fm-code-in-text} now points at the
/var/tmp/3267/var/mystorage directory:

``` programlisting
$ podman info
...
store:
 configFile: /home/dwalsh/.config/containers/storage.conf
...
 graphOptions: {}
 graphRoot: /var/tmp/3267/var/mystorage
```

[]{#05.htm_pgfId-1105625}Container/storage supports expanding the
`$HOME`{.fm-code-in-text}[]{#05.htm_marker-1105623} and
`$UID`{.fm-code-in-text} environment variables[]{#05.htm_marker-1105624}
for this path. To revert changes, copy and restore the original
storage.conf file:

``` programlisting
$ sudo cp /etc/containers/storage.conf.orig /etc/containers/storage.conf
```

[]{#05.htm_pgfId-1105627}[Note]{.fm-callout-head} If you are running on
an SELinux system and change the default location of storage, you need
to inform SELinux about it, using the following
`semanage`{.fm-code-in-text1} command[]{#05.htm_marker-1105628}. This
will tell SELinux to label the new location as if it was in the old
location. Next, you will need to change the labeling on disk using the
`restorecon`{.fm-code-in-text1} command[]{#05.htm_marker-1105629}. You
can do this with the following commands:

``` programlisting
sudo semanage fcontext -a -e /var/lib/containers/storage /var/mystorage
  sudo restorecon -R -v /var/mystorage
```

[]{#05.htm_pgfId-1105632}In rootless mode you need to do the following:

``` programlisting
sudo semanage fcontext -a -e $HOME/.local/share/containers/storage/
➥ var/tmp/3267/var/mystorage
sudo restorecon -R -v /var/tmp/3267/var/mystorage
```

[]{#05.htm_pgfId-1105636}Sometimes you might want to change the storage
driver or, more likely, the configuration of the storage
[]{#05.htm_marker-1105637}[]{#05.htm_marker-1105638}[]{#05.htm_marker-1105639}driver.

### []{#05.htm_pgfId-1105641}5.1.2 Storage drivers {#05.htm_heading_id_5 .fm-head1}

[]{#05.htm_pgfId-1105645}Recall
[]{#05.htm_marker-1105642}[]{#05.htm_marker-1105643}[]{#05.htm_marker-1105644}the
wedding cake illustration from chapter 2. This illustration shows that
images are often made of multiple layers. These layers are stored on
disk by the container/ storage library, but when you are running a
container on them, each layer needs to be mounted on the previous layer
(figure 5.1).

::: figure
![](images/05-01.png){.calibre18}

[]{#05.htm_pgfId-1111790}[]{#05.htm_id_mnifp03xfnzo}Figure 5.1 Layered
images stacked on one another are reassembled and mounted using
container/storage.
:::

[]{#05.htm_pgfId-1105653}Container/storage uses a Linux kernel
filesystem concept called a *layered
filesystem*[]{#05.htm_marker-1105652} to do this. Podman, using
container/storage, supports multiple different types of layered
filesystems. In Linux, these filesystems are called *copy-on-write
(CoW*[]{#05.htm_marker-1105654}*)* filesystems. In containers/storage,
these different filesystem types are called *drivers*. By default Podman
uses the `overlay`{.fm-code-in-text} storage
driver[]{#05.htm_marker-1105655}.

[]{#05.htm_pgfId-1105656}[Note]{.fm-callout-head} Docker supports two
types of overlay drivers: `overlay`{.fm-code-in-text1} and
`overlay2`{.fm-code-in-text1}. `overlay2`{.fm-code-in-text1} was an
improvement over `overlay`{.fm-code-in-text1}, and the original
`overlay`{.fm-code-in-text1} driver is rarely used any more. In
contrast, Podman uses the newer `overlay2`{.fm-code-in-text1} driver and
just calls it `overlay`{.fm-code-in-text1}. You can select the
`overlay`{.fm-code-in-text1} driver in Podman, but this is just an alias
for `overlay2`{.fm-code-in-text1}.

[]{#05.htm_pgfId-1105657}Table 5.2 lists all of the storage drivers
Podman and containers/storage support. I recommend you just stick to the
`overlay`{.fm-code-in-text} driver, since this is the driver the vast
majority of the world uses.[]{#05.htm_id_4qwxaoy9s9gr}

[]{#05.htm_pgfId-1108284}Table 5.2 Container storage drivers

+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108288}Storage drivers                                                                        | []{#05.htm_pgfId-1108290}Description                |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108292}`overlay (overlay2`{.fm-code-in-text1}[]{#05.htm_marker-1108315}`)`{.fm-code-in-text1} | []{#05.htm_pgfId-1108294}This is the default        |
|                                                                                                                 | driver, and I strongly recommend its use. It is     |
|                                                                                                                 | based on the Linux kernel overlay filesystem.       |
|                                                                                                                 | `overlay`{.fm-code-in-text1} and                    |
|                                                                                                                 | `overlay2`{.fm-code-in-text1} are exactly the same  |
|                                                                                                                 | in Podman. It is the most tested driver, which the  |
|                                                                                                                 | overwhelming majority of users use.                 |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108296}`vfs`{.fm-code-in-text1}[]{#05.htm_marker-1108316}                                     | []{#05.htm_pgfId-1108298}This is the simplest       |
|                                                                                                                 | driver; it creates full copies of each lower layer  |
|                                                                                                                 | up onto the next layer. It works everywhere but is  |
|                                                                                                                 | slow and very disk intensive.                       |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108300}`devmapper`{.fm-code-in-text1}[]{#05.htm_id_mnp47wrp87ki}[]{#05.htm_marker-1109998}    | []{#05.htm_pgfId-1108302}This driver was heavily    |
|                                                                                                                 | used when Docker first became popular---before the  |
|                                                                                                                 | `overlay`{.fm-code-in-text1} driver was available.  |
|                                                                                                                 | It reallocates the size of each layer at a maximum  |
|                                                                                                                 | size. It is not recommended any longer.             |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108304}`aufs`{.fm-code-in-text1}[]{#05.htm_marker-1108319}                                    | []{#05.htm_pgfId-1108306}This driver was never      |
|                                                                                                                 | merged into the upstream kernel, so it is only      |
|                                                                                                                 | available on a few Linux distributions.             |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108308}`btrfs`{.fm-code-in-text1}[]{#05.htm_marker-1108320}                                   | []{#05.htm_pgfId-1108310}This driver allows storage |
|                                                                                                                 | on btrfs snapshots based on the Btrfs filesystem.   |
|                                                                                                                 | Some users have had success using this filesystem.  |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108312}`zfs`{.fm-code-in-text1}[]{#05.htm_marker-1108321}                                     | []{#05.htm_pgfId-1108314}This driver uses the ZFS   |
|                                                                                                                 | filesystem, which is a proprietary filesystem and   |
|                                                                                                                 | not available on most distributions.                |
+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#05.htm_pgfId-1105699}overlay storage options

[]{#05.htm_pgfId-1105701}The
`overlay`{.fm-code-in-text}[]{#05.htm_marker-1105700} driver has some
interesting customization options. These options are located in the
storage.conf \[storage.options.overlay\] table.

[]{#05.htm_pgfId-1105702}There are several advanced options available
for configuring the overlay driver. I'll quickly mention a few to
describe use cases.

[]{#05.htm_pgfId-1105704}The `mount_program`{.fm-code-in-text}
option[]{#05.htm_marker-1105703} allows you to specify an executable to
use instead of the kernel overlay driver. Podman usually ships with the
`fuse-overlayfs`{.fm-code-in-text} executable[]{#05.htm_marker-1105705},
which provides a `FUSE`{.fm-code-in-text} (userspace) overlay driver.
Podman automatically fails over to the
`fuse-overlayfs`{.fm-code-in-text} `mount_program`{.fm-code-in-text} if
it is installed on systems where rootless native overlay is not
supported. Most kernels support native overlay; however, there are use
cases when you might want to configure the
`mount_program`{.fm-code-in-text}. The
`fuse-overlayfs`{.fm-code-in-text} has advanced features not currently
supported in the native overlay.

[]{#05.htm_pgfId-1105707}Podman is quickly being adopted by the
high-performance computing (HPC[]{#05.htm_marker-1105706}) community.
The HPC community does not allow rootful containers, and in many cases
it allows workloads to run only with a single UID. This means some HPC
systems do not allow user namespaces with multiple UIDs. Since many
images come with multiple UIDs, Podman added an
`ignore_chown_errors`{.fm-code-in-text} option[]{#05.htm_marker-1105708}
to containers/storage to allow images with files with different UIDs to
be flattened into a single UID. Table 5.3 lists all the current storage
options supported by container storage.[]{#05.htm_id_41jizfpj6s0d}

[]{#05.htm_pgfId-1105757}[Note]{.fm-callout-head} You have examined a
few of the storage.conf fields, but there are many more. Use the
containers-storage.conf man page to explore all of them:

``` programlisting
https:/ /github.com/containers/storage/blob/main/docs/containers-storage.conf.5.md 
$ man containers-storage.conf
```

[]{#05.htm_pgfId-1108407}Table 5.3 Container storage drivers

+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108411}Storage drivers                                                    | []{#05.htm_pgfId-1108413}Description                           |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108415}`ignore_chown_errors`{.fm-code-in-text1}[]{#05.htm_marker-1110057} | []{#05.htm_pgfId-1108417}Ignore `chown`{.fm-code-in-text1}ing  |
|                                                                                             | file UIDs for rootless containers with a single UID. There is  |
|                                                                                             | no entry in /etc/subuid.                                       |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108419}`mount_program`{.fm-code-in-text1}[]{#05.htm_marker-1110062}       | []{#05.htm_pgfId-1108421}Path to a helper program to use for   |
|                                                                                             | mounting the filesystem instead of using a kernel overlay to   |
|                                                                                             | mount it. Older kernels did not support rootless overlay.      |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108423}`mountopt`{.fm-code-in-text1}                                      | []{#05.htm_pgfId-1108425}Comma-separated list of mount options |
|                                                                                             | to be passed to the kernel. It defaults to                     |
|                                                                                             | `"nodev,metacopy=on"`{.fm-code-in-text1}.                      |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108427}`skip_mount_home`{.fm-code-in-text1}[]{#05.htm_marker-1110072}     | []{#05.htm_pgfId-1108429}Do not create                         |
|                                                                                             | `PRIVATE`{.fm-code-in-text1} bind mounts on the storage home   |
|                                                                                             | directory.                                                     |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108431}`inode`{.fm-code-in-text1}[]{#05.htm_marker-1110077}               | []{#05.htm_pgfId-1108433}Maximum number of inodes in a         |
|                                                                                             | container image                                                |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108435}`size`{.fm-code-in-text1}[]{#05.htm_marker-1110082}                | []{#05.htm_pgfId-1108437}Maximum size of a container image     |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+
| []{#05.htm_pgfId-1108439}`force_mask`{.fm-code-in-text1}[]{#05.htm_marker-1110087}          | []{#05.htm_pgfId-1108441}Permissions mask for new files and    |
|                                                                                             | directories in an image. The values are the following:         |
|                                                                                             |                                                                |
|                                                                                             | - []{#05.htm_pgfId-1108480}`private`{.fm-code-in-text1}---This |
|                                                                                             |   sets all filesystem objects to `0700`{.fm-code-in-text1}. No |
|                                                                                             |   other users on the system can access the files.              |
|                                                                                             |                                                                |
|                                                                                             | - []{#05.htm_pgfId-1108487}`shared`{.fm-code-in-text1}---This  |
|                                                                                             |   is equivalent to `0755`{.fm-code-in-text1}. Everyone on the  |
|                                                                                             |   system can read, access, and execute files in the image.     |
|                                                                                             |   This is useful for sharing container storage with other      |
|                                                                                             |   users.                                                       |
|                                                                                             |                                                                |
|                                                                                             | []{#05.htm_pgfId-1108490}All files within the image are made   |
|                                                                                             | readable and executable by any user on the system. Even        |
|                                                                                             | /etc/shadow within your image is now readable by any user.     |
|                                                                                             |                                                                |
|                                                                                             | []{#05.htm_pgfId-1108493}When `force_mask`{.fm-code-in-text1}  |
|                                                                                             | is set, the original permission mask is stored in              |
|                                                                                             | `xattr`{.fm-code-in-text1}s, and the                           |
|                                                                                             | `mount_program`{.fm-code-in-text1}, like                       |
|                                                                                             | /usr/bin/fuse-overlayfs, presents the                          |
|                                                                                             | `xattr`{.fm-code-in-text1} permissions to processes within     |
|                                                                                             | containers.                                                    |
+---------------------------------------------------------------------------------------------+----------------------------------------------------------------+

[]{#05.htm_pgfId-1105760}Now you know about configuring the container
storage! The next configuration you will look at is
[]{#05.htm_marker-1105761}container
[]{#05.htm_marker-1105762}[]{#05.htm_marker-1105763}[]{#05.htm_marker-1105764}registry
[]{#05.htm_marker-1105765}[]{#05.htm_marker-1105766}access.

## []{#05.htm_pgfId-1105768}5.2 Configuration files for registries {#05.htm_heading_id_6 .fm-head}

[]{#05.htm_pgfId-1105771}Podman
[]{#05.htm_marker-1105769}[]{#05.htm_marker-1105770}uses the
github.com/containers/image library for pulling and pushing container
images, usually from container registries. Podman uses the
registries.conf configuration file to specify registries and the
policy.json file for signature verification of images. As with the
container storage storage.conf, most users never modify these files and
just use the distribution defaults.

### []{#05.htm_pgfId-1105773}5.2.1 registries.conf {#05.htm_heading_id_7 .fm-head1}

[]{#05.htm_pgfId-1105775}The []{#05.htm_marker-1105774}registries.conf
configuration file is a system-wide configuration file for container
image registries. Podman uses \$HOME/.config/containers/registries.conf
if it exists; otherwise, it uses /etc/containers/registries.conf.

[]{#05.htm_pgfId-1105776}[Note]{.fm-callout-head} When using Podman in
remote mode, for example on a Mac or Windows box, registries.conf files
are stored in the Linux box on the server side. You need to
`ssh`{.fm-code-in-text1} into the Linux box to make the changes. With a
Podman machine, you can execute `podman`{.fm-code-in-text1}
`machine`{.fm-code-in-text1} `ssh`{.fm-code-in-text1}. See appendixes E
and F for more information.

[]{#05.htm_pgfId-1105777}The main key value to use with the
registries.conf file is
`unqualified-search-registries`{.fm-code-in-text}. This field specifies
an array of `host[:port]`{.fm-code-in-text} registries to try when
pulling via short names, in order. If you specify only one registry in
the `unqualified-search-registries`{.fm-code-in-text}
option[]{#05.htm_marker-1105778}, Podman will work similarly to Docker
and force a single registry on the user.

[]{#05.htm_pgfId-1105779}In this exercise, you will modify the default
search registries to be used by Podman. First, you need to make a backup
of the /etc/containers/registries.conf file, and then remove docker.io
and add example.com:

``` programlisting
$ sudo cp /etc/containers/registries.conf /etc/containers/registries.conf.orig
$ sudo vi /etc/containers/registries.conf 
```

[]{#05.htm_pgfId-1105782}Modify the following line:

``` programlisting
unqualified-search-registries = ["registry.fedoraproject.org", "registry.access.redhat.com", "docker.io", "quay.io"]
```

[]{#05.htm_pgfId-1105784}Change the line to

``` programlisting
unqualified-search-registries = ["registry.fedoraproject.org", "registry.access.redhat.com", "example.com", "quay.io"]
```

[]{#05.htm_pgfId-1105786}Save the file, then execute
`podman`{.fm-code-in-text} `info`{.fm-code-in-text} to verify the
changes:

``` programlisting
$ podman info
registries:
  search:
  - registry.fedoraproject.org
  - registry.access.redhat.com
  - example.com
  - quay.io
```

[]{#05.htm_pgfId-1105794}Now, if you attempt to pull via an unknown
short name, you should see the following prompt:

``` programlisting
$ podman pull foobar
? Please select an image: 
  ▸ registry.fedoraproject.org/foobar:latest
    registry.access.redhat.com/foobar:latest
    example.com/foobar:latest
    quay.io/foobar:latest
```

[]{#05.htm_pgfId-1105801}Copy the original to the registries.conf file:

``` programlisting
$ sudo cp /etc/containers/registries.conf.orig /etc/containers/registries.conf
```

[]{#05.htm_pgfId-1105803}Table 5.4 describes all of the options
available in registries.conf files.[]{#05.htm_id_ampolw88x8jd}

[]{#05.htm_pgfId-1108571}Table 5.4 Container registries.conf global
fields

+-----------------------------------------------------------------------------+----------------------------------------------------------------------+
| []{#05.htm_pgfId-1108575}Fields                                             | []{#05.htm_pgfId-1108577}Description                                 |
+-----------------------------------------------------------------------------+----------------------------------------------------------------------+
| []{#05.htm_pgfId-1108579}`unqualified-search-registries`{.fm-code-in-text1} | []{#05.htm_pgfId-1108581}An array of                                 |
|                                                                             | `host[:port]`{.fm-code-in-text1} registries to try when pulling an   |
|                                                                             | unqualified image, in order.                                         |
+-----------------------------------------------------------------------------+----------------------------------------------------------------------+
| []{#05.htm_pgfId-1108583}`short-name-mode`{.fm-code-in-text1}               | []{#05.htm_pgfId-1108585}Determines how Podman should handle short   |
|                                                                             | names. The values include the following:                             |
|                                                                             |                                                                      |
|                                                                             | - []{#05.htm_pgfId-1108612}`enforcing`{.fm-code-in-text1}---If there |
|                                                                             |   is one unqualified search registry, use it. If there are two or    |
|                                                                             |   more registries defined and you are running Podman in a terminal,  |
|                                                                             |   prompt the user to select one of the search registries; otherwise, |
|                                                                             |   there will be an error.                                            |
|                                                                             |                                                                      |
|                                                                             | - []{#05.htm_pgfId-1108615}`permissive`{.fm-code-in-text1}---Behaves |
|                                                                             |   as `enforcing`{.fm-code-in-text1} but does not lead to an error if |
|                                                                             |   no terminal: just uses each entry in unqualified search registries |
|                                                                             |   until success.                                                     |
|                                                                             |                                                                      |
|                                                                             | - []{#05.htm_pgfId-1108618}`disabled`{.fm-code-in-text1}---Use all   |
|                                                                             |   unqualified search registries without prompting.                   |
+-----------------------------------------------------------------------------+----------------------------------------------------------------------+
| []{#05.htm_pgfId-1108587}`credential-helpers`{.fm-code-in-text1}            | []{#05.htm_pgfId-1108589}An array of default credential helpers is   |
|                                                                             | used as external credential stores. Note that containers-auth.json   |
|                                                                             | is a reserved value to use auth files as specified in                |
|                                                                             | `containers-auth.json(5)`{.fm-code-in-text1}. The credential helpers |
|                                                                             | are set to `["containers-auth.json"]`{.fm-code-in-text1} if none are |
|                                                                             | specified.                                                           |
+-----------------------------------------------------------------------------+----------------------------------------------------------------------+

[]{#05.htm_pgfId-1105829}Blocking pulling from container registries

[]{#05.htm_pgfId-1105832}Another
[]{#05.htm_marker-1105830}[]{#05.htm_marker-1105831}interesting thing
you can configure in registries.conf is the ability to block users from
pulling from a container registry. In the following example, you will
configure registries.conf to block pulls from docker.io. The
registries.conf file has a specific `[[registry]]`{.fm-code-in-text}
table entry that can specify how to handle individual container
registries. You can add this table multiple times---once per registry:

``` programlisting
$ sudo vi /etc/containers/registries.conf
```

[]{#05.htm_pgfId-1105834}Add the following:

``` programlisting
[[registry]]
Location = "docker.io"
blocked=true
```

[]{#05.htm_pgfId-1105838}Save the file. Examine the settings using
`podman`{.fm-code-in-text} `info`{.fm-code-in-text}:

``` programlisting
$ podman info
...
registries:
 Docker.io:
  Blocked: true
  Insecure: false
  Location: docker.io
  MirrorByDigestOnly: false
  Mirrors: null
  Prefix: docker.io
  search:
  - registry.fedoraproject.org
  - registry.access.redhat.com
  - docker.io
  - quay.io
```

[]{#05.htm_pgfId-1105854}Now, attempt to pull an image from docker.io:

``` programlisting
$ podman pull docker.io/ubuntu
Trying to pull docker.io/library/ubuntu:latest...
Error: initializing source docker:/ /ubuntu:latest: registry docker.io is blocked in /etc/containers/registries.conf or /home/dwalsh/.config/containers/registries.conf.d
```

[]{#05.htm_pgfId-1105858}This demonstrates that administrators have the
ability to block content from specific registries. Table 5.5 describes
the suboptions available for the `[[registry]]`{.fm-code-in-text} table
in the registries.conf file.

[]{#05.htm_pgfId-1105859}[Note]{.fm-callout-head} Copy the original
registries.conf to pull from docker.io for the rest of this book:

``` programlisting
$ sudo cp /etc/containers/registries.conf.orig/
➥ etc/containers/registries.conf
```

[]{#05.htm_pgfId-1108659}Table 5.5 `[[registry]]`{.fm-code-in-text}
table fields

+--------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108663}Fields                        | []{#05.htm_pgfId-1108665}Description                |
+--------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108667}`location`{.fm-code-in-text1} | []{#05.htm_pgfId-1108669}Name of the                |
|                                                        | registry/repository to apply the filters on         |
+--------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108671}`prefix`{.fm-code-in-text1}   | []{#05.htm_pgfId-1108673}Select the specified       |
|                                                        | configuration when attempting to pull an image      |
|                                                        | matched by the specific prefix.                     |
+--------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108675}`insecure`{.fm-code-in-text1} | []{#05.htm_pgfId-1108677}If true, unencrypted HTTP  |
|                                                        | as well as TLS connections with untrusted           |
|                                                        | certificates are allowed.                           |
+--------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108679}`blocked`{.fm-code-in-text1}  | []{#05.htm_pgfId-1108681}If true, pulling images    |
|                                                        | with matching names is forbidden.                   |
+--------------------------------------------------------+-----------------------------------------------------+

[]{#05.htm_pgfId-1105888}Some users work on systems that are fully
isolated from the internet but still need to use applications that rely
on images from the internet. An example of this situation is if you have
an application that expects to use registry.access.redhat.com/ubi8/
httpd-24:latest but has no access to registry.access.redhat.com on the
internet. You can download the image and put it onto an internal
registry and then configure registries.conf with a mirror registry. If
you configure an entry in registries.conf, it will look like this:

``` programlisting
[[registry]]
location="registry.access.redhat.com"
[[registry.mirror]]
location="mirror-1.com"
```

[]{#05.htm_pgfId-1105893}Then your users can use the
`podman`{.fm-code-in-text} `pull`{.fm-code-in-text} command:

``` programlisting
$ podman pull registry.access.redhat.com/ubi8/httpd-24:latest
```

[]{#05.htm_pgfId-1105895}Podman actually pulls
mirror-1.com/ubi8/httpd-24:latest, but users will not notice the
difference.

[]{#05.htm_pgfId-1105896}[Note]{.fm-callout-head} You have examined a
few of the registries.conf fields, but there are many more. Use the
`containers-registries.conf(5)`{.fm-code-in-text1} man
page[]{#05.htm_marker-1105897} to explore all of them:

``` programlisting
$ man containers-registries.conf
https:/ /github.com/containers/image/blob/main/docs/containers-registries.conf.5.md
```

[]{#05.htm_pgfId-1105901}Now that you know how to configure storage and
registries, it is time to look at how to configure all of the options
[]{#05.htm_marker-1105902}[]{#05.htm_marker-1105903}central
[]{#05.htm_marker-1105904}to
[]{#05.htm_marker-1105905}[]{#05.htm_marker-1105906}Podman.

## []{#05.htm_pgfId-1105908}5.3 Configuration files for engines {#05.htm_heading_id_8 .fm-head}

[]{#05.htm_pgfId-1105911}Podman
[]{#05.htm_marker-1108748}[]{#05.htm_marker-1108749}and other container
engines use the github.com/containers/common library for handling the
default settings not related to container storage or container
registries. These configuration settings come from the containers.conf
file. Podman reads the files in table 5.6 if they
exist.[]{#05.htm_id_hipq25nyuwlt}

[]{#05.htm_pgfId-1108711}Table 5.6 containers.conf files read by both
rootful and rootless Podman

+--------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108715}File                                      | []{#05.htm_pgfId-1108717}Description |
+--------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108719}/usr/share/containers/containers.conf     | []{#05.htm_pgfId-1108721}Usually     |
|                                                                    | shipped with the distribution        |
|                                                                    | defaults                             |
+--------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108723}/etc/containers/containers.conf           | []{#05.htm_pgfId-1108725}System      |
|                                                                    | administrator can use this file to   |
|                                                                    | set and modify different defaults.   |
+--------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108727}/etc/containers/containers.conf.d/\*.conf | []{#05.htm_pgfId-1108729}Some        |
|                                                                    | package tools might drop additional  |
|                                                                    | default files into this directory,   |
|                                                                    | sorted numerically.                  |
+--------------------------------------------------------------------+--------------------------------------+

[]{#05.htm_pgfId-1105933}When running in rootless mode, Podman also
reads the files in table 5.7 if they exist.[]{#05.htm_id_b48ggzrj4qk2}

[]{#05.htm_pgfId-1108802}Table 5.7 containers.conf files read by
rootless Podman

+------------------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108806}File                                                | []{#05.htm_pgfId-1108808}Description |
+------------------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108810}\$HOME/.config/containers/containers.conf           | []{#05.htm_pgfId-1108812}Users can   |
|                                                                              | create this file to override system  |
|                                                                              | defaults.                            |
+------------------------------------------------------------------------------+--------------------------------------+
| []{#05.htm_pgfId-1108814}\$HOME/.config/containers/containers.conf.d/\*.conf | []{#05.htm_pgfId-1108816}Users can   |
|                                                                              | also drop files here if they want,   |
|                                                                              | and they will be sorted numerically. |
+------------------------------------------------------------------------------+--------------------------------------+

[]{#05.htm_pgfId-1105951}Unlike storage.conf and registries.conf,
containers.conf files are merged together, and they do not fully
override previous versions. Individual fields can override the same
field in the higher-level containers.conf file. Podman does not require
any containers.conf file to exist, since it has built-in defaults. Most
systems come with only the distribution default overrides in
/usr/share/containers/containers.conf.

[]{#05.htm_pgfId-1105953}[Note]{.fm-callout-head} Podman supports the
CONTAINERS_CONF environment variable[]{#05.htm_marker-1105952}, which
forces Podman to use the target of the \$CONTAINERS_CONF. All other
containers.conf files are ignored. This is useful for testing
environments or making sure no one has customized the Podman defaults.

[]{#05.htm_pgfId-1105954}containers.conf currently supports five
different tables, as shown in table 5.8. You need to be careful that you
are in the correct table when you modify
options.[]{#05.htm_id_ompsioa1yai3}

[]{#05.htm_pgfId-1108881}Table 5.8 Containers.conf tables

+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108885}Table                                       | []{#05.htm_pgfId-1108887}Description                |
+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108889}`[containers]`{.fm-code-in-text1}           | []{#05.htm_pgfId-1108891}Configuration on running   |
|                                                                      | individual containers. Examples are the namespaces  |
|                                                                      | to stick containers in, whether or not SELinux is   |
|                                                                      | enabled, and default environment variables for      |
|                                                                      | containers.                                         |
+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108893}`[engine]`{.fm-code-in-text1}               | []{#05.htm_pgfId-1108895}Default configurations for |
|                                                                      | Podman to use. Examples are the default logging     |
|                                                                      | system, paths for OCI runtimes to use, and the      |
|                                                                      | location of conmon.                                 |
+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108897}`[service_destinations]`{.fm-code-in-text1} | []{#05.htm_pgfId-1108899}Remote connection data for |
|                                                                      | use with `podman`{.fm-code-in-text1}                |
|                                                                      | `--remote`{.fm-code-in-text1}. Remote service is    |
|                                                                      | covered in chapter 9.                               |
+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108901}`[secrets]`{.fm-code-in-text1}              | []{#05.htm_pgfId-1108903}Information about the      |
|                                                                      | `secrets`{.fm-code-in-text1} plugin driver to use   |
|                                                                      | for containers                                      |
+----------------------------------------------------------------------+-----------------------------------------------------+
| []{#05.htm_pgfId-1108905}`[network]`{.fm-code-in-text1}              | []{#05.htm_pgfId-1108907}Special configuration for  |
|                                                                      | network configuration, including the default        |
|                                                                      | network name, location of CNI plugins, and default  |
|                                                                      | subnets                                             |
+----------------------------------------------------------------------+-----------------------------------------------------+

[]{#05.htm_pgfId-1105984}Many users of Podman want to change the default
ways it launches containers in an environment. I previously explained
how the HPC community wants to use Podman to run their workloads, but
they are very specific about the volumes that get added to containers,
which environment variables are added, and which namespaces are enabled.

[]{#05.htm_pgfId-1105985}Perhaps you want all of your containers to have
the same environment variables set. Let's try an example. Run
`podman`{.fm-code-in-text} to show the default environment in the ubi8
image.

``` programlisting
$ podman run --rm ubi8 printenv
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM=xterm
container=oci
HOME=/root
HOSTNAME=ba4acf180386
```

[]{#05.htm_pgfId-1105992}[Note]{.fm-callout-head} When using Podman in
remote mode, for example on a Mac or Windows box, most of the settings
of the containers.conf files are used from the Linux box on the server
side. A containers.conf file in the user's home directory is used for
storing connection data, which is covered in chapter 9. Mac and Windows
clients are covered in appendixes E and F.

[]{#05.htm_pgfId-1105993}Now create an env.conf file in the home
directory with the `env="[foo=bar]"`{.fm-code-in-text} set:

``` programlisting
$ mkdir -p $HOME/.config/containers/containers.conf.d
$ cat << _EOF > $HOME/.config/containers/containers.conf.d/env.conf
[containers]
env=[ "foo=bar" ]
_EOF
Run any container and you see the foo=bar environment set.
$ podman run --rm ubi8 printenv
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM=xterm
container=oci
foo=bar
HOME=/root
HOSTNAME=406fc182d44b
```

[]{#05.htm_pgfId-1106007}I use containers.conf when configuring Podman
to run within a container. Many users want to run Podman within a
container for CI/CD systems or for just testing out newer versions of
Podman than their distribution enables. Because lots of people were
having a hard time running Podman in a container, I decided to try to
create a default image, quay.io/podman/stable, to help them. While
creating that image, I realized several of the Podman defaults did not
work well when running it within a container, so I used containers.conf
to change those settings. You can see my containers.conf file at this
link: [http://mng.bz/o5DM](http://mng.bz/o5DM){.url}.

[]{#05.htm_pgfId-1106008}You can see the contains.conf by actually
running the image:

``` programlisting
$ podman run quay.io/podman/stable cat /etc/containers/containers.conf 
[containers]
netns="host"
userns="host"
ipcns="host"
utsns="host"
cgroupns="host"
cgroups="disabled"
log_driver = "k8s-file"
[engine]
cgroup_manager = "cgroupfs"
events_logger="file"
runtime="crun"
```

[]{#05.htm_pgfId-1106022}Here was what I was thinking while writing this
file. First, I decided that since Podman is running inside of a
container, I would disable all of the cgroups and namespaces other than
the mount and user namespace. If users set cgroups or configured
namespaces, then the container run by Podman in a container would follow
the parent Podman's rules:

``` programlisting
[containers]
netns="host"
userns="host"
ipcns="host"
utsns="host"
cgroupns="host"
cgroups="disabled"
```

[]{#05.htm_pgfId-1106030}The default `log_driver`{.fm-code-in-text},
event logger, and cgroup manager on many distributions is journald and
system, respectively, but inside of the container, systemd and journald
are not running, so the container engine needs to use the filesystem:

``` programlisting
[containers]
log_driver = "k8s-file"
[engine]
cgroup_manager = "cgroupfs"
events_logger="file"
```

[]{#05.htm_pgfId-1106037}Finally, use the OCI runtime
`crun`{.fm-code-in-text}[]{#05.htm_marker-1106036} rather than
`runc`{.fm-code-in-text}, mainly because `crun`{.fm-code-in-text} is a
lot smaller than `runc`{.fm-code-in-text}:

``` programlisting
[engine]
runtime="crun"
```

[]{#05.htm_pgfId-1106040}Now attempt to run a container within a
container. A trick needed to make this work is running the podman/stable
image with `--user`{.fm-code-in-text} `podman`{.fm-code-in-text}. This
causes the Podman inside the container to run in rootless mode. Since
the podman/stable image uses the `fuse-overlay`{.fm-code-in-text}
driver[]{#05.htm_marker-1106041} within the container, you also need to
add the /dev/fuse device:

``` programlisting
$ podman run --device /dev/fuse --user podman quay.io/podman/stable podman 
➥ run ubi8-micro echo hi
Resolved "ubi8" as an alias (/etc/containers/registries.conf.d/
➥ 000-shortnames.conf
Trying to pull registry.access.redhat.com/ubi8:latest...
Getting image source signatures
Copying blob sha256:5368f457acd16b337e2b150741f727c46f886c69eea
➥ 1a4d56d0114c88029ed87
...
hi
```

[]{#05.htm_pgfId-1106052}[Note]{.fm-callout-head} You examined a few of
the containers.conf fields, but there are many more. Use the
`container.conf(5)`{.fm-code-in-text1} man page to explore all of them:

``` programlisting
$ man containers.conf
https:/ /github.com/containers/common/blob/main/docs/containers.conf.5.md
```

[]{#05.htm_pgfId-1106056}Now you know more about configuration tools
specific to container tools like Podman. Next, you'll learn about some
other system configuration files Podman
[]{#05.htm_marker-1106057}[]{#05.htm_marker-1106058}needs.

## []{#05.htm_pgfId-1106060}5.4 System configuration files {#05.htm_heading_id_9 .fm-head}

[]{#05.htm_pgfId-1106063}When
[]{#05.htm_marker-1108995}[]{#05.htm_marker-1108996}you run rootless
Podman, you are using the /etc/subuid and /etc/subgid files to specify
the UID ranges for your containers. As I explained in section 3.1.2,
Podman reads the /etc/subuid and /etc/subgid files for UID and GID
ranges allocated for your user account. Podman then launches
/usr/bin/newuidmap and /usr/bin/newgidmap, which verifies the range of
UIDs and GIDs Podman specified are actually allocated to you. In certain
cases you need to modify these files to add UIDs. Tools like
`useradd`{.fm-code-in-text}[]{#05.htm_marker-1108998} automatically
update the /etc/subuid and /etc/subgid when you add new users to your
system. For example, when I installed my laptop,
`useradd`{.fm-code-in-text} set up my user account to use UID
`3267`{.fm-code-in-text} and added the mapping
`dwalsh:100000:65536`{.fm-code-in-text} to /etc/subuid and /etc/subgid.
Figure 5.2 shows what containers based on this mapping look like on my
system.

::: figure
![](images/05-02.png){.calibre18}

[]{#05.htm_pgfId-1111835}Figure 5.2 User namespace mapping for
containers
:::

[]{#05.htm_pgfId-1106070}[Note]{.fm-callout-head} You want to keep the
ranges of UIDs unique for each user and ensure they are not overlapping
with any system UIDs. Podman and the system do not verify there is no
overlap. If two different users had the same UIDs in their range, the
processes in the containers would be allowed to attack each other from
the user namespace perspective. Verifying this is a manual process. The
`useradd`{.fm-code-in-text1} tool automatically selects unique ranges.

[]{#05.htm_pgfId-1106072}As the `subuid(5)`{.fm-code-in-text} and
`subgid(5)`{.fm-code-in-text} man pages explain, each line in
/etc/subuid and /etc/subgid contains a username and a range of
subordinate user IDs or GIDs, respectively, that the user is allowed to
use. The entry is specified with three fields delimited by colons. These
fields are the following:

- []{#05.htm_pgfId-1106073 .calibre17}Login name or UID

- []{#05.htm_pgfId-1106074 .calibre17}Numerical subordinate user ID or
  group ID

- []{#05.htm_pgfId-1106075 .calibre17}Numerical subordinate user ID or
  group ID count

[]{#05.htm_pgfId-1106076}Newer versions of the operating system,
specifically the packages that ship /usr/bin/ newuidmap and
/usr/bin/newgidmap, are gaining the ability to share the contents of
these files via the network from an LDAP server. On Fedora, these
executables are shipped in the `shadow-utils`{.fm-code-in-text} package.
Versions 4.9 or later have this feature.

[]{#05.htm_pgfId-1106077}[Tip]{.fm-callout-head} Changes to /etc/subuid
and /etc/subgid may not be immediately reflected in the user's account.
This is a common problem for users who modify these files after they
have already run Podman. But remember: when Podman first runs, it
launches the `podman`{.fm-code-in-text1} `pause`{.fm-code-in-text1}
process[]{#05.htm_marker-1108199} in the user namespace, and then all
other containers join this Podman process's user namespace. To have a
new user namespace take effect, you must execute the
`podman`{.fm-code-in-text1} `system`{.fm-code-in-text1}
`migrate`{.fm-code-in-text1} command[]{#05.htm_marker-1108200}, which
stops the `podman`{.fm-code-in-text1} `pause`{.fm-code-in-text1}
[]{#05.htm_marker-1108201}[]{#05.htm_marker-1108202}process[]{#05.htm_marker-1108203}
and re-creates the user namespace.

## []{#05.htm_pgfId-1106084}Summary {#05.htm_heading_id_10 .fm-head}

- []{#05.htm_pgfId-1106085 .calibre17}Podman has multiple configuration
  files based on the libraries it uses.

- []{#05.htm_pgfId-1106086 .calibre17}Configuration files are shared
  between rootful and rootless environments.

- []{#05.htm_pgfId-1106087 .calibre17}The storage.conf file is used to
  configure containers/storage, including the storage driver as well as
  the location where containers and their images are to be stored.

- []{#05.htm_pgfId-1106088 .calibre17}The registries.conf and
  policy.json files are used to configure the container/ image
  library---primarily affecting access to container registries, short
  names, and mirror sights.

- []{#05.htm_pgfId-1106089 .calibre17}The containers.conf file is used
  to configure all of the other defaults used within Podman.

- []{#05.htm_pgfId-1106090 .calibre17}System configuration files
  /etc/subuid and /etc/subgid are used to configure the user namespace
  required for running rootless []{#05.htm_marker-1106091
  .calibre17}Podman.

[]{#06.htm}

# []{#06.htm_pgfId-1110282}[]{#06.htm_id_sira8yl9f04n}[]{#06.htm_pgfId-1110284}6 Rootless containers {#06.htm_heading_id_2 .tochead}

[]{#06.htm_pgfId-1110286}This chapter []{#06.htm_marker-1111672}covers

- []{#06.htm_pgfId-1110287 .calibre17}Why rootless mode is more secure
- []{#06.htm_pgfId-1110288 .calibre17}How Podman works with the user and
  mount namespaces
- []{#06.htm_pgfId-1110289 .calibre17}The architecture of Podman running
  in rootless mode

[]{#06.htm_pgfId-1110290}In this chapter, you will take a deep dive into
what is going on when running Podman in rootless mode. I believe it is
helpful to understand what is happening when you run rootless containers
and learn about the problems that running in rootless mode can cause.
With the introduction of containerized applications over the last few
years, certain highly secure environments were not able to take
advantage of the new technology.

[]{#06.htm_pgfId-1110292}High performance computing
(HPC[]{#06.htm_marker-1110291}) systems run the fastest computers in the
world. These tend to be at national labs and universities and deal with
high-security information. They also handle some of the most secure data
in the world and expressly forbid the use of rootful containers. HPC
systems deal with huge datasets, including artificial intelligence,
nuclear weapons, global weather patterns, and medical research. These
systems tend to have thousands of shared computers, and they need to be
locked down because of their multi-user shared environments. HPC
computing believes running daemons as root is too insecure. If a rogue
container process breaks out of confinement and gains root access, it
can access highly sensitive data. Administrators of HPC environments
couldn't use Open Container Initiative (OCI) containers until Podman
came along. The HPC community is now working to move to rootless Podman.

[]{#06.htm_pgfId-1110293}Similarly, large financial company
administrators do not allow users and developers access to root on their
shared computer systems, out of concern for the financial data involved.
The largest financial firms in the world were having difficulty fully
adopting OCI containers. Figure 6.1 shows that even though the Docker
client can be run as non-root, it connects to a root running daemon,
giving full root access to the host OS.

::: figure
![](images/06-01.png){.calibre18}

[]{#06.htm_pgfId-1115608}Figure 6.1 Multiple users' workloads sharing
the same daemon running as root is inherently insecure.
:::

[]{#06.htm_pgfId-1110300}The bottom line is that allowing users on a
shared computing system to run container workloads accessing the same
root-running daemon is too insecure. Running each user's containers in
rootless mode under different users' accounts is more secure. Figure 6.2
shows multiple users running Podman independent of each other, without
any root access.

::: figure
![](images/06-02.png){.calibre18}

[]{#06.htm_pgfId-1115646}Figure 6.2 Each workload running within its
unique user space is more secure.
:::

[]{#06.htm_pgfId-1110307}Linux was designed from the ground up with a
separation between privileged mode (rootful) and unprivileged mode
(rootless). In Linux almost all tasks run without being privileged.
Privileged operations are only required for modifications to the core
operating system. Almost all applications that run in containers, web
servers, databases, and user tools run without requiring root. The
applications do not modify core parts of the system. Sadly, most of the
images you will find on container registries are built to require root
privileges or at least start as root and then drop privileges.

[]{#06.htm_pgfId-1110308}In the corporate world, administrators are very
reluctant to give out root access to their users. If you receive a
corporate laptop from your employer, usually you are not granted any
root access. Administrators need to control what is installed on their
systems because of scale, and they need to be able to update hundreds to
thousands of machines at the same time, so controlling what is in the OS
is critical. If someone else is administering your machine, they need to
control who gets root access.

[]{#06.htm_pgfId-1110309}As a security person, I still flinch a little
when I see sudo without a password. When I first started working with
Docker, I was shocked that it was encouraging the use of the Docker
group, giving users full root access on the host, without a password.
The holy grail of hackers is to get a root exploit; this means the
hackers gain full control over the system.

[]{#06.htm_pgfId-1110310}Bottom line is that if you have a container
escape, as bad as that is, you are better off in rootless mode. This is
because the hackers have control over only nonprivileged processes, as
opposed to a root exploit, where they have full control over the system
and all of the data (ignoring other security mechanisms like SELinux).
Podman's design goals include the ability to run as many workloads as
possible without being root and push the core OS to make it easier for
you to run in this more secure mode.

## []{#06.htm_pgfId-1110312}6.1 How does rootless Podman work? {#06.htm_heading_id_3 .fm-head}

[]{#06.htm_pgfId-1110313}Have you ever wondered what happens behind the
scenes of a rootless Podman container? In chapter 2, all of the Podman
examples were running in rootless mode. Let's take a look at what
happens under the hood of rootless Podman containers. I'll explain each
component and then break down all of the steps involved.

[]{#06.htm_pgfId-1110314}[Note]{.fm-callout-head} Some of this section
is copied and rewritten from the "What Happens behind the Scenes of a
Rootless Podman Container?" blog
([https://www.redhat.com/sysadmin/behind-scenes-podman](https://www.redhat.com/sysadmin/behind-scenes-podman){.url}),
written by myself and coworkers Matthew Heon and Giuseppe Scrivano.

[]{#06.htm_pgfId-1110316}First, let's first clear out all storage, so
you can get a fresh environment, and then run a container on
quay.io/rhatdan/myimage. (Remember that the `podman`{.fm-code-in-text}
`rmi`{.fm-code-in-text} `--all`{.fm-code-in-text}
`--force`{.fm-code-in-text} command[]{#06.htm_marker-1110317} removes
all images and containers from storage.)

``` programlisting
$ podman rmi --all --force
Untagged: registry.access.redhat.com/ubi8/httpd-24:latest
Untagged: registry.access.redhat.com/ubi8-init:latest
Untagged: localhost/myimage:latest
Untagged: quay.io/rhatdan/myimage:latest
Deleted: d2244a4379d6f1981189d35154beaf4f9a17666ae3b9fba680ddb014eac72adc
Deleted: 82eb390304938f16dd707f32abaa8464af8d4a25959ab342e25696a540ec56b5
Deleted: 8773554aad01d4b8443d979cdd509e7b8fa88ddbc966987fe91690d05614c961
```

[]{#06.htm_pgfId-1110327}Now that you have a clean system, you need to
retrieve the application image, quay.io/ rhatdan/myimage, from the
container registry you pushed it to in chapter 2. In the following
command, re-create the application on your machine. The command pulls
the image back from the container registry and starts the
`myapp`{.fm-code-in-text} container[]{#06.htm_marker-1110328} on your
host.

``` programlisting
$ podman run -d -p 8080:8080 --name myapp quay.io/rhatdan/myimage
Trying to pull quay.io/rhatdan/myimage:latest...
...  
2f111737752dcbf1a1c7e15e807fb48f55362b67356fc10c2ade24964e99fa09
```

[]{#06.htm_pgfId-1110333}Now let's dig deep into what just happened when
you ran a rootless Podman container. The first thing that happened was
Podman needed to set up the user namespace. In the next section, I
explain why, and how it works.

### []{#06.htm_pgfId-1110335}6.1.1 Images contain content owned by multiple user identifiers (UIDs) {#06.htm_heading_id_4 .fm-head1}

[]{#06.htm_pgfId-1110340}In
[]{#06.htm_marker-1113923}[]{#06.htm_marker-1113924}[]{#06.htm_marker-1113925}Linux,
user identifiers (UIDs) and group identifiers
(GIDs[]{#06.htm_marker-1113926}) are assigned to processes and stored on
filesystem objects. The filesystem objects also have permission values
assigned to them. Linux controls the processes' access to the filesystem
based on these UIDs and GIDs. This access is called *discretionary
access control*
(DAC[]{#06.htm_marker-1113928}[]{#06.htm_marker-1113929}). When you log
in to a Linux machine, your rootless user processes run with a single
UID---say, `1000`{.fm-code-in-text}---but container images usually come
with multiple different UIDs in their image layers. Let's examine the
UIDs needed to run our image. In this example, you examine all the UIDs
defined within the container image by running another container.

[]{#06.htm_pgfId-1110343}In the following command, launch a container
with the quay.io/rhatdan/myimage image. You need to run the container as
root (`- -user=root`{.fm-code-in-text}) inside the container to examine
every file within the image.

``` programlisting
$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c "find / 
➥ -mount -printf \”%U=%u\n\” | sort -un" 2>/dev/null
```

[]{#06.htm_pgfId-1110347}Since this is only a temporary container, use
the `--rm`{.fm-code-in-text} option[]{#06.htm_marker-1110346} to make
sure the container is removed when it finishes running. The container
runs a Bash script, which finds all of the UIDs and users associated
with every file/directory in the container. The script pipes the output
to show unique entries and redirects `stderr`{.fm-code-in-text} to
/dev/null to eliminate any errors.

``` programlisting
$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c "find /
➥ -mount -printf \”%U=%u\n\” | sort -un" 2>/dev/null
0=root
48=apache
1001=default
65534=nobody
```

[]{#06.htm_pgfId-1110354}As you can see from the output, our container
image uses four different UIDs, shown in table 6.1.

[]{#06.htm_pgfId-1112391}Table 6.1 Unique UIDs required to run the
container image

+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+
| []{#06.htm_pgfId-1112397}UID                        | []{#06.htm_pgfId-1112399}Name                         | []{#06.htm_pgfId-1112401}Description |
+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+
| []{#06.htm_pgfId-1112403}`0`{.fm-code-in-text1}     | []{#06.htm_pgfId-1112405}`root`{.fm-code-in-text1}    | []{#06.htm_pgfId-1112407}Owns most   |
|                                                     |                                                       | of the content within the container  |
|                                                     |                                                       | image                                |
+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+
| []{#06.htm_pgfId-1112409}`48`{.fm-code-in-text1}    | []{#06.htm_pgfId-1112411}`apache`{.fm-code-in-text1}  | []{#06.htm_pgfId-1112413}Owns all of |
|                                                     |                                                       | the Apache content                   |
+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+
| []{#06.htm_pgfId-1112415}`1001`{.fm-code-in-text1}  | []{#06.htm_pgfId-1112417}`default`{.fm-code-in-text1} | []{#06.htm_pgfId-1112419}Default     |
|                                                     |                                                       | user the container runs as           |
+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+
| []{#06.htm_pgfId-1112421}`65634`{.fm-code-in-text1} | []{#06.htm_pgfId-1112423}`nobody`{.fm-code-in-text1}  | []{#06.htm_pgfId-1112425}Assigned to |
|                                                     |                                                       | any UID that is not mapped into the  |
|                                                     |                                                       | container                            |
+-----------------------------------------------------+-------------------------------------------------------+--------------------------------------+

[]{#06.htm_pgfId-1110389}For you to pull a container image to your home
directory, Podman needs to store at least three different UIDs:
`0`{.fm-code-in-text}, `48`{.fm-code-in-text}, and
`1001`{.fm-code-in-text}. Since the Linux kernel prevents nonprivileged
accounts from using more than a single UID, you are prevented from
creating files with different UIDs. You will need to take advantage of
the user namespace.

[]{#06.htm_pgfId-1110391}User namespace

[]{#06.htm_pgfId-1110396}Linux[]{#06.htm_marker-1110392}[]{#06.htm_marker-1110393}[]{#06.htm_marker-1110394}[]{#06.htm_marker-1110395}
supports the concept of user namespaces, which is a mapping of UID/GIDs
from the host to different UIDs and GIDs inside the namespace. Here is
how the man page describes it:

``` programlisting
$ man user namespaces
...
```

[]{#06.htm_pgfId-1110399}User namespaces isolate security-related
identifiers and attributes---in particular, user IDs and group IDs (see
`credentials(7)`{.fm-code-in-text}), the root directory, keys (see
`keyrings(7)`{.fm-code-in-text}), and capabilities (see
`capabilities(7)`{.fm-code-in-text}). A process's user and group IDs can
be different inside and outside a user namespace. In particular, a
process can have a normal, unprivileged user ID outside a user
namespace, while at the same time having a user ID of
`0`{.fm-code-in-text} inside the namespace; in other words, the process
has full privileges for operations inside the user namespace but is
unprivileged for operations outside the namespace.

[]{#06.htm_pgfId-1110400}Since your container requires more than one
UID, the Podman process first creates and enters a user namespace, where
it has access to more UIDs. Podman must also mount several filesystems
to run a container. These mount commands are not allowed outside a user
namespace (along with a mount namespace). Figure 6.3 shows the UIDs used
within a user namespace.

::: figure
![](images/06-03.png){.calibre18}

[]{#06.htm_pgfId-1115684}Figure 6.3 User namespace mapping for
containers
:::

[]{#06.htm_pgfId-1110408}When I created my system, I used the
`useradd`{.fm-code-in-text} program[]{#06.htm_marker-1110407} to create
my account. It assigned me `3267`{.fm-code-in-text} as my UID and GID,
defined in /etc/passwd and /etc/group. It also allocated UID
`100000-1065535`{.fm-code-in-text}---additional UIDs and GIDs for me
defined in /etc/ subuid and /etc/subgid. Let's see the content of these
files:

``` programlisting
$ cat /etc/subuid
dwalsh:100000:65536
Testuser:165536:65536
$ cat /etc/subgid
dwalsh:100000:65536
Testuser:165536:65536
```

[]{#06.htm_pgfId-1110415}You can cat these files on your system, and
you'll see something similar. On my system I also have a
`testuser`{.fm-code-in-text} account; `useradd`{.fm-code-in-text} also
added UIDs/GIDs for that user, starting right after my allocation.

[]{#06.htm_pgfId-1110416}Within a user namespace, I have access to UIDs
`3267`{.fm-code-in-text} (my UID) as well as `100000`{.fm-code-in-text},
`100001`{.fm-code-in-text}, `100002`{.fm-code-in-text}, \...,
`165535`{.fm-code-in-text}, for a total of 65,537 UIDs. A root user can
modify the /etc/subuid and /etc/subgid files to increase or decrease
this number.

[]{#06.htm_pgfId-1110418}The `useradd`{.fm-code-in-text}
command[]{#06.htm_marker-1110417} starts at UID
`100000`{.fm-code-in-text} to allow you to have around 99,000 regular
users plus 1,000 UIDs reserved for system services on a Linux system.
The kernel supports more than 4 billion UIDs (2^32^ = 4,294,967,296).
Since `useradd`{.fm-code-in-text} allocates 65,537 per user, Linux can
support more than 60,000 users. The 65,536 (2^16^) number was picked
because up until the Linux kernel 2.4, this was the maximum number of
users on a Linux system. Let's look deeper into the user namespace.

[]{#06.htm_pgfId-1110419}Every process on a Linux system is in a
namespace, including the init process and systemd. These are the host
namespaces. Therefore, every process is in a user namespace. You can see
the user namespace mapping for your process by examining the /proc
filesystem. The /proc/PID/uid_map and /proc/PID/gid_map contain the user
namespace mappings for each process on the OS. /proc/self/uid_map
contains the UID map of the current process:

``` programlisting
$ cat /proc/self/uid_map 
      0        0 4294967295
```

[]{#06.htm_pgfId-1110422}The mapping means UIDs starting at UID
`0`{.fm-code-in-text} are mapped to UID `0`{.fm-code-in-text} for a
range of 4,294,967,295 UIDs.

[]{#06.htm_pgfId-1110423}Another way of looking at this mapping is

``` programlisting
UID 0->0, 1->1,...3267->3267,...,4294967294->4294967294.
```

[]{#06.htm_pgfId-1110425}Basically, there is no mapping, so root is
root. And my UID `3267`{.fm-code-in-text} is mapped to
`3267`{.fm-code-in-text}---itself.

[]{#06.htm_pgfId-1110426}Now let's enter the user namespace and see what
is mapped. Podman has a special command, `podman`{.fm-code-in-text}
`unshare`{.fm-code-in-text}, which allows you to enter a user namespace
without launching a container. It allows you to examine what is going on
within the user namespace, while still running as a regular process on
your system.

[]{#06.htm_pgfId-1110427}In the following command, I run
`podman`{.fm-code-in-text} `unshare`{.fm-code-in-text} to launch the cat
/proc/self/ uid_map within the default user namespace for my account:

``` programlisting
$ podman unshare cat /proc/self/uid_map 
       0     3267        1
       1   100000    65536
```

[]{#06.htm_pgfId-1110431}The mappings show that UID
`0`{.fm-code-in-text} is mapped to UID `3267`{.fm-code-in-text} (my UID)
for a range of `1`{.fm-code-in-text}. Then UID `1`{.fm-code-in-text} is
mapped to UID `100000`{.fm-code-in-text} for a range of
`65536`{.fm-code-in-text} UIDS.

[]{#06.htm_pgfId-1110432}Any UID not mapped to the user namespace is
reported within the user namespace as the `nobody`{.fm-code-in-text}
user[]{#06.htm_marker-1110433}. You saw this earlier when you searched
for the UIDs within the container image:

``` programlisting
$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c "find / 
➥ -mount -exec stat -c %u=%U {} \; | sort -un" 2>/dev/null
0=root
48=apache
1001=default
65534=nobody
```

[]{#06.htm_pgfId-1110440}If you look at `/`{.fm-code-in-text} on the
host, you see it is owned by the real root:

``` programlisting
$ ls -l -ld /
dr-xr-xr-x. 18 root root 242 Sep 21 22:32 /
```

[]{#06.htm_pgfId-1110443}If you examine the same directory within the
user namespace, you see it is owned by the `nobody`{.fm-code-in-text}
user[]{#06.htm_marker-1110444}:

``` programlisting
$ podman unshare ls -ld /
dr-xr-xr-x. 18 nobody nobody 242 Sep 21 22:32 /
```

[]{#06.htm_pgfId-1110447}Since the host's UID `0`{.fm-code-in-text} is
not mapped into the user namespace, the kernel reports the UID as the
`nobody`{.fm-code-in-text} user[]{#06.htm_marker-1110448}. Processes
within the user namespace only have access to `nobody`{.fm-code-in-text}
files based on only the
`other`{.fm-code-in-text}[]{#06.htm_marker-1110449} or
`world`{.fm-code-in-text} permissions[]{#06.htm_marker-1110450}. In the
example that follows, you will launch a Bash script that shows the user
is root within the user namespace but sees /etc/passwd as owned by the
user `nobody`{.fm-code-in-text}. You can read the file with the grep
command because /etc/passwd is world readable. But the touch command
fails because even root cannot modify files owned by UIDs not mapped to
the user namespace:

``` programlisting
$ podman unshare bash -c "id ; ls -l /etc/passwd; grep dwalsh 
➥ /etc/passwd; touch /etc/passwd"
uid=0(root) gid=0(root) groups=0(root),65534(nobody)
-rw-r--r--. 1 nobody nobody 2942 Sep 28 07:08 /etc/passwd
dwalsh:x:3267:3267:Dan Walsh:/home/dwalsh:/bin/bash
touch: cannot touch '/etc/passwd': Permission denied
```

[]{#06.htm_pgfId-1110457}Looking at your home directory on the host
versus inside of the user namespace, you see that the same files are
reported as being owned by your UID:

``` programlisting
$ ls -ld /home/dwalsh
drwx------. 365 dwalsh dwalsh 24576 Sep 28 07:30 /home/dwalsh
```

[]{#06.htm_pgfId-1110460}Within the user namespace, they are owned by
root:

``` programlisting
$ podman unshare ls -ld /home/dwalsh
drwx------. 365 root root 24576 Sep 28 07:30 /home/dwalsh
```

[]{#06.htm_pgfId-1110463}By default, Podman maps your UID to root within
the user namespace. Podman defaults to root because, as I specified at
the beginning of this chapter, the majority of container images assume
they start with root.

[]{#06.htm_pgfId-1110464}I'll give one last example. Create a directory
and a file within the directory while in the user namespace, and use the
`chown`{.fm-code-in-text} command[]{#06.htm_marker-1110465} to change
the contents UIDs to `1:1`{.fm-code-in-text}:

``` programlisting
$ podman unshare bash -c "mkdir test;touch test/testfile; chown -R 1:1 test"
```

[]{#06.htm_pgfId-1110467}Outside the user namespace, you see the test
file is owned by UID `100000`{.fm-code-in-text}:

``` programlisting
$ ls -l test
total 0
-rw-r--r--. 1 100000 100000 0 Sep 28 07:53 testfile
```

[]{#06.htm_pgfId-1110471}When you create the test file and
`chown`{.fm-code-in-text} it to UID/GID `1:1`{.fm-code-in-text} within
the user namespace, the on-disk owner is actually UID
`100000`{.fm-code-in-text}/`100000`{.fm-code-in-text}. Remember, within
the user namespace, UID `1`{.fm-code-in-text} is mapped to UID
`100000`{.fm-code-in-text}, so when you create a UID
`1`{.fm-code-in-text} file within the user namespace, the OS actually
creates UID `100000`{.fm-code-in-text}.

[]{#06.htm_pgfId-1110472}If you attempt to remove the file outside of
the user namespace, you get an error:

``` programlisting
$ rm -rf test
rm: cannot remove 'test/testfile': Permission denied
```

[]{#06.htm_pgfId-1110475}Outside the user namespace, you have access to
only your UID; you don't have access to the additional UIDs.

[]{#06.htm_pgfId-1110476}[Note]{.fm-callout-head} In section 3.1.2, I
showed how user namespace mappings can be problematic with container
volumes and discussed ways you can handle them.

[]{#06.htm_pgfId-1110477}Reentering the user namespace, you can remove
the file:

``` programlisting
$ podman unshare rm -rf test
```

[]{#06.htm_pgfId-1110479}Hopefully, you are starting to get a feel for
the user namespace; the `podman`{.fm-code-in-text}
`unshare`{.fm-code-in-text} command[]{#06.htm_marker-1110480} makes it
easy to explore your system within the user namespace and understand
what is happening in rootless containers. When running a rootless
container, Podman needs more than just to run as root; it also needs
access to some of the special powers of root called Linux capabilities.

[]{#06.htm_pgfId-1110481}In Linux, the root processes actually are not
all equally powerful. Linux breaks root privileges into a series of
Linux capabilities. A root process with all Linux capabilities is all
powerful, while a root process without Linux capabilities is not allowed
to manipulate a lot of the system. For example, it cannot read non-root
files, unless those files have permission flags that allow all UIDs on
the system to read (world readable).

[]{#06.htm_pgfId-1110482}Let's see how capabilities work with the user
namespace:

``` programlisting
$ man capabilities
...
DESCRIPTION
For the purpose of performing permission checks, traditional UNIX 
implementations distinguish two categories of processes: privileged 
processes (whose effective user ID is 0, referred to as superuser or root), 
and unprivileged processes (whose effective UID is nonzero). Privileged 
processes bypass all kernel permission checks, while unprivileged processes 
are subject to full permission checking based on the process's credentials 
(usually: effective UID, effective GID, and supplementary group list).
Starting with kernel 2.2, Linux divides the privileges traditionally 
associated with superuser into distinct units, known as capabilities, which 
can be independently enabled and disabled. Capabilities are a per-thread 
attribute.
```

[]{#06.htm_pgfId-1110498}Linux currently has around 40 capabilities.
Examples include
`CAP_SETUID`{.fm-code-in-text}[]{#06.htm_marker-1110497} and
`CAP_SETGID`{.fm-code-in-text}[]{#06.htm_marker-1110499}, which allow
processes to change their UIDs and GIDs.
`CAP_NET_ADMIN`{.fm-code-in-text}[]{#06.htm_marker-1110500} allows you
to manage the network stack.

[]{#06.htm_pgfId-1110502}Another capability called
`CAP_CHOWN`{.fm-code-in-text}[]{#06.htm_marker-1110501} allows processes
to change the UID/GID of files on disk. In the preceding example, when
you `chown`{.fm-code-in-text}ed the test directory to
`1:1`{.fm-code-in-text}, you used the `CAP_CHOWN`{.fm-code-in-text}
capability[]{#06.htm_marker-1110503} within the user namespace:

``` programlisting
$ podman unshare bash -c "mkdir test;touch test/testfile; chown -R 1:1 test"
```

[]{#06.htm_pgfId-1110505}When you run within a user namespace, you are
using namespaced capabilities. The root user within your user namespace
has these capabilities beyond the UIDs and GIDs defined within the
namespace. Processes with the namespaced capability,
`CAP_CHOWN`{.fm-code-in-text}, are allowed to `chown`{.fm-code-in-text}
files owned within your user namespace to UIDs that are also within the
user namespace. If a process within a user namespace attempts to
`chown`{.fm-code-in-text} a file not mapped to the user namespace, owned
by the `nobody`{.fm-code-in-text} user, the process is denied
permission. Likewise, a process attempting to `chown`{.fm-code-in-text}
a file with a UID not defined within the user namespace also gets
denied. Similarly, the `CAP_SETUID`{.fm-code-in-text} capability only
allows processes to change UIDs to those defined within the user
namespace.

[]{#06.htm_pgfId-1110508}When Podman runs a container, it needs to mount
several filesystems for the container. In Linux, the
`CAP_SYS_ADMIN`{.fm-code-in-text} capability[]{#06.htm_marker-1110509}
is required for mounting filesystems. From a security point of view,
mounting filesystems can be a dangerous thing to do on Linux. The kernel
adds additional controls on which types of filesystems can be mounted
and requires your user-namespaced processes to also be in a unique mount
namespace. In chapter 10, you will see how Podman limits the number of
Linux capabilities available to the namespaced root within a
[]{#06.htm_marker-1110510}[]{#06.htm_marker-1110511}[]{#06.htm_marker-1110512}[]{#06.htm_marker-1110513}container.

[]{#06.htm_pgfId-1110515}Mount namespace

[]{#06.htm_pgfId-1110520}Mount
[]{#06.htm_marker-1110516}[]{#06.htm_marker-1110517}[]{#06.htm_marker-1110518}[]{#06.htm_marker-1110519}namespaces
allow processes within them to mount filesystems, where the mount points
are not seen by processes outside the mount namespace. Inside a mount
namespace, you can mount a `tmpfs`{.fm-code-in-text} on /tmp, which
blocks the processes within the namespaces view of /tmp. Outside the
mount namespace, processes still see the original mount and files within
/tmp, but they do not see your mount.

[]{#06.htm_pgfId-1110521}In rootless containers, Podman needs to mount
the content in the container images as well as /proc, /sys, devices from
/dev, and some `tmpfs`{.fm-code-in-text} filesystems. For that, Podman
needs to create a mount namespace:

``` programlisting
$ man mount namespaces
...
Mount namespaces provide isolation of the list of mount points seen by the 
processes in each namespace instance. Thus, the processes in each of the 
mount namespace instances see distinct single-directory hierarchies.
```

[]{#06.htm_pgfId-1110528}When you execute the `podman`{.fm-code-in-text}
`unshare`{.fm-code-in-text} command,[]{#06.htm_marker-1110527} you are
actually entering a different mount namespace as well as a different
user namespace.

[]{#06.htm_pgfId-1110529}You can examine a process's namespaces by
listing the /proc/self/ns/ directory as follows:

``` programlisting
$ ls -l /proc/self/ns/user /proc/self/ns/mnt
lrwxrwxrwx. 1 dwalsh dwalsh 0 Sep 28 09:17 /proc/self/ns/mnt -> 
➥ 'mnt:[4026531840]'
lrwxrwxrwx. 1 dwalsh dwalsh 0 Sep 28 09:17 /proc/self/ns/user -> 
➥ 'user:[4026531837]'
```

[]{#06.htm_pgfId-1110535}Notice that when you enter the user namespace
and mount namespace, the identifiers change:

``` programlisting
$ podman unshare ls -l /proc/self/ns/user /proc/self/ns/mnt
lrwxrwxrwx. 1 root root 0 Sep 28 09:17 /proc/self/ns/mnt -> 
➥ 'mnt:[4026533087]'
lrwxrwxrwx. 1 root root 0 Sep 28 09:17 /proc/self/ns/user -> 
➥ 'user:[4026533086]'
```

[]{#06.htm_pgfId-1110541}In the following test, you can create a file on
/tmp and then attempt to bind mount it onto /etc/shadow. Outside the
namespaces, the kernel rightly prevents you from mounting the file, as
you can see in the following output:

``` programlisting
$ echo hello > /tmp/testfile
$ mount --bind /tmp/testfile /etc/shadow
mount: /etc/shadow: must be superuser to use mount.
 
Once you enter the user namespace and mount namespace, your namespaced 
process can successfully mount over the /etc/shadow file. You can see when 
you run the following command that /etc/shadow is actually modified:
$ podman unshare bash -c "mount -o bind /tmp/testfile /etc/shadow; cat 
/etc/shadow" 
hello
```

[]{#06.htm_pgfId-1110556}Once you exit the `unshare`{.fm-code-in-text},
everything is back to
[]{#06.htm_marker-1110552}[]{#06.htm_marker-1110553}[]{#06.htm_marker-1110554}[]{#06.htm_marker-1110555}normal.

[]{#06.htm_pgfId-1110558}User namespace and mount namespace

[]{#06.htm_pgfId-1110564}As
[]{#06.htm_marker-1110559}[]{#06.htm_marker-1110560}[]{#06.htm_marker-1110561}[]{#06.htm_marker-1110562}[]{#06.htm_marker-1110563}you
saw previously, when you over-mount the /etc/shadow file, you might
trick some `setuid`{.fm-code-in-text} applications, like /bin/su or
/bin/sudo, into giving you full root. The reason rootless users are not
allowed to mount filesystems is to prevent this type of attack.

[]{#06.htm_pgfId-1110565}As you have seen, the separate mount namespace
prevents you from affecting the host's view of the system, and anything
you mount is seen only within the mount namespace. Within the user
namespace, the container already has a namespaced root. Attacks on your
mount points can be escalated to root only within the user
namespace---not real root on the host. Containerized processes cannot
change their UID (`setuid`{.fm-code-in-text}) to real root or any other
UID not mapped into the user namespace.

[]{#06.htm_pgfId-1110566}Even with the namespaces, the Linux kernel only
allows you to mount certain filesystem types. Many filesystem types are
too dangerous to allow for rootless users because they gain access to
sensitive parts of the kernel. I work with filesystem kernel engineers
to see if there are ways to lock down other filesystem types that could
be allowed to be mounted in rootless mode, without affecting the
security of the system.

[]{#06.htm_pgfId-1110567}As of kernel 5.13, the kernel engineers added
native overlay mounts to the list of allowed mounts. The filesystem
types currently allowed are
[]{#06.htm_marker-1110568}[]{#06.htm_marker-1110569}[]{#06.htm_marker-1110570}[]{#06.htm_marker-1110571}[]{#06.htm_marker-1110572}listed
[]{#06.htm_marker-1110573}[]{#06.htm_marker-1110574}[]{#06.htm_marker-1110575}in
table 6.2.

[]{#06.htm_pgfId-1112521}Table 6.2 Filesystem mounts currently supported
in rootless mode

+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112525}Mount type                                               | []{#06.htm_pgfId-1112527}Description                |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112529}`bind`{.fm-code-in-text1}[]{#06.htm_marker-1112572}      | []{#06.htm_pgfId-1112531}Used heavily in rootless   |
|                                                                                   | containers. Because rootless users are not allowed  |
|                                                                                   | to create devices, Podman `bind`{.fm-code-in-text1} |
|                                                                                   | mounts /dev on the host into the container. Podman  |
|                                                                                   | also uses `bind`{.fm-code-in-text1} mounts to       |
|                                                                                   | obscure content within the host filesystem from     |
|                                                                                   | containers. Podman also `bind`{.fm-code-in-text1}   |
|                                                                                   | mounts /dev/null over files in /proc and /sys to    |
|                                                                                   | hide content. Volume mounts, described in chapter   |
|                                                                                   | 3, also use `bind`{.fm-code-in-text1} mounts.       |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112533}`binderfs`{.fm-code-in-text1}[]{#06.htm_marker-1112573}  | []{#06.htm_pgfId-1112535}Filesystem for the Android |
|                                                                                   | binder IPC mechanism. It is not supported by        |
|                                                                                   | Podman.                                             |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112537}`devpts`{.fm-code-in-text1}[]{#06.htm_marker-1112574}    | []{#06.htm_pgfId-1112539}Virtual filesystem mounted |
|                                                                                   | at /dev/pts. It contains device files used for      |
|                                                                                   | terminal emulators                                  |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112541}`cgroupfs`{.fm-code-in-text1}[]{#06.htm_marker-1112575}  | []{#06.htm_pgfId-1112543}Kernel filesystem used to  |
|                                                                                   | manipulate cgroups; rootless containers can use     |
|                                                                                   | `cgroupfs`{.fm-code-in-text1} to manipulate cgroups |
|                                                                                   | in cgroups v2. On v1 this is not supported. This is |
|                                                                                   | mounted at /sys/fs/cgroups.                         |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112545}`FUSE`{.fm-code-in-text1} []{#06.htm_marker-1112576}     | []{#06.htm_pgfId-1112547}Used to mount container    |
|                                                                                   | images using the                                    |
|                                                                                   | `fuse-overlayfs`{.fm-code-in-text1} in rootless     |
|                                                                                   | mode. Prior to kernel 5.13, this was the only way   |
|                                                                                   | to use an overlay filesystem in rootless mode.      |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112549}`procfs`{.fm-code-in-text1}[]{#06.htm_marker-1112577}    | []{#06.htm_pgfId-1112551}Mounted at /proc within    |
|                                                                                   | the container. You can examine processes within the |
|                                                                                   | container.                                          |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112553}`mqueue`{.fm-code-in-text1}[]{#06.htm_marker-1112578}    | []{#06.htm_pgfId-1112555}Implements the POSIX       |
|                                                                                   | message queues API. Podman mounts this filesystem   |
|                                                                                   | at /dev/mqueue.                                     |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112557}`overlayfs`{.fm-code-in-text1}[]{#06.htm_marker-1112579} | []{#06.htm_pgfId-1112559}Used for mounting the      |
|                                                                                   | image. Performs better in the                       |
|                                                                                   | `fuse-overlayfs`{.fm-code-in-text1} filesystem. In  |
|                                                                                   | certain use cases, it provides benefits over native |
|                                                                                   | overlay, such as NFS home directories.              |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112561}`ramfs`{.fm-code-in-text1}[]{#06.htm_marker-1112580}     | []{#06.htm_pgfId-1112563}Dynamically resizable,     |
|                                                                                   | ram-based Linux filesystem, currently not used with |
|                                                                                   | Podman.                                             |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112565}`sysfs`{.fm-code-in-text1}[]{#06.htm_marker-1112581}     | []{#06.htm_pgfId-1112567}Mounted at /sys.           |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#06.htm_pgfId-1112569}`tmpfs`{.fm-code-in-text1}[]{#06.htm_marker-1112582}     | []{#06.htm_pgfId-1112571}Used to obscure kernel     |
|                                                                                   | filesystem directories from containers in /proc and |
|                                                                                   | /sys.                                               |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+

## []{#06.htm_pgfId-1110640}6.2 Rootless Podman under the covers {#06.htm_heading_id_5 .fm-head}

[]{#06.htm_pgfId-1110641}Now that you have some understanding of how the
user namespace and mount namespace work and why they are needed, let's
dig deeper into what Podman does when it runs a container. The first
time you run a Podman container after logging in, Podman reads the
/etc/subuid and /etc/subgid files, looking for your username or UID.
Once Podman finds the entry, it uses the contents as well as your
current UID/GID to generate a user namespace for you. Podman then
launches the `podman`{.fm-code-in-text} `pause`{.fm-code-in-text}
process[]{#06.htm_marker-1110642} to hold open the user and mount
namespaces (figure 6.4).

::: figure
![](images/06-04.png){.calibre18}

[]{#06.htm_pgfId-1115722}Figure 6.4 Podman launches the pause process to
hold open the user and mount namespaces.
:::

[]{#06.htm_pgfId-1110649}Users commonly report that after they run
Podman containers, they see a `podman`{.fm-code-in-text} process still
running when they run the following command:

``` programlisting
$ ps -e | grep podman
  2541 ?     00:00:00 podman pause 
```

[]{#06.htm_pgfId-1110652}Subsequent running of the Podman commands joins
the namespaces of the `podman`{.fm-code-in-text}
`pause`{.fm-code-in-text} process[]{#06.htm_marker-1110653}. Podman does
this to avoid race conditions when user namespaces are coming up and
going down. The `pause`{.fm-code-in-text} process remains running until
you log out. You can also execute the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `migrate`{.fm-code-in-text}
command[]{#06.htm_marker-1110654} to remove it. The
`pause`{.fm-code-in-text} process's role is keeping the user namespace
alive, as all rootless containers must be run in the same user
namespace. If they were not, sharing content and other namespaces (like
sharing the network namespace from another container) is impossible.

[]{#06.htm_pgfId-1110655}[Note]{.fm-callout-head} I often have users
report that when changing the /etc/subuid and /etc/subgid files, their
containers don't reflect the changes right away. Since the pause process
was launched with the previous user namespace settings, it needs to be
removed. Executing the `podman`{.fm-code-in-text1}
`system`{.fm-code-in-text1} `migrate`{.fm-code-in-text1} command
restarts the pause process within the user namespace.

[]{#06.htm_pgfId-1110656}You can kill the `pause`{.fm-code-in-text}
process at any time, but Podman re-creates it on the next run. By
default each rootless user has their own user namespace, and all of
their containers run within the same user namespace. You can subdivide
the user namespace and run containers with different user namespaces,
but realize, by default, you only have 65,000 UIDs to work with. Running
multiple containers in different user namespaces is much easier to do
when running rootful containers. Now that the user namespace and mount
namespace are created, Podman creates storage for the container's image
and sets up a mount point to start storing the image.

### []{#06.htm_pgfId-1110658}6.2.1 Pulling the image {#06.htm_heading_id_6 .fm-head1}

[]{#06.htm_pgfId-1110668}When
[]{#06.htm_marker-1110665}[]{#06.htm_marker-1110666}[]{#06.htm_marker-1110667}pulling
the image (figure 6.5), Podman checks if the container image quay.io/
rhatdan/myimage exists in local container storage. If it does, Podman
sets up the container network (see section 6.2.3). However, if the
container image does not exist, Podman uses the containers/image library
to pull the image. Following are the steps Podman takes while pulling
the image:

1.  []{#06.htm_pgfId-1110669 .calibre17}Resolve the IP address for the
    registry: quay.io.

2.  []{#06.htm_pgfId-1110670 .calibre17}Connect to the IP address via
    the HTTPS port (`443`{.fm-code-in-text}).

3.  []{#06.htm_pgfId-1110671 .calibre17}Begin pulling the manifest, all
    layers, and the config of the image using the HTTP protocol.

4.  []{#06.htm_pgfId-1110672 .calibre17}Find the multiple layers or
    blobs of quay.io/rhatdan/myimage.

5.  []{#06.htm_pgfId-1110673 .calibre17}Copy all layers simultaneously
    from the container registry to the host.

::: figure
![](images/06-05.png){.calibre18}

[]{#06.htm_pgfId-1115763}Figure 6.5 Podman pulls an image off a
container registry and stores it in the container storage.
:::

[]{#06.htm_marker-1110696}[]{#06.htm_pgfId-1110674}As each layer is
copied to the host, Podman uses the containers/storage library to
reassemble the layers in order, creating an overlay mount point for each
of them on top of the previous one in
\~/.local/share/containers/storage. If there is no previous layer, it
creates the initial layer.

[]{#06.htm_pgfId-1110675}Next, containers/storage untars the contents of
the layer into the new storage layer. As the layers are untarred,
containers/storage `chown`{.fm-code-in-text}s the UID/GIDs of files in
the tarball into the home directory. Podman takes advantage of the user
namespace `CAP_CHOWN`{.fm-code-in-text}, as explained in previous
sections. Remember that Podman fails to create content if the UID or GID
specified in the TAR file was not mapped into the user
[]{#06.htm_marker-1110676}[]{#06.htm_marker-1110677}[]{#06.htm_marker-1110678}namespace.

### []{#06.htm_pgfId-1110680}6.2.2 Creating a container {#06.htm_heading_id_7 .fm-head1}

[]{#06.htm_pgfId-1110682}Once []{#06.htm_marker-1110681}the
containers/storage library finishes downloading the image and creating
the storage, Podman creates a new container based on the image. Podman
adds the container to Podman's internal database. It then tells
containers/storage to create writable space on disk and use the default
storage driver, usually `overlayfs`{.fm-code-in-text}, to mount this
space as a new container layer. The new container layer acts as the
final read/write layer and is mounted on top of the image.

[]{#06.htm_pgfId-1110683}[Note]{.fm-callout-head} Rootful containers
default to using native Linux overlay mounts. In rootless mode, kernel
versions newer than 5.13 or with the rootless overlay feature backported
(RHEL 8.5 kernels or later also have this feature) use the native
overlay mounts. On older kernels, Podman uses the
`fuse-overlayfs`{.fm-code-in-text1} executable[]{#06.htm_marker-1110684}
to create the layer. In Podman, `overlay`{.fm-code-in-text1} and
`overlay2`{.fm-code-in-text1} are the same drivers.

[]{#06.htm_pgfId-1110686}At this point, Podman needs to configure the
network inside the network []{#06.htm_marker-1110685}namespace.

### []{#06.htm_pgfId-1110688}6.2.3 Setting up the network {#06.htm_heading_id_8 .fm-head1}

[]{#06.htm_pgfId-1110697}In
[]{#06.htm_marker-1115791}[]{#06.htm_marker-1115792}rootless Podman, you
cannot create full, separate networking for containers because rootless
processes are not allowed to create network devices and modify the
firewall rules. Rootless Podman uses slirp4netns
([https://github.com/rootless-containers/slirp4netns](https://github.com/rootless-containers/slirp4netns){.url})
to configure the host network and simulate a VPN for the container.
Slirp4netns provides user-mode networking (slirp) for unprivileged
network namespaces. See figure 6.6.

::: figure
![](images/06-06.png){.calibre18}

[]{#06.htm_pgfId-1115814}Figure 6.6 Podman creates a network namespace
and launches slirp4netns to relay network connections.
:::

[]{#06.htm_pgfId-1110698}[Note]{.fm-callout-head} In rootful containers,
Podman uses the CNI plugins to configure networking devices. In rootless
mode, even though the user is allowed to create and join a network
namespace, they are not allowed to create network devices. The
slirp4netns program emulates a virtual network to connect host
networking to the container networking. More advanced networking setups
require rootful containers.

[]{#06.htm_pgfId-1110699}Remember that in our original example, you
specified the `8080:8080`{.fm-code-in-text} port mapping as follows:

``` programlisting
$ podman run -d -p 8080:8080 --name myapp 
     registry.access.redhat.com/ubi8/httpd-24
```

[]{#06.htm_marker-1110731}[]{#06.htm_pgfId-1110701}Podman configures the
slirp4netns program to listen on the host network at port
`8080`{.fm-code-in-text} and allow the container process to bind to port
`8080`{.fm-code-in-text}. The slirp4netns command creates a tap device
that is injected inside the new network namespace, where the container
lives. Each packet is read back from slirp4netns and emulates a TCP/IP
stack in user space. Each connection outside the container network's
namespace is converted in a socket operation the unprivileged user can
run in the host network's namespace.

[]{#06.htm_pgfId-1110702}[Note]{.fm-callout-head} Linux TAP devices
create a user space network bridge. In user space, TAP devices can
simulate network devices inside of a network namespace. Processes within
the namespace interact with the network device. Packets read/written
from the network device are routed via the TUN/TAP device to the user
space program: slirp4netns.

[]{#06.htm_pgfId-1110703}Now that the storage and network are
configured, Podman is ready to finally start the container
[]{#06.htm_marker-1110704}[]{#06.htm_marker-1110705}process.

### []{#06.htm_pgfId-1110707}6.2.4 Starting the container monitor: conmon {#06.htm_heading_id_9 .fm-head1}

[]{#06.htm_pgfId-1110716}Podman
[]{#06.htm_marker-1110714}[]{#06.htm_marker-1110715}now executes conmon
(container monitor) for the container, telling it to use its configured
OCI runtime, usually `crun`{.fm-code-in-text}[]{#06.htm_marker-1110717}
or `runc`{.fm-code-in-text}[]{#06.htm_marker-1110718}. It also executes
the `podman`{.fm-code-in-text} `container`{.fm-code-in-text}
`cleanup`{.fm-code-in-text} `$CTRID`{.fm-code-in-text}
command[]{#06.htm_marker-1110719} when the container exits (see figure
6.7). conmon is described in
[]{#06.htm_marker-1110720}[]{#06.htm_marker-1110721}section 4.1.

::: figure
![](images/06-07.png){.calibre18}

[]{#06.htm_pgfId-1115852}Figure 6.7 Podman launches the container
monitor, which launches the OCI runtime.
:::

### []{#06.htm_pgfId-1110723}6.2.5 Launching the OCI runtime {#06.htm_heading_id_10 .fm-head1}

[]{#06.htm_pgfId-1110732}The
[]{#06.htm_marker-1115925}[]{#06.htm_marker-1115926}OCI runtime reads
the OCI spec file and configures the kernel to run the container (see
figure 6.8). OCI runtimes do the following:

1.  []{#06.htm_pgfId-1110733 .calibre17}Set up the additional namespaces
    for the container.

2.  []{#06.htm_pgfId-1110734 .calibre17}Configure cgroups v2 (cgroups v1
    is not supported for rootless containers).

3.  []{#06.htm_pgfId-1110735 .calibre17}Set up the SELinux label for
    running the container.

4.  []{#06.htm_pgfId-1110736 .calibre17}Load the
    /usr/share/containers/seccomp.json seccomp rules into the kernel.

5.  []{#06.htm_pgfId-1110737 .calibre17}Set the environment variables
    for the container.

6.  []{#06.htm_pgfId-1110738 .calibre17}Bind mount any volumes onto the
    paths in the rootfs.

7.  []{#06.htm_pgfId-1110739 .calibre17}Switch the current
    `/`{.fm-code-in-text} to the rootfs `/`{.fm-code-in-text}.

8.  []{#06.htm_pgfId-1110740 .calibre17}Fork the container process.

9.  []{#06.htm_pgfId-1110741 .calibre17}Execute any OCI hook programs,
    passing them the rootfs as well as the container's PID 1.

10. []{#06.htm_pgfId-1110742 .calibre17}Execute the command specified by
    the image.

11. []{#06.htm_pgfId-1110743 .calibre17}Exit the OCI runtime, leaving
    conmon to monitor the container.

::: figure
![](images/06-08.png){.calibre18}

[]{#06.htm_pgfId-1116007}Figure 6.8 conmon launches the OCI runtime,
which configures the kernel.
:::

[]{#06.htm_marker-1110753}[]{#06.htm_pgfId-1110744}And finally, conmon
reports the success back to Podman (see figure 6.9).

::: figure
![](images/06-09.png){.calibre18}

[]{#06.htm_pgfId-1116045}Figure 6.9 Podman and OCI runtime exit, leaving
the container running with conmon monitoring it and slirp4netns
providing the network.
:::

[]{#06.htm_pgfId-1110754}The Podman command now exits because it ran in
`--detach`{.fm-code-in-text} (`-d`{.fm-code-in-text})
[]{#06.htm_marker-1115991}[]{#06.htm_marker-1115992}mode[]{#06.htm_marker-1115993}.

``` programlisting
$ podman run -d -p 8080:8080 --name myapp 
     registry.access.redhat.com/ubi8/httpd-24
```

[]{#06.htm_pgfId-1110756}[Note]{.fm-callout-head} If later you want
Podman to interact with the detached container, use the
`podman`{.fm-code-in-text1} `attach`{.fm-code-in-text1}
command[]{#06.htm_marker-1110757}, which connects to the conmon socket.
conmon allows Podman to interact with the container process through the
`STDIN`{.fm-code-in-text1}[]{#06.htm_marker-1110758},
`STDOUT`{.fm-code-in-text1}[]{#06.htm_marker-1110759}, and
`STDERR`{.fm-code-in-text1} file descriptors[]{#06.htm_marker-1110760},
which conmon has been monitoring.

### []{#06.htm_pgfId-1110762}6.2.6 The containerized application runs until completion {#06.htm_heading_id_11 .fm-head1}

[]{#06.htm_pgfId-1110764}The []{#06.htm_marker-1110763}application
process can exit on its own, or you can stop the container by executing
the `podman`{.fm-code-in-text} `stop`{.fm-code-in-text}
command[]{#06.htm_marker-1110765}:

``` programlisting
$ podman stop myapp
```

[]{#06.htm_pgfId-1110768}When the container process exits, the kernel
sends a `SIGCHLD`{.fm-code-in-text} to the `conmon`{.fm-code-in-text}
process[]{#06.htm_marker-1110767}. In turn, conmon does the following:

1.  []{#06.htm_pgfId-1110769 .calibre17}Records the container's exit
    code

2.  []{#06.htm_pgfId-1110770 .calibre17}Closes the container's logfile

3.  []{#06.htm_pgfId-1110771 .calibre17}Closes the Podman command's
    `STDOUT`{.fm-code-in-text}/`STDERR`{.fm-code-in-text}

4.  []{#06.htm_pgfId-1110773 .calibre17}Executes the
    `podman`{.fm-code-in-text} `container`{.fm-code-in-text}
    `cleanup`{.fm-code-in-text} `$CTRID`{.fm-code-in-text}
    command[]{#06.htm_marker-1110772 .calibre17}

5.  []{#06.htm_pgfId-1110774 .calibre17}Exits itself

[]{#06.htm_pgfId-1110776}The `podman`{.fm-code-in-text}
`container`{.fm-code-in-text} `cleanup`{.fm-code-in-text}
command[]{#06.htm_marker-1110775} takes down the slirp4netns network and
unmounts all of the container mount points. If you specify the
`--rm`{.fm-code-in-text} option[]{#06.htm_marker-1110777}, the container
is entirely removed---layers are removed from containers/storage, and
the container definition is removed from []{#06.htm_marker-1110778}the
DB.

## []{#06.htm_pgfId-1110780}Summary {#06.htm_heading_id_12 .fm-head}

- []{#06.htm_pgfId-1110781 .calibre17}Running rootless containers is
  more secure than running rootful containers.

- []{#06.htm_pgfId-1110782 .calibre17}The user namespace gives ordinary
  users the ability to manipulate more than one UID and is key to
  running containers.

- []{#06.htm_pgfId-1110783 .calibre17}The mount namespace allows Podman
  to mount filesystems within the user namespace.

- []{#06.htm_pgfId-1110784 .calibre17}Podman uses slirp4netns for
  providing network access to containers.

- []{#06.htm_pgfId-1110786 .calibre17}Podman launches the
  `conmon`{.fm-code-in-text} process to monitor the
  []{#06.htm_marker-1110785 .calibre17}container.

[]{#p3.htm}

# []{#p3.htm_pgfId-998407} []{#p3.htm_id_Hlk73883217}[]{#p3.htm_pgfId-1016261}Part 3. Advanced topics {#p3.htm_heading_id_2 .tochead}

[]{#p3.htm_pgfId-1016264}[I]{.fm-part-initial-cap}n part 3 of the book,
you learn about advanced ways you can use Podman. This part discusses
integrating Podman into your system and how Podman can work with other
tools and orchestrators.

[]{#p3.htm_pgfId-1016265}In chapter 7, I introduce systemd integration.
Podman was developed to fully integrate into the system and takes
advantage of the init system: systemd. Systemd can easily be run within
Podman containers, and this chapter shows you how. Podman, likewise, can
be run within systemd services and provides commands that allow you to
automatically create the service configuration files to make this
happen.

[]{#p3.htm_pgfId-1016266}Chapter 8 shows you how Podman works with
Kubernetes. Podman is not a container engine under Kubernetes but can
work with Kubernetes YAML files. Because Kubernetes YAML files are used
to define applications that run within Kubernetes, Podman makes it easy
to move applications to and from a fully orchestrated environment back
to a single node. This feature makes it easier for you to develop
applications that eventually run under Kubernetes or debug problems that
happen under Kubernetes by running these applications locally on your
laptop. Kubernetes YAML is a great alternative to
`docker-compose`{.fm-code-in-text} YAML when running a group of
containers on a single node.

[]{#p3.htm_pgfId-1016267}Chapter 9 introduces the concept of Podman as a
service, which allows tools written to use a RESTful API to generate and
manage pods and containers with Podman. Tools like
`docker-compose`{.fm-code-in-text} and other Python tools built on
docker-py can interface with the Podman service, eliminating the need
for Docker altogether. The Podman service even allows Podman running on
remote systems, such as Windows, macOS, and Linux, to work with Linux
Podman containers.[]{#p3.htm_id_u6n877dddx1z}

[]{#07.htm}

# []{#07.htm_pgfId-1110283}[]{#07.htm_id_sira8yl9f04n}[]{#07.htm_pgfId-1110285}7 Integration with systemd {#07.htm_heading_id_2 .tochead}

[]{#07.htm_pgfId-1110287}This chapter []{#07.htm_marker-1113414}covers

- []{#07.htm_pgfId-1110288 .calibre17}Running systemd within the
  container as the primary process
- []{#07.htm_pgfId-1110289 .calibre17}Generating systemd unit files from
  existing containers
- []{#07.htm_pgfId-1110290 .calibre17}Socket-activated containerized
  services
- []{#07.htm_pgfId-1110292 .calibre17}Using
  `sd-notify`{.fm-code-in-text} containerized
  services[]{#07.htm_marker-1113419 .calibre17}
- []{#07.htm_pgfId-1110293 .calibre17}The advantages of using journald
  as a logging driver and events backend
- []{#07.htm_pgfId-1110294 .calibre17}Using Podman and systemd to manage
  containerized services' life cycles on edge devices

[]{#07.htm_pgfId-1110295}Systemd is the de facto init system for Linux.
Almost every distribution of Linux defaults to systemd as the first
process launched after the kernel, which then launches all of the
services, including the login sessions for the user. Podman embraces the
power of systemd and uses it for starting up lots of its services. When
starting containerized services at boot time, Podman encourages users to
use systemd unit files with Podman commands. Unit files are what systemd
calls its configuration files. Systemd supports a few different types of
unit files, including service files in which you can define a service,
which you would want systemd to manage. A SystemD.socket is another kind
of unit file systemd uses (see section 7.6). The systemd service unit
files are a way to share your containerized service with the world. As
you see in figure 7.1, Podman's []{#07.htm_id_Hlk115164025}fork/exec
model grants systemd the ability to track the processes within a
containerized service.

::: figure
![](images/07-01.png){.calibre18}

[]{#07.htm_pgfId-1118970}Figure 7.1 Systemd executing a Podman container
:::

[]{#07.htm_pgfId-1110304}Systemd puts all the processes within a unit
file service (called a scope[]{#07.htm_marker-1110303}) into the same
cgroup hierarchy. It then uses the PID cgroup to keep track of all the
processes and uses this information to manage the service. Container
engines that use client-server methodology prevent systemd from keeping
track of the containerized processes.

[]{#07.htm_pgfId-1110305}Podman also takes advantage of other services,
as you will see in this chapter, to handle auto-restarting containers,
[]{#07.htm_id_Hlk115164229}auto-updating, and basic management of
containerized services. You will be exposed to many Podman and systemd
features in this chapter, but first you will run systemd within a Podman
container.

## []{#07.htm_pgfId-1110308}7.1 Running systemd within a container {#07.htm_heading_id_3 .fm-head}

[]{#07.htm_pgfId-1110311}When
[]{#07.htm_marker-1110309}[]{#07.htm_marker-1110310}containerization was
first becoming popular, many evangelists taught the concept of
microservices. A *microservice*[]{#07.htm_marker-1110312} is defined as
one specialized service within a container. This single service runs as
the initial PID (PID 1) within the containers and writes its logs
directly to `stdout`{.fm-code-in-text} and `stderr`{.fm-code-in-text}.
Kubernetes assumes microservices, and thus gathers logs from the
`stdin`{.fm-code-in-text}/`stderr`{.fm-code-in-text} of the containers
it runs. Figure 7.2 shows Podman running microservices.

::: figure
![](images/07-02.png){.calibre18}

[]{#07.htm_pgfId-1119015}Figure 7.2 Podman running three microservices
:::

[]{#07.htm_pgfId-1110319}An alternative idea was to run systemd as the
initial PID within the container and then allow systemd to start one or
more services within the container. This school of thought argues that
containerized services are to be launched the same way they are launched
within a VM. Because service package designers (e.g., RPM and APT)
develop systemd unit files as a precise way of launching their services
within the OS, container developers should take advantage of these unit
files. This approach allows running multiple services within the same
container, taking advantage of local communications paths, and speeding
up the conversion of large []{#07.htm_id_Hlk115164558}multiservice
applications into a container and then, over time, breaking each service
into its own microservice.

[]{#07.htm_pgfId-1110321}A final huge advantage of systemd in a
container is that the init system handles the cleaning up of a zombie
process[]{#07.htm_marker-1110322}. In Linux, when a process exits, the
kernel sends the signal
`SIGCHLD`{.fm-code-in-text}[]{#07.htm_marker-1110323} to the parent
process, and the parent process is supposed to collect the exit status
of the exiting process. The kernel removes the process from the system
when the parent reads the exit status. If no parent process reads the
exit status, the exited process is left in the exited status and is
referred to as a *zombie process*[]{#07.htm_marker-1110324}. The init
system, systemd, reaps most processes on the system. In containers, the
initial process running within the container is supposed to reap these
processes. Sometimes container processes exit, and if PID1 does not reap
them, they just linger and never disappear.

[]{#07.htm_pgfId-1110327}[Note]{.fm-callout-head} The
`podman-run`{.fm-code-in-text1} command[]{#07.htm_marker-1110325}
supports an `–init`{.fm-code-in-text1} option[]{#07.htm_marker-1110326},
which will launch a tiny init program just to reap the zombie processes.

[]{#07.htm_pgfId-1110328}Podman was designed to support both
methods---microservices as well as multiservice containers. Figure 7.3
shows systemd running a multiservice application within a container.

::: figure
![](images/07-03.png){.calibre18}

[]{#07.htm_pgfId-1119056}Figure 7.3 Podman running systemd in a
container with three services
:::

[]{#07.htm_pgfId-1110336}Podman examines the `cmd`{.fm-code-in-text}
option[]{#07.htm_marker-1116219} of a container and then launches
systemd for init or system. It then automatically launches the container
in systemd mode.

[]{#07.htm_pgfId-1110337}The following list shows all the commands that
trigger Podman to run in systemd mode:

- []{#07.htm_pgfId-1110338 .calibre17}/sbin/init

- []{#07.htm_pgfId-1110339 .calibre17}/usr/sbin/init

- []{#07.htm_pgfId-1110340 .calibre17}/usr/local/sbin/init

- []{#07.htm_pgfId-1110341 .calibre17}/\*/systemd (any path ending with
  the systemd command)

[]{#07.htm_pgfId-1110342}The registry.access.redhat.com/ubi8-init image
is an example of an image intended to run in systemd mode.

[]{#07.htm_pgfId-1110343}Pull down the ubi8-init image, and examine the
command:

``` programlisting
$ podman pull ubi8-init
Resolved "ubi8-init" as an alias (/etc/containers/registries.conf.d/
➥ 000-shortnames.conf)
Trying to pull registry.access.redhat.com/ubi8-init:latest...
...
8cb83279f877a4bf3412827bf71c53188c3983194bd4663a1fc1378360844463
$ podman inspect ubi8-init --format '{{ .Config.Cmd }}'
[/sbin/init]
```

[]{#07.htm_pgfId-1110352}Systemd requires the environment to be
configured in a certain way; otherwise, systemd attempts to correct the
environment. The next section explains how Podman satisfies systemd
requirements.

### []{#07.htm_pgfId-1110355}7.1.1 Containerized systemd requirements {#07.htm_heading_id_4 .fm-head1}

[]{#07.htm_pgfId-1110358}Systemd
[]{#07.htm_marker-1110356}[]{#07.htm_marker-1110357}makes some
assumptions about the environment it starts in, like /run and /tmp need
to have tmpfs mounted on them. When the environment is incorrect,
systemd attempts to correct it by mounting tmpfs on /run and /tmp.
Mounting requires `CAP_SYS_ADMIN`{.fm-code-in-text} privilege within the
container, which is not allowed in unprivileged containers. Systemd then
blows up.

[]{#07.htm_pgfId-1110359}To fix this problem, after examining the entry
point and `CMD`{.fm-code-in-text} of a container image to see if they
are running systemd, Podman modifies the container environment to match
systemd expectations. When systemd sees the mounts, it skips them,
allowing systemd to run within a locked-down environment. Table 7.1
describes the requirements systemd needs and Podman provides to
successfully run within an unprivileged
[]{#07.htm_marker-1110360}[]{#07.htm_marker-1110361}container.

[]{#07.htm_pgfId-1114353}Table 7.1 Systemd requirements for running
within a nonprivileged container

+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114357}Systemd expectations                       | []{#07.htm_pgfId-1114359}Description                |
+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114361}/run on a tmpfs                            | []{#07.htm_pgfId-1114363}Systemd requires /run to   |
|                                                                     | have a tmpfs mounted on it. If /run is not mounted  |
|                                                                     | with a tmpfs, systemd will attempt to mount a tmpfs |
|                                                                     | on /run. A default locked-down container is         |
|                                                                     | prevented from mounting, so systemd will fail.      |
+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114365}/tmp on a tmpfs                            | []{#07.htm_pgfId-1114367}Similarly to /run, systemd |
|                                                                     | will attempt to mount a tmpfs on /tmp, if there is  |
|                                                                     | not already one mounted there.                      |
+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114369}/var/log/journald as a tmpfs               | []{#07.htm_pgfId-1114371}Systemd within the         |
|                                                                     | container expects to be able to write to            |
|                                                                     | /var/log/journald, so Podman mounts a tmpfs to make |
|                                                                     | this possible.                                      |
+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114373}`container`{.fm-code-in-text1} environment | []{#07.htm_pgfId-1114375}Systemd uses the fact that |
| variable                                                            | a `container`{.fm-code-in-text1} environment        |
|                                                                     | variable is set to change some of its default       |
|                                                                     | behavior, making it run better within a container.  |
+---------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1114377}`STOPSIGNAL=SIGRTMIN+3`{.fm-code-in-text1} | []{#07.htm_pgfId-1114379}Unlike most processes on a |
|                                                                     | system, systemd ignores                             |
|                                                                     | `SIGTERM`{.fm-code-in-text1} and will only cleanly  |
|                                                                     | exit with it when it receives the signal            |
|                                                                     | `SIGRTMIN+3 (37)`{.fm-code-in-text1}.               |
+---------------------------------------------------------------------+-----------------------------------------------------+

### []{#07.htm_pgfId-1110391}7.1.2 Podman container in systemd mode {#07.htm_heading_id_5 .fm-head1}

[]{#07.htm_pgfId-1110395}You
[]{#07.htm_marker-1116574}[]{#07.htm_marker-1116575}[]{#07.htm_marker-1116576}can
examine the environment of a systemd-based container with the
`--systemd =always`{.fm-code-in-text} flag[]{#07.htm_marker-1116578}.
First, launch a container with systemd mode enabled with the
`--systemd=always`{.fm-code-in-text} flag. This option runs the
container in systemd mode even when not running systemd, making it
easier to debug the environment. You can
`exec systemd`{.fm-code-in-text} at this point and start it as PID1:

``` programlisting
$ podman create –rm –name SystemD -ti –systemd=always ubi8-init sh
774a50204204768edd73f178b6afdf975cf9353e3b90af9df77273d639f60ac3
```

[]{#07.htm_pgfId-1110399}Use `podman`{.fm-code-in-text}
`inspect`{.fm-code-in-text} to examine the
`StopSignal`{.fm-code-in-text} for the container; Podman set it to
`37`{.fm-code-in-text} `(SIGRTMIN+3)`{.fm-code-in-text}:

``` programlisting
$ podman inspect SystemD --format '{{ .Config.StopSignal}}'
37
```

[]{#07.htm_pgfId-1110402}Now, start up the container, and look at the
mounts for /run and /tmp; you will see that both are mounted with a
tmpfs. Finally, check to see if the container environment variable is
set:

``` programlisting
$ podman start --attach SystemD
# mount | grep -e /tmp -e /run | head -2
tmpfs on /tmp type tmpfs 
➥ (rw,nosuid,nodev,relatime,context="system_u:object_r:container_file_t:s0:
➥ c37,c965",uid=3267,gid=3267,inode64)
tmpfs on /run type tmpfs 
➥ (rw,nosuid,nodev,relatime,context="system_u:object_r:container_file_t:s
➥ 0:c37,c965",uid=3267,gid=3267,inode64)
# printenv container
Oci
```

[]{#07.htm_pgfId-1110413}If you just run a container based on
`ubi8-init`{.fm-code-in-text}, you will see systemd launched:

``` programlisting
$ podman run -ti ubi8-init
SystemD 239 (239-45.el8_4.3) running in system mode. (+PAM +AUDIT +SELINUX 
➥ +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS 
➥ +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 
➥ default-hierarchy=legacy)
Detected virtualization container-other.
Detected architecture x86-64.
Welcome to Red Hat Enterprise Linux 8.4 (Ootpa)!
Set hostname to <26bbf9077219>.
Initializing machine ID from random generator.
Failed to read AF_UNIX datagram queue length, ignoring: 
➥ No such file or directory
[  OK  ] Listening on initctl Compatibility Named Pipe.
[  OK  ] Reached target Swap.
[  OK  ] Listening on Journal Socket (/dev/log).
[  OK  ] Listening on Journal Socket.
...
```

[]{#07.htm_pgfId-1110431}Here you can notice that systemd ignores
`SIGTERM`{.fm-code-in-text} by pressing Ctrl-C. So to stop this
container you need to go to a different terminal and execute

``` programlisting
# podman stop -l
```

[]{#07.htm_pgfId-1110433}This causes Podman to send the proper
`STOPSIGNAL`{.fm-code-in-text} `(SIGRTMIN+3)`{.fm-code-in-text} to
systemd in the container. Systemd will shut down instantly when it
receives this signal.

[]{#07.htm_pgfId-1110434}Now that you understand what systemd requires,
it is time to create a service systemd will run. In the following
section, you will build a systemd-based Apache service that will run
with systemd within the
[]{#07.htm_marker-1110435}[]{#07.htm_marker-1110436}[]{#07.htm_marker-1110437}container.

### []{#07.htm_pgfId-1110439}7.1.3 Running an Apache service within a systemd container {#07.htm_heading_id_6 .fm-head1}

[]{#07.htm_pgfId-1110443}In
[]{#07.htm_marker-1110440}[]{#07.htm_marker-1110441}[]{#07.htm_marker-1110442}this
section, you will create a Containerfile that uses ubi8-init as the base
image and then install Apache `httpd`{.fm-code-in-text}. Finally, you
will enable this service and set up the Apache script we have been
working with.

[]{#07.htm_pgfId-1110444}Create a Containerfile:

``` programlisting
$ cat << _EOF >  /tmp/Containerfile
FROM ubi8-init
RUN dnf -y install httpd; dnf -y clean all
RUN systemctl enable httpd.service
_EOF
```

[]{#07.htm_pgfId-1110450}Recall that the `FROM`{.fm-code-in-text}
`ubi8-init`{.fm-code-in-text} line will tell Podman to use the ubi8-init
image as the base image for your new image:

``` programlisting
FROM ubi8-init
RUN dnf -y install httpd; dnf -y clean all
RUN systemctl enable httpd.service
```

[]{#07.htm_pgfId-1110454}The `RUN`{.fm-code-in-text}
`dnf`{.fm-code-in-text} `-y`{.fm-code-in-text}
`install`{.fm-code-in-text} `httpd;`{.fm-code-in-text}
`dnf`{.fm-code-in-text} `-y`{.fm-code-in-text} `clean`{.fm-code-in-text}
`all`{.fm-code-in-text} line tells Podman to run a container that
executes the `dnf`{.fm-code-in-text} command[]{#07.htm_marker-1110455}
and install the `httpd`{.fm-code-in-text} package on top of the
`ubi8-init`{.fm-code-in-text} image. The second `dnf`{.fm-code-in-text}
command removes excess files and logs `dnf`{.fm-code-in-text} created
while installing, as there is no reason to include these in the image:

``` programlisting
FROM ubi8-init
RUN dnf -y install httpd; dnf -y clean all
RUN systemctl enable httpd.service
```

[]{#07.htm_pgfId-1110462}The final `RUN`{.fm-code-in-text}
`systemctl`{.fm-code-in-text} `enable`{.fm-code-in-text}
`httpd.service`{.fm-code-in-text} command[]{#07.htm_marker-1110461}
tells Podman to launch another build container and execute the
`systemctl`{.fm-code-in-text} command[]{#07.htm_marker-1110463} to
enable the `httpd`{.fm-code-in-text} `.service`{.fm-code-in-text}. When
systemd runs on a container created from the newly created image, the
`httpd`{.fm-code-in-text} service[]{#07.htm_marker-1110464} will be
started:

``` programlisting
FROM ubi8-init
RUN dnf -y install httpd; dnf -y clean all
RUN systemctl enable httpd.service
```

[]{#07.htm_pgfId-1110468}Now build the image using
`podman`{.fm-code-in-text} `build`{.fm-code-in-text}, and name the image
`my-systemd`{.fm-code-in-text}:

``` programlisting
$ podman build -t my-systemd /tmp
STEP 1/3: FROM ubi8-init
STEP 2/3: RUN dnf -y install httpd; dnf -y clean all
Updating Subscription Management repositories.
Unable to read consumer identity
...
COMMIT my-systemd
--> 104fa99d9a2
Successfully tagged localhost/my-systemd:latest
104fa99d9a2138404039cf15b470ab04784cdaab2226f29bd8343f8e24ec60e2
```

[]{#07.htm_pgfId-1110479}Now run a container on this systemd-based
container image with a volume mounted from the host. Since the default
Apache package listens on port `80`{.fm-code-in-text}, use
`--p`{.fm-code-in-text} `8080:80`{.fm-code-in-text}, which, as you
learned, maps port `8080`{.fm-code-in-text} to port
`80`{.fm-code-in-text} within the container. Use an html folder with
index.html from section 3.1:

``` programlisting
$ podman run -d --rm -p 8080:80 -v ./html:/var/www/html:Z my-systemd
71f1678084390925b7488f68ab58cd55e16009d69b717045b8ed5ef14e8599ce
```

[]{#07.htm_pgfId-1110482}You volume mounted `(-v`{.fm-code-in-text}
`./html/:/var/www/html:Z)`{.fm-code-in-text} in the ./html directory,
with the goodbye world index.html file:

``` programlisting
$ podman run -d --rm -p 8080:80 -v ./html:/var/www/html:Z my-systemd
```

[]{#07.htm_pgfId-1110484}Launch a web browser to check whether the
containerized service is working (as seen in figure 7.4):

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/07-04.png){.calibre18}

[]{#07.htm_pgfId-1119097}Figure 7.4 Web browser window showing
system-based container image running your content
:::

[]{#07.htm_pgfId-1110492}Notice that you did not need to specially
handle the HTTPD server processes when designing the image; your
container is running HTTPD the same way a VM would. If you need to
enable another service within the image, you can easily do this by
installing the package and enabling its unit file.

[]{#07.htm_pgfId-1110494}To see one of the shortcomings of this setup,
you can run the `podman`{.fm-code-in-text} `logs`{.fm-code-in-text}
command[]{#07.htm_marker-1110493}:

``` programlisting
$ podman logs 71f1678084
```

[]{#07.htm_pgfId-1110496}There is no output. Since systemd is running at
the PID1 of the container, it is not writing any output to the logs. You
need to exec into the container and use `journalctl`{.fm-code-in-text}
or read the `httpd`{.fm-code-in-text} logs in /var/log/httpd/error_log
to see if there were any problems. Now that you have seen how to use
systemd within a container, it is time to see how you can use systemd
and Podman to take advantage of advanced
[]{#07.htm_marker-1110497}[]{#07.htm_marker-1110498}[]{#07.htm_marker-1110499}systemd
[]{#07.htm_marker-1110500}[]{#07.htm_marker-1110501}features.

## []{#07.htm_pgfId-1110503}7.2 Journald for logging and events {#07.htm_heading_id_7 .fm-head}

[]{#07.htm_pgfId-1110506}The
[]{#07.htm_marker-1110504}[]{#07.htm_marker-1110505}systemd journal
(journald) is the modern logging system on Linux. It is a system service
that collects and stores logging data. A big advantage of using journald
is that records are permanently stored, and log rotation is built in.
Podman uses journald by default for storing its logging data.

### []{#07.htm_pgfId-1110508}7.2.1 Log driver {#07.htm_heading_id_8 .fm-head1}

[]{#07.htm_pgfId-1110512}Podman
[]{#07.htm_marker-1110509}[]{#07.htm_marker-1110510}[]{#07.htm_marker-1110511}defaults
to using journald as the log driver on systems running with systemd as
the init system. If you run Podman in a container without systemd
running, it falls back to using the file driver. One consideration when
picking a log driver is whether the log data persists when the container
is removed.

[]{#07.htm_pgfId-1110513}A second concern is how large the log file
grows. The log records all `stdout`{.fm-code-in-text} and
`stderr`{.fm-code-in-text} within the container. Containers running for
a very long time can create a lot of log content. Only the journald
driver has log rotation built into it, provided by systemd. If you use
the k8s-file driver there is a risk your system could run out of space.
Table 7.2 shows the available log drivers and whether the log data
persists and the system supports log rotation.

[]{#07.htm_pgfId-1114456}Table 7.2 Log driver options

+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114464}Library  | []{#07.htm_pgfId-1114466}Description | []{#07.htm_pgfId-1114468}Persist     | []{#07.htm_pgfId-1114470}Log         |
|                                   |                                      | logs after container removal         | rotation                             |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114472}Journald | []{#07.htm_pgfId-1114474}Use systemd | []{#07.htm_pgfId-1114476}[✔]{.segoe} | []{#07.htm_pgfId-1114478}[✔]{.segoe} |
|                                   | journal to store logging information |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114480}k8s-file | []{#07.htm_pgfId-1114482}Store       | []{#07.htm_pgfId-1114484}[✘]{.segoe} | []{#07.htm_pgfId-1114486}[✘]{.segoe} |
|                                   | logging data in Kubernetes format    |                                      |                                      |
|                                   | flat file                            |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114488}None     | []{#07.htm_pgfId-1114490}Do not      | []{#07.htm_pgfId-1114492}[✘]{.segoe} | []{#07.htm_pgfId-1114494}[✘]{.segoe} |
|                                   | store any logging information        |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+

[]{#07.htm_pgfId-1110550}While I recommend you use journald for the log
driver, some rootless users are not allowed to use journald, depending
on their system configuration. In other cases, like running Podman
within a container, journald is not available.

[]{#07.htm_pgfId-1110551}You can see the default log driver on your
system by using the following command:

``` programlisting
$ podman info --format '{{ .Host.LogDriver }}'
k8s-file
```

[]{#07.htm_pgfId-1110554}For some reason, the system settings on your
host were set to log to k8s-file. It is simple to override the default
log driver for your system using containers.conf. Create a
log_driver.conf file in the home directory,
\$HOME/.config/containers/containers .conf.d, with the
`log_driver`{.fm-code-in-text} option[]{#07.htm_marker-1110555} set:

``` programlisting
$ mkdir -p $HOME/.config/containers/containers.conf.d
$ cat > $HOME/.config/containers/containers.conf.d/log_driver.conf << _EOF
[containers]
log_driver="journald"
_EOF
$ podman info --format '{{ .Host.LogDriver }}'
journald
```

[]{#07.htm_pgfId-1110563}Great. Next, you will see the benefits of the
journald log driver by launching a container with the
`--rm`{.fm-code-in-text} option to remove the container when it exits:

``` programlisting
$ podman run --rm --name test2 ubi8 echo "Check if logs persist"
Check if logs persist
```

[]{#07.htm_pgfId-1110566}Check that the journal keeps a record of the
container being launched:

``` programlisting
$ journalctl -b | grep "Check if logs persist"
Nov 10 06:19:54 fedora conmon[657915]: Check if logs persist
```

[]{#07.htm_pgfId-1110569}If you had launched with the
`k8s_file`{.fm-code-in-text} option, Podman would have removed the log
file when the container was removed. No log entry would be left behind.
Like logs, Podman supports using the systemd journal to store
[]{#07.htm_marker-1110570}[]{#07.htm_marker-1110571}[]{#07.htm_marker-1110572}events.

### []{#07.htm_pgfId-1110574}7.2.2 Events {#07.htm_heading_id_9 .fm-head1}

[]{#07.htm_pgfId-1110578}Podman
[]{#07.htm_marker-1110575}[]{#07.htm_marker-1110576}[]{#07.htm_marker-1110577}events
record different steps in the container life cycle; for example, you can
see the start event of the last container you ran:

``` programlisting
$ podman events --filter event=start --since 1h
2021-11-10 06:35:06.780429582 -0500 EST container start 
➥ ecf04c4802bb120f34533560fbfc19ab023bcce63d48945ab0e8ff06cc6eeda1
...
```

[]{#07.htm_pgfId-1110583}Examine the default events logger with the
Podman info command:

``` programlisting
$ podman info --format '{{ .Host.EventLogger }}'
journald
```

[]{#07.htm_pgfId-1110588}You can modify the events logger with the
`events_logger`{.fm-code-in-text} option[]{#07.htm_marker-1110587} in
containers.conf similarly to how you did for the
`log_driver`{.fm-code-in-text}. Table 7.3 shows the available events
logging options.

[]{#07.htm_pgfId-1114771}Table 7.3 Events logger options

+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114779}Library  | []{#07.htm_pgfId-1114781}Description | []{#07.htm_pgfId-1114783}Persist log | []{#07.htm_pgfId-1114785}Log         |
|                                   |                                      | data on reboot                       | rotation                             |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114787}Journald | []{#07.htm_pgfId-1114789}The systemd | []{#07.htm_pgfId-1114791}[✔]{.segoe} | []{#07.htm_pgfId-1114793}[✔]{.segoe} |
|                                   | journal will record all events.      |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114795}File     | []{#07.htm_pgfId-1114797}Store       | []{#07.htm_pgfId-1114799}[✘]{.segoe} | []{#07.htm_pgfId-1114801}[✘]{.segoe} |
|                                   | events in a file, usually on /run.   |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1114803}None     | []{#07.htm_pgfId-1114805}Do not      | []{#07.htm_pgfId-1114807}[✘]{.segoe} | []{#07.htm_pgfId-1114809}[✘]{.segoe} |
|                                   | store any events information.        |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+

[]{#07.htm_pgfId-1110625}If your system uses the file event logger, the
events backend file is stored on `$XDG_RUNTIME_DIR`{.fm-code-in-text}
for rootless users, which is on a tmpfs by default. The events backend
file grows continuously, until you reboot the system when using the file
driver. This could cause failures to run containers or the system to run
out of space, since the events backend does not roll over unless you are
using journald. Also, when you reboot, the events log is lost. Switching
to journald preserves the events and handles rotation of the events log.
I recommend you keep the log driver and the events driver the same
values, either as journald, a flat file, or none, if you don't need the
events and logs.

[]{#07.htm_pgfId-1110626}You have examined using systemd within Podman
as well as journald to manage log files and events. Now you will look at
how to set up your system to automatically run a container when the
system comes up
[]{#07.htm_marker-1110627}[]{#07.htm_marker-1110628}[]{#07.htm_marker-1110629}using
[]{#07.htm_marker-1110630}[]{#07.htm_marker-1110631}systemd.

## []{#07.htm_pgfId-1110633}7.3 Starting containers at boot {#07.htm_heading_id_10 .fm-head}

[]{#07.htm_pgfId-1110636}As
[]{#07.htm_marker-1110634}[]{#07.htm_marker-1110635}you learned in
chapter 1, Podman does not run as a daemon, meaning you cannot rely on a
daemon to automatically start containers at boot time. Often you will
need to run containerized services via systemd. Systemd can be
configured to install, run, and manage containerized applications. Many
applications are shipped as container images and will include systemd
service unit files for launching. There are many features provided by
systemd to improve the way containerized services run on your system.

### []{#07.htm_pgfId-1110638}7.3.1 Restarting containers {#07.htm_heading_id_11 .fm-head1}

[]{#07.htm_pgfId-1110642}Podman
[]{#07.htm_marker-1110639}[]{#07.htm_marker-1110640}[]{#07.htm_marker-1110641}relies
on systemd to start containerized services by launching Podman within
systemd unit files. The `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#07.htm_marker-1110643} allows you to
choose whether to restart a container
(`--restart`{.fm-code-in-text}[]{#07.htm_marker-1110644}) if it is not
stopped by a user---for example, if the container crashes or the system
reboots. Table 7.4 shows the restart policies available to Podman.

[]{#07.htm_pgfId-1110645}One simple way systemd helps is by starting
containers with a restart policy of `always`{.fm-code-in-text}. If you
set the `always`{.fm-code-in-text} option[]{#07.htm_marker-1110646} and
the system reboots, Podman uses two systemd services to automatically
restart containers marked with `--restart=always`{.fm-code-in-text}. One
service handles rootful containers, and the other handles all rootless
containers on the system.

[]{#07.htm_pgfId-1115012}Table 7.4 Restart policy

+------------------------------------------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1115018}Option                                        | []{#07.htm_pgfId-1115020}Description | []{#07.htm_pgfId-1115022}Restart on  |
|                                                                        |                                      | boot                                 |
+------------------------------------------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1115024}`no`{.fm-code-in-text1}                       | []{#07.htm_pgfId-1115026}Do not      | []{#07.htm_pgfId-1115028}[✘]{.segoe} |
|                                                                        | restart containers on exit.          |                                      |
+------------------------------------------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1115030}`on-failure[:max_retries]`{.fm-code-in-text1} | []{#07.htm_pgfId-1115032}Restart     | []{#07.htm_pgfId-1115034}[✘]{.segoe} |
|                                                                        | containers when they exit with a     |                                      |
|                                                                        | nonzero exit code, retrying          |                                      |
|                                                                        | indefinitely or until the optional   |                                      |
|                                                                        | `max_retries`{.fm-code-in-text1}     |                                      |
|                                                                        | count is hit.                        |                                      |
+------------------------------------------------------------------------+--------------------------------------+--------------------------------------+
| []{#07.htm_pgfId-1115036}`always`{.fm-code-in-text1} or                | []{#07.htm_pgfId-1115038}Restart     | []{#07.htm_pgfId-1115040}[✔]{.segoe} |
| `unless-stopped`{.fm-code-in-text1}                                    | containers when they exit,           |                                      |
|                                                                        | regardless of status, retrying       |                                      |
|                                                                        | indefinitely.                        |                                      |
+------------------------------------------------------------------------+--------------------------------------+--------------------------------------+

[]{#07.htm_pgfId-1110676}When your system boots up, systemd runs the
following Podman command to start any containers with restart policy set
to
[]{#07.htm_marker-1114978}[]{#07.htm_marker-1114979}[]{#07.htm_marker-1114980}`always`{.fm-code-in-text}:

``` programlisting
/usr/bin/podman start --all --filter restart-policy=always
```

[]{#07.htm_pgfId-1110681}[Note]{.fm-callout-head} Podman ships with two
systemd service files used to restart services---one for rootful and one
for rootless:\
\
[]{#07.htm_pgfId-1110682}/usr/lib/systemd/system/podman-restart.service\
[]{#07.htm_pgfId-1110683}/usr/lib/systemd/user/podman-restart.service\
\
[]{#07.htm_pgfId-1110684}The `--restart=always`{.fm-code-in-text1} works
great, but it requires you to create a container on the system and will
restart containers even if they fail. Systemd was designed to run
services; you will see in the next section that you can easily create a
service unit file with Podman to run your containerized service.

### []{#07.htm_pgfId-1110686}7.3.2 Podman containers as systemd services {#07.htm_heading_id_12 .fm-head1}

[]{#07.htm_pgfId-1110690}As
[]{#07.htm_marker-1110687}[]{#07.htm_marker-1110688}[]{#07.htm_marker-1110689}you
have seen, systemd uses unit files to specify how to run a service.
Figure 7.5 shows how systemd works with Podman to launch a container.

::: figure
![](images/07-05.png){.calibre18}

[]{#07.htm_pgfId-1119135}Figure 7.5 Podman fork/exec architecture is
ideal for systemd service management.
:::

[]{#07.htm_pgfId-1110697}In figure 7.5, I point out that systemd is able
to monitor all the processes running within the systemd unit file. This
allows it to easily start and stop the processes. The
`conmon`{.fm-code-in-text} process[]{#07.htm_marker-1110698} is also
running within the systemd service monitoring the container processes.
`conmon`{.fm-code-in-text} still notices when the container exits, saves
its exit code, and cleanly shuts down the container environment. Systemd
does not know about the container; it only knows about the processes
running within the unit file, including the container processes.

[]{#07.htm_pgfId-1110699}Systemd unit files have many different ways to
run and launch processes, and Podman has many different options for
running containers. Configuring the unit files can be very complex. Many
users have written unit files to run containers, but several have
stumbled over problems when doing so. The most common problem is running
the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
`--detach`{.fm-code-in-text} command[]{#07.htm_marker-1110700} within a
unit file. When the Podman command detaches and exits, systemd assumes
the service is complete and takes it down, even though
`conmon`{.fm-code-in-text} and the container are still running. One of
the most common questions I hear from users is the following: "How
should I run my container within a systemd unit file?"

[]{#07.htm_pgfId-1110701}Podman has a feature to generate unit files
with the best defaults. First, re-create the container from
`myimage`{.fm-code-in-text}, and then use `podman`{.fm-code-in-text}
`systemd`{.fm-code-in-text} `generate`{.fm-code-in-text} to create a
systemd service unit file to manage your container.

[]{#07.htm_pgfId-1110702}Create a container based on the image you
created in chapter 2:

``` programlisting
$ podman create -p 8080:8080 --name myapp quay.io/rhatdan/myimage  
...
8879112805e976b4b6d97c07c9426bdde22ee4ffc7ba4daa59965ae25aa08331
```

[]{#07.htm_pgfId-1110706}Now use Podman to generate a unit file off of
this container:

``` programlisting
$ mkdir -p $HOME/.config/systemd/user
$ podman generate systemd myapp > $HOME/.config/systemd/user/myapp.service
```

[]{#07.htm_pgfId-1110709}Notice in the myapp.service script that Podman
created an `ExecStart`{.fm-code-in-text} field. On service start,
systemd will execute the `ExecStart`{.fm-code-in-text}
command[]{#07.htm_marker-1110710}, which simply starts the container you
created:

``` programlisting
ExecStart=/usr/bin/podman start 8879112805…
```

[]{#07.htm_pgfId-1110713}On service stop, systemd executes the
`ExecStop`{.fm-code-in-text} command[]{#07.htm_marker-1110712} added to
the unit file:

``` programlisting
ExecStop=/usr/bin/podman stop -t 10 8879112805...
Let's take a look at the generated service file: 
$ cat $HOME/.config/systemd/user/myapp.service
# container-8879112805e976b4b6d97c07c9426bdde22ee4ffc7ba4daa59965ae25aa08331.service
# autogenerated by Podman 3.4.1
# Wed Nov 10 08:23:06 EST 2021 
[Unit]
Description=Podman container-8879112805...service
Documentation=man:podman-generate-SystemD(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=/run/user/3267/containers 
[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStart=/usr/bin/podman start 8879112805...
ExecStop=/usr/bin/podman stop -t 10 8879112805...
ExecStopPost=/usr/bin/podman stop -t 10 8879112805...
PIDFile=/run/user/3267/containers/overlay-containers/8879112805.../userdata/conmon.pid
Type=forking
[Install]
WantedBy=multi-user.target default.target
```

[]{#07.htm_pgfId-1110737}To make this all work, you need to tell systemd
to reload its database, so it will notice changes in the unit files:

``` programlisting
$ systemctl --user daemon-reload
```

[]{#07.htm_pgfId-1110739}Start the service with the following command:

``` programlisting
$ systemctl --user start myapp
```

[]{#07.htm_pgfId-1110741}Check to see that the service is running:

``` programlisting
$ systemctl --user status myapp
• myapp.service - Podman container-8879112805....service
   Loaded: loaded (/home/dwalsh/.config/SystemD/user/myapp.service; 
➥ disabled; vendor preset: disabled)
   Active: active (running) since Thu 2021-11-11 07:19:08 EST; 3min 9s ago
...
$ podman ps
CONTAINER ID  IMAGE                             COMMAND           
➥ CREATED     STATUS          PORTS         NAMES
8879112805e9  quay.io/rhatdan/myimage:latest    /usr/bin/run-http...  
➥ 23 hours ago  Up 5 minutes ago  0.0.0.0:8080->8080/tcp  myapp
```

[]{#07.htm_pgfId-1110753}Now you can run the web browser against
localhost port `8080`{.fm-code-in-text} to see it is running (see figure
7.6):

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/07-06.png){.calibre18}

[]{#07.htm_pgfId-1119176}Figure 7.6 Web browser window connecting
`myapp`{.fm-code-in-text}
:::

[]{#07.htm_pgfId-1110761}To shut down the service, execute

``` programlisting
$ systemctl --user stop myapp
```

[]{#07.htm_pgfId-1110763}The ability to generate systemd service files
offers a lot of flexibility to users, and it intentionally blurs the
difference between a container and any other program or service on the
host.

[]{#07.htm_pgfId-1110764}One problem with this unit file is that it's
specific to the container you created. You need to first create the
container and generate specific service files. You are not able to hand
the unit file to another user and have them run your service on their
machine. Luckily, Podman has support for creating a more portable
systemd unit file:
[]{#07.htm_marker-1110765}[]{#07.htm_marker-1110766}[]{#07.htm_marker-1110767}`podman`{.fm-code-in-text}
`generate`{.fm-code-in-text} `systemd`{.fm-code-in-text}
`--new.`{.fm-code-in-text}

### []{#07.htm_pgfId-1110769}7.3.3 Distributing systemd unit files to manage Podman containers {#07.htm_heading_id_13 .fm-head1}

[]{#07.htm_pgfId-1110773}As
[]{#07.htm_marker-1110770}[]{#07.htm_marker-1110771}[]{#07.htm_marker-1110772}shown
previously, the `podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`systemd`{.fm-code-in-text} `command`{.fm-code-in-text} generated a unit
file, which started and stopped an existing container. The
`--new`{.fm-code-in-text} flag[]{#07.htm_marker-1110774} instructs
Podman to generate units that run, stop, and remove containers. Try it
out in the same container:

``` programlisting
$ podman generate systemd --new myapp > $HOME/.config/systemd/user/
➥ myapp-new.service
```

[]{#07.htm_pgfId-1110778}Notice that with the `--new`{.fm-code-in-text}
option,[]{#07.htm_marker-1116820} Podman creates a slightly different
unit file. Examine the following `ExecStart`{.fm-code-in-text}
command[]{#07.htm_marker-1116822}, and you will see the original
`podman`{.fm-code-in-text} `create`{.fm-code-in-text}
`-p`{.fm-code-in-text} `8080:8080`{.fm-code-in-text}
`--name`{.fm-code-in-text} `myapp`{.fm-code-in-text}
`quay.io/rhatdan/myimage`{.fm-code-in-text} command you used to create
the container has been changed to use the `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#07.htm_marker-1116823}. Also notice
that Podman added additional options to make running under systemd
easier `(--cidfile =%t/%n.ctr-id`{.fm-code-in-text}
`--cgroups=no-conmon`{.fm-code-in-text} `--rm`{.fm-code-in-text}
`--sdnotify=conmon`{.fm-code-in-text} `-d`{.fm-code-in-text}
`--replace).`{.fm-code-in-text}

[]{#07.htm_pgfId-1110782}Podman now adds the
`ExecStop`{.fm-code-in-text} command[]{#07.htm_marker-1116824}
(`/usr/bin/podman`{.fm-code-in-text} `stop`{.fm-code-in-text}
`--ignore`{.fm-code-in-text}
`--cidfile=%t/%n.ctr-id`{.fm-code-in-text}), which tells systemd how to
stop the container when someone executes `systemctl`{.fm-code-in-text}
`stop`{.fm-code-in-text} or the system shuts down.

[]{#07.htm_pgfId-1110784}Finally, Podman adds an
`ExecStopPost`{.fm-code-in-text} command[]{#07.htm_marker-1116811}
(`/usr/bin/podman`{.fm-code-in-text} `rm`{.fm-code-in-text}
`-f`{.fm-code-in-text} `--ignore`{.fm-code-in-text}
`--cidfile=%t/%n.ctr-idType=notify`{.fm-code-in-text}), which systemd
executes once the `ExecStop`{.fm-code-in-text}
command[]{#07.htm_marker-1116813} completes. The Podman command removes
the container from the system:

``` programlisting
$ cat $HOME/.config/systemd/user/myapp-new.service
# container-8879112805....service
# autogenerated by Podman 3.4.1
# Thu Nov 11 07:40:34 EST 2021
[Unit]
Description=Podman container-8879112805...service
Documentation=man:podman-generate-SystemD(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=%t/containers
[Service]
Environment=PODMAN_SystemD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStartPre=/bin/rm -f %t/%n.ctr-id
ExecStart=/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon –
➥ rm --sdnotify=conmon -d --replace -p 8080:8080 --name myapp 
➥ quay.io/rhatdan/myimage
ExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id
ExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-idType=notify
NotifyAccess=all
[Install]
WantedBy=multi-user.target default.target
```

[]{#07.htm_pgfId-1110809}You can remove the container and the image from
your system, and when you tell `systemctl`{.fm-code-in-text} to start
the service, Podman will pull the image and create a new container. This
means the myapp-new.service unit file can be shared with a different
user, and when they run the service, Podman will likewise pull the image
and run the container on their systems, without them ever creating the
container in the first place. Table 7.5 shows the different commands
added to the unit file based on whether you used the
`--new`{.fm-code-in-text} flag[]{#07.htm_marker-1110810}.

[]{#07.htm_pgfId-1114037}Table 7.5 Differences between unit files

+------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
| []{#07.htm_pgfId-1114041}Option                      | []{#07.htm_pgfId-1114043}Commands                                                                                   |
+------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
| []{#07.htm_pgfId-1114045}With                        | []{#07.htm_pgfId-1114047}`ExecStart=/usr/bin/podman run ...--cidfile=%t/%n.ctr-id --cgroups=no-`{.fm-code-in-text1} |
| `--new`{.fm-code-in-text1}[]{#07.htm_marker-1114052} |                                                                                                                     |
|                                                      | [➥]{.fm-code-continuation-arrow1}                                                                                   |
|                                                      | `conmon --rm --sdnotify=conmon -d --replace -p 8080:8080 --name`{.fm-code-in-text1}                                 |
|                                                      |                                                                                                                     |
|                                                      | [➥]{.fm-code-continuation-arrow1} `myapp quay.io/rhatdan/myimage`{.fm-code-in-text1}                                |
|                                                      |                                                                                                                     |
|                                                      | `ExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id`{.fm-code-in-text1}                                  |
|                                                      |                                                                                                                     |
|                                                      | `ExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n`{.fm-code-in-text1}                                    |
|                                                      |                                                                                                                     |
|                                                      | [➥]{.fm-code-continuation-arrow1} `.ctr-idType=notify`{.fm-code-in-text1}                                           |
+------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
| []{#07.htm_pgfId-1114049}Without                     | []{#07.htm_pgfId-1114051}`ExecStart=/usr/bin/podman start 8879112805...`{.fm-code-in-text1}                         |
| `--new`{.fm-code-in-text1}                           |                                                                                                                     |
|                                                      | `ExecStop=/usr/bin/podman stop -t 10 8879112805...`{.fm-code-in-text1}                                              |
|                                                      |                                                                                                                     |
|                                                      | `ExecStopPost=/usr/bin/podman stop -t 10 8879112805...`{.fm-code-in-text1}                                          |
+------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+

[]{#07.htm_pgfId-1110837}Once you have your containerized service
running on many machines, you need to think about maintaining it. Podman
has a way to do this without human intervention:
[]{#07.htm_marker-1110838}[]{#07.htm_marker-1110839}[]{#07.htm_marker-1110840}auto-update.

### []{#07.htm_pgfId-1110842}7.3.4 Automatically updating Podman containers {#07.htm_heading_id_14 .fm-head1}

[]{#07.htm_pgfId-1110846}In
[]{#07.htm_marker-1110843}[]{#07.htm_marker-1110844}[]{#07.htm_marker-1110845}chapter
2, we talked about container images aging like stinky cheese. When the
container image gets updated with new software or vulnerability fixes,
you need to reach out to these machines, pull the updated images, and
re-create the containerized services. It is much less labor intensive
when machines manage their own updates.

[]{#07.htm_pgfId-1110847}Imagine you configure a service to run on a
container image on hundreds of nodes. A few months later, you add new
features to the application in the image or, more importantly, a new CVE
is found. Now you need to update the image and then recreate the service
on all of the nodes.

[]{#07.htm_pgfId-1110848}Podman automates this process with auto-update;
each node watches for new images to appear in a container registry. When
the image shows up, the node pulls down the image and re-creates the
container. No human interaction is involved.

[]{#07.htm_pgfId-1110849}Podman auto-update enables you to use Podman in
edge use cases, update workloads once they are connected to the network,
and roll back failures to a known good state. In addition, running
containers is essential for implementing edge computing in remote data
centers or on internet-of-things (IoT) devices. Auto-updates enable you
to use Podman in edge use cases, update workloads once they are
connected to the network, and reduce maintenance costs.

[]{#07.htm_pgfId-1110850}To implement this behavior, Podman requires
containers to have a special label, `--label`{.fm-code-in-text}
`"io.containers.autoupdate=registry"`{.fm-code-in-text}, and the
container must be run in a systemd unit generated by
`podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`systemd`{.fm-code-in-text} `--new`{.fm-code-in-text}. Table 7.6
describes the auto-update modes available.

[]{#07.htm_pgfId-1115092}Table 7.6 Auto-update modes

+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1115096}`io.containers.autoupdate`{.fm-code-in-text} | []{#07.htm_pgfId-1115098}Description                |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1115100}`registry`{.fm-code-in-text1}                | []{#07.htm_pgfId-1115102}Podman connects to the     |
|                                                                       | container registry and checks if a different image  |
|                                                                       | than the one used to create the container is        |
|                                                                       | available; if there is one, Podman will update the  |
|                                                                       | container.                                          |
+-----------------------------------------------------------------------+-----------------------------------------------------+
| []{#07.htm_pgfId-1115104}`local`{.fm-code-in-text1}                   | []{#07.htm_pgfId-1115106}Podman connects to the     |
|                                                                       | container registry but compares local images to the |
|                                                                       | one the container was created with; if they are     |
|                                                                       | different, Podman updates the container.            |
+-----------------------------------------------------------------------+-----------------------------------------------------+

[]{#07.htm_pgfId-1110868}First, stop the systemd service if it is
running, and remove the existing `myapp`{.fm-code-in-text}
container[]{#07.htm_marker-1110867}:

``` programlisting
$ systemctl --user stop myapp-new
$ podman rm myapp --force -t 0
```

[]{#07.htm_pgfId-1110871}Re-create the myapp container with the special
label `"io.containers.autoupdate=registry"`{.fm-code-in-text}:

``` programlisting
$ podman create --label "io.containers.autoupdate=registry" -p 8080:8080 
➥ --name myapp quay.io/rhatdan/myimage 
397ad15601868eb6fd77fe0b67136869cde9e0ffad90ee5095a19de5bb4b999e
```

[]{#07.htm_pgfId-1110875}Re-create the systemd unit file with the
`--new`{.fm-code-in-text} option:

``` programlisting
$ podman generate systemd myapp --new > $HOME/.config/systemd/user/
➥ myapp-new.service
```

[]{#07.htm_pgfId-1110878}Tell systemd the unit file changed by executing
`daemon-reload`{.fm-code-in-text}, and start the service:

``` programlisting
$ systemctl --user daemon-reload
$ systemctl --user start myapp-new
```

[]{#07.htm_pgfId-1110882}The `myapp-new`{.fm-code-in-text}
service[]{#07.htm_marker-1110881} is now ready to be automatically
updated. When you execute the `podman`{.fm-code-in-text}
`auto-update`{.fm-code-in-text} command[]{#07.htm_marker-1110883},
Podman examines running containers for the
`io.containers.autoupdate`{.fm-code-in-text}
label[]{#07.htm_marker-1110884} set to `image`{.fm-code-in-text}. For
each container with that label, Podman reaches out to the container
registry and checks if the image has changed since the container was
created. If the image has changed, Podman restarts the corresponding
systemd unit. Recall that on a systemd restart, the following steps
happen:

1.  []{#07.htm_pgfId-1110886 .calibre17}Systemd stops the service by
    executing the `podman`{.fm-code-in-text} `stop`{.fm-code-in-text}
    command[]{#07.htm_marker-1110885 .calibre17}:

    ``` programlisting
    ExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id
    ```

2.  []{#07.htm_pgfId-1110889 .calibre17}Systemd executes the
    `ExecStopPost`{.fm-code-in-text} script[]{#07.htm_marker-1110888
    .calibre17}. Once the container stops, this script removes the
    container with `podman`{.fm-code-in-text} `rm`{.fm-code-in-text}:

    ``` programlisting
    ExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/
    ➥ %n.ctr-idType=notify
    ```

3.  []{#07.htm_pgfId-1110893 .calibre17}Systemd restarts the services
    with the `podman`{.fm-code-in-text} `run`{.fm-code-in-text}
    command[]{#07.htm_marker-1110892 .calibre17}, including the
    `--label`{.fm-code-in-text}
    `"io.containers.autoupdate=registry"`{.fm-code-in-text} option:

    ``` programlisting
    ExecStart=/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon --rm 
    ➥ --sdnotify=conmon -d --replace --label 
    ➥ io.containers.autoupdate=registry -p 8080:8080 
    ➥ --name myapp quay.io/rhatdan/myimage
    ```

[]{#07.htm_pgfId-1110899}The `podman`{.fm-code-in-text}
`run`{.fm-code-in-text} command[]{#07.htm_marker-1110898} in the third
step will reach out to the registry and pull down the updated container
image and re-create the containerized application on it. The container,
its environment, and all dependencies are restarted.

[]{#07.htm_pgfId-1110900}You can test this by changing your image,
pushing it to a registry, and then running the
`podman`{.fm-code-in-text} `auto-update`{.fm-code-in-text}
command[]{#07.htm_marker-1110901} as follows:

``` programlisting
$ podman exec -i myapp bash -c 'cat > /var/www/html/index.html' << _EOF
<html>
 <head>
 </head>
 <body>
  <h1>Welcome to the new Hello World<h1>
 </body>
</html>
_EOF
```

[]{#07.htm_pgfId-1110911}Now commit the image as
`myimage-new`{.fm-code-in-text}, and push it to the registry with the
original name: `myimage`{.fm-code-in-text}. Finally, remove the image
from the local store to simulate that the image was never on your
system:

``` programlisting
$ podman commit myapp quay.io/rhatdan/myimage-new
...
226ec055eef82ac185c53a26de9e98da4e6403640e72c7461a711edcbcaa2422
$ podman push quay.io/rhatdan/myimage-new quay.io/rhatdan/myimage
...
$ podman rmi quay.io/rhatdan/myimage-new
```

[]{#07.htm_pgfId-1110918}Once the new image is at the registry, and you
have removed it from local storage, you can run
`podman`{.fm-code-in-text} `auto-update`{.fm-code-in-text}, which
notices the new image and restarts the service. This triggers Podman to
pull the new image and re-create the containerized service:

``` programlisting
$ podman auto-update
Trying to pull quay.io/rhatdan/myimage...
Getting image source signatures
Copying blob ecfb9899f4ce done   
Copying config 37e5619f4a done   
Writing manifest to image destination
Storing signatures
UNIT             CONTAINER           IMAGE                
➥ POLICY    UPDATED
myapp-new.service  c8888d1319c4 (myapp)  quay.io/rhatdan/myimage  registry
➥ true
```

[]{#07.htm_pgfId-1110930}Your application has been updated to the latest
version of the image.

[]{#07.htm_pgfId-1110932}Some notable `podman`{.fm-code-in-text}
`auto-update`{.fm-code-in-text} options[]{#07.htm_marker-1110931}
include the following:

- []{#07.htm_pgfId-1110934
  .calibre17}`--dry-run`{.fm-code-in-text}[]{#07.htm_marker-1110933
  .calibre17}---This option is useful to see if any containers need to
  be updated, without actually updating them.

- []{#07.htm_pgfId-1110936
  .calibre17}`--roll-back`{.fm-code-in-text}[]{#07.htm_marker-1110935
  .calibre17}---This option tells Podman to roll back to the previous
  image if the update fails, as covered in the next section.

[]{#07.htm_pgfId-1110938}[]{#07.htm_id_9a7jioh1skx9}systemd timers
trigger Podman updates

[]{#07.htm_pgfId-1110940}Podman []{#07.htm_marker-1110939}ships with two
auto-update systemd timer units and two auto-update service units---one
each for rootful containers and rootless containers. The timer units
triggered by systemd once per day are the following:

- []{#07.htm_pgfId-1110941
  .calibre17}/usr/lib/systemd/system/podman-auto-update.timer

- []{#07.htm_pgfId-1110942
  .calibre17}/usr/lib/systemd/user/podman-auto-update.timer

[]{#07.htm_pgfId-1110943}The timer units tell systemd to execute the
appropriate auto-update service unit file:

- []{#07.htm_pgfId-1110944
  .calibre17}/usr/lib/systemd/system/podman-auto-update.service

- []{#07.htm_pgfId-1110945
  .calibre17}/usr/lib/systemd/user/podman-auto-update.service

[]{#07.htm_pgfId-1110946}With this feature, systemd will launch Podman,
which looks for containers with the
`"io.containers.autoupdate=registry"`{.fm-code-in-text} label, like you
created last section. Once Podman finds a container with the label, it
checks if the container's image has been updated on the registry. If the
image has changed, Podman starts the update process. This means you can
run your systems unattended, and they are updated within 24 hours with
the newest version of the container image every time you push an updated
image to a registry. If you share the unit file you generated with
others, then they also get the auto-updates.

[]{#07.htm_pgfId-1110947}A big concern with auto-update is what happens
if the update is broken. In that case, you will have hundreds of nodes
updated to a broken service. Systemd has a feature called
`sd-notify`{.fm-code-in-text}[]{#07.htm_marker-1117747}, which allows a
service to say its initialization is complete and it is ready to be used
[]{#07.htm_marker-1117748}as
[]{#07.htm_marker-1117749}[]{#07.htm_marker-1117750}[]{#07.htm_marker-1117751}a
[]{#07.htm_marker-1117752}[]{#07.htm_marker-1117753}service.

[]{#07.htm_pgfId-1110955}[Note]{.fm-callout-head} Some of this section
is based on previously written blogs copied and rewritten from the "How
to use auto-updates and rollbacks in Podman" blog
([http://mng.bz/neDK](http://mng.bz/neDK){.url}), written by myself and
coworkers Valentin Rothberg and Preethi Thomas.

## []{#07.htm_pgfId-1110957}7.4 Running containers in notify unit files {#07.htm_heading_id_15 .fm-head}

[]{#07.htm_pgfId-1110961}Unit
[]{#07.htm_marker-1110958}[]{#07.htm_marker-1110959}[]{#07.htm_marker-1110960}file
services can specify that they wait to start until other services are up
and running. For example, you can have a website that relies on a
database to be running before the web service accepts connections.
Systemd usually considers a service started after it launches the
primary process of the service. However, many services take time to
initialize and can't accept connections right away. The database in the
previous example might take minutes before it is ready for the web
service to start receiving connections.

[]{#07.htm_pgfId-1110964}Systemd defines a special service type called
`notify`{.fm-code-in-text}[]{#07.htm_marker-1110962} (or
`sd-notify`{.fm-code-in-text}[]{#07.htm_marker-1110963}) that allows the
service process to notify systemd when it is actually fully up and
running. Systemd starts the web service only when systemd is notified
that the database is ready.

[]{#07.htm_pgfId-1110965}Systemd tells a service that it needs to be
notified that the service is ready by passing the
`NOTIFY_SOCKET`{.fm-code-in-text} environment
variable[]{#07.htm_marker-1110966} pointing to the systemd socket to be
notified. By default, systemd listens on the /run/SystemD/notify socket.
When Podman executes within a `NOTIFY`{.fm-code-in-text} unit file, it
needs to volume mount the socket into the container and pass down the
environment variable into the container (figure 7.7).

::: figure
![](images/07-07.png){.calibre18}

[]{#07.htm_pgfId-1119214}Figure 7.7 Containerized
`sd_notify`{.fm-code-in-text} systemd service launched by Podman
:::

[]{#07.htm_pgfId-1110974}If the service does not notify systemd within
the specified time, systemd will mark the service as failed. Podman
auto-update checks if the new service is fully up and running, and if
the check fails, Podman can automatically roll back to the previous
container---again, without human
[]{#07.htm_marker-1110975}[]{#07.htm_marker-1110976}[]{#07.htm_marker-1110977}intervention.

## []{#07.htm_pgfId-1110978}7.5 Rolling back failed containers after update {#07.htm_heading_id_16 .fm-head}

[]{#07.htm_marker-1110994}[]{#07.htm_pgfId-1110983}If
[]{#07.htm_marker-1110979}[]{#07.htm_marker-1110980}[]{#07.htm_marker-1110981}[]{#07.htm_marker-1110982}your
defined service supports `sd-notify`{.fm-code-in-text} and writes to the
notify socket within the time limit, the `podman`{.fm-code-in-text}
`auto-update`{.fm-code-in-text} command[]{#07.htm_marker-1110984} will
succeed. However, if it fails, Podman will remove the new container and
retag the original image. Finally, it will create the container on the
previous image, and your service will come back up in the previous
state. You could even set up your system-based containerized service to
notify your logging system that the update failed. The rollback gives
you time to figure out what went wrong and ship a new image, triggering
the auto-update again. As you can see, systemd can be used as the
container orchestrator of a single system.

[]{#07.htm_pgfId-1110985} You have now discovered a few nice features
systemd provides for running containers without human intervention. One
additional feature Podman can take advantage of is socket activation,
which allows you to specify a container within a unit file that will not
be running until the first packet comes to its
[]{#07.htm_marker-1118701}[]{#07.htm_marker-1118702}[]{#07.htm_marker-1118703}[]{#07.htm_marker-1118704}socket.

## []{#07.htm_pgfId-1110991}7.6 Socket-activated Podman containers {#07.htm_heading_id_17 .fm-head}

[]{#07.htm_pgfId-1110995}When
[]{#07.htm_marker-1118707}[]{#07.htm_marker-1118708}[]{#07.htm_marker-1118709}systemd
was first introduced, it was lauded for speeding up the boot of a
system. Before systemd, each service started sequentially, and services
that relied on different services to be run needed to wait. To speed up
the boot and get better with resource allocation, systemd uses
*socket-activated services*[]{#07.htm_marker-1118711}. When you set up a
socket-activated service, systemd sets up listening IP or UNIX domain
sockets on behalf of your service, without starting the service (figure
7.8).

::: figure
![](images/07-08.png){.calibre18}

[]{#07.htm_pgfId-1119252}Figure 7.8 Systemd listening on a socket for a
socket-activated container
:::

[]{#07.htm_pgfId-1111003}When a connection to the socket arrives,
systemd activates the service and hands the connection to it.
Afterwards, the service handles connections. The service can at some
point in the future idle itself by exiting. If a new connection comes
in, systemd accepts the new connection and starts the service again.

[]{#07.htm_pgfId-1111004}Socket activation allows systemd to indicate
that a service started instantly, without actually starting or waiting
for the service to start, speeding up the boot process. Socket
activation allows systemd to run more services on the system, since many
services are idle and not using system resources. Basically, your
services can be stopped and only run when they are actually needed and
not sit idle, waiting for another connection. With containerized
services, the main process of the service is Podman, and it needs to
pass the connection down to the service running within the container
(figure 7.9).

::: figure
![](images/07-09.png){.calibre18}

[]{#07.htm_pgfId-1119290}Figure 7.9 When a connection to the socket
systemd is listening on arrives, systemd activates Podman, which
launches the container, passing the socket down to the container.
:::

[]{#07.htm_pgfId-1111011}Shut down the myapp.service, and create the
myapp.socket:

``` programlisting
$ systemctl --user stop myapp.service
$ cat > $HOME/.config/systemd/user/myapp.socket <<_EOF
[Unit]
Description=myapp socket service
PartOf=myapp.service
[Socket]
ListenStream=127.0.0.1:8080
[Install]
WantedBy=sockets.target
_EOF
```

[]{#07.htm_pgfId-1111022}Now, enable the socket, and make sure no
containers are running:

``` programlisting
$ systemctl --user enable --now myapp.socket
$ podman ps
CONTAINER ID  IMAGE     COMMAND   CREATED   STATUS    
➥ PORTS     NAMES
```

[]{#07.htm_pgfId-1111027}Connect a web browser to the socket (see figure
7.10):

``` programlisting
$ web-browser localhost:8080
```

::: figure
![](images/07-10.png){.calibre18}

[]{#07.htm_pgfId-1119328}Figure 7.10 A web browser window connecting to
the `ubi8/httpd-24`{.fm-code-in-text} container running in Podman with
updated Hello World HTML.
:::

[]{#07.htm_pgfId-1111035}Notice that podman.socket started the
podman.service, which created a container to handle the connection:

``` programlisting
$ podman ps
CONTAINER ID  IMAGE                         COMMAND             CREATED
➥ STATUS          PORTS                 NAMES
69c34949d632  quay.io/rhatdan/myimage:latest  /usr/bin/run-http...  
➥ 2 minutes ago  Up 2 minutes ago  0.0.0.0:8080->8080/tcp  myapp
```

[]{#07.htm_pgfId-1111041}Now if you stop the service, not only will the
container be stopped, but it will be removed:

``` programlisting
$ systemctl --user stop myapp.service
$ podman ps -a
CONTAINER ID  IMAGE     COMMAND   CREATED   STATUS    
➥ PORTS     NAMES
```

[]{#07.htm_pgfId-1111046}Socket activation allows you to run the service
only when needed, saving system resources. Later, you can take the
service down, knowing that if a new connection comes in, systemd and
Podman will handle
[]{#07.htm_marker-1111047}[]{#07.htm_marker-1111048}[]{#07.htm_marker-1111049}it.

## []{#07.htm_pgfId-1111051}Summary {#07.htm_heading_id_18 .fm-head}

- []{#07.htm_pgfId-1111052 .calibre17}Podman enables running systemd as
  the primary process within a container.

- []{#07.htm_pgfId-1111053 .calibre17}Journald is recommended for Podman
  logs and events.

- []{#07.htm_pgfId-1111054 .calibre17}Systemd can be used to start and
  restart containers at boot time.

- []{#07.htm_pgfId-1111055 .calibre17}Podman auto-update is used to
  manage the life cycle of a container and its image.

- []{#07.htm_pgfId-1111056 .calibre17}Socket-activated systemd services
  can be used with Podman-based containers.

- []{#07.htm_pgfId-1111057 .calibre17}The `podman`{.fm-code-in-text}
  `generate`{.fm-code-in-text} `systemd`{.fm-code-in-text} command makes
  it easy to generate systemd service files for running your
  []{#07.htm_marker-1111058 .calibre17}containers.

[]{#08.htm}

# []{#08.htm_pgfId-1118666}[]{#08.htm_id_sira8yl9f04n}[]{#08.htm_pgfId-1118668}8 Working with Kubernetes {#08.htm_heading_id_2 .tochead}

[]{#08.htm_pgfId-1118670}This chapter []{#08.htm_marker-1119983}covers

- []{#08.htm_pgfId-1118671 .calibre17}Creating Kubernetes YAML files
  from existing Podman pods and containers
- []{#08.htm_pgfId-1118672 .calibre17}Creating Podman containers and
  pods from a Kubernetes YAML file
- []{#08.htm_pgfId-1118673 .calibre17}Shutting down and removing pods
  and containers using the Kubernetes YAML file
- []{#08.htm_pgfId-1118674 .calibre17}Building container images on the
  fly before launching pods and containers from a Kubernetes YAML file
- []{#08.htm_pgfId-1118675 .calibre17}Running Podman inside of a Podman
  and Kubernetes container

[]{#08.htm_pgfId-1118676}Some readers come to this chapter expecting to
see how Podman can be used as the container engine for Kubernetes,
similar to how it has used Docker in the past. While there have been
some efforts to use Podman as the container engine for Podman (the kind
project supports this), I do not generally recommend that you use Podman
for this purpose. I recommend you use CRI-O described in appendix A,
since it was built specifically to work with Kubernetes and shares the
underlying libraries of Podman. Kubernetes is now discouraging users
from using the Docker backend and encouraging them to use a CRI-O or
containerd as a backend.

[]{#08.htm_pgfId-1118677}This chapter covers using the same structured
language with both Kubernetes and Podman as well as how to run Podman
containers inside a Kubernetes cluster. You have learned how to create
microservices as containers and pods from the command line using Podman.
Often software developers and packagers need to take their applications
and run them on multiple machines. You might want to take your web
application and add a database backend. If the web application becomes
popular, you will need to run multiple instances on different nodes.
Wiring different microservices together and orchestrating all of them
together is not something Podman does. This is where Kubernetes comes
in.

[]{#08.htm_pgfId-1118678}In this chapter, you will learn about running
these same containers and pods in Kubernetes. The kubernetes.io website
says, "Kubernetes, also known as K8s, is an open-source system for
automating deployment, scaling, and management of containerized
applications." I look at Kubernetes as the tool for running containers
on multiple machines at the same time---a way to orchestrate large
clusters of containerized microservices.

[]{#08.htm_pgfId-1118680}One problem you may encounter is that most
container development happens with tools like Podman and Docker, which
use fairly simple command-line interfaces to create containers and pods.
But Kubernetes uses a declarative language written in YAML files.

[]{#08.htm_pgfId-1118681}I will not be diving deep into how Kubernetes
works in this chapter because there are already many in-depth books on
the topic, including *Kubernetes in Action* by Marko
Lukša[]{#08.htm_marker-1118684}[]{#08.htm_marker-1118685} (Manning,
2020) and *Kubernetes for Developers*[]{#08.htm_marker-1118687} by
William Denniss (Manning, 2020), that describe all the features of
Kubernetes. But I will be describing the developer language of
Kubernetes: the Kubernetes YAML file.

[]{#08.htm_pgfId-1118690}[Note]{.fm-callout-head} The yaml.org website
first describes YAML as the "YAML Ain't Markup Language." It further
elaborates, "YAML is a human-friendly data serialization language for
all programming languages."

[]{#08.htm_pgfId-1118691}Translating command-line options to a
structured language like YAML presents a barrier for developers moving
from containers on a single node to containers running at scale. How do
you specify volumes, the image to be used, the security constraints, the
network ports, and so on? In section 8.2, you will learn to use Podman
to take your locally created pods and containers to generate Kubernetes
YAML files from them.

[]{#08.htm_pgfId-1118692}After writing and deploying your application in
a pod using Kubernetes YAML files, users are likely to find problems
with your application running within Kubernetes. Testing the application
at scale can be difficult, and often you just want to run the
application locally on your system, without having to set up and
configure a Kubernetes cluster. In section 8.3, you will learn about
`podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text}. This Podman command allows you to run the
Kubernetes YAML file locally, without Kubernetes, so you can test and
debug problems.

[]{#08.htm_pgfId-1118693}The final part of this chapter will cover
running Podman within containers, including running it within a
Kubernetes cluster. Administrators, developers, and quality engineers
need to test containers within their continuous integration
(CI[]{#08.htm_marker-1118694}) systems using Podman. Often these CI
systems are built on Kubernetes clusters. Section 8.4 teaches you
different ways to run the Podman command within containers launched by
Podman and Kubernetes.

## []{#08.htm_pgfId-1118696}8.1 Kubernetes YAML files {#08.htm_heading_id_3 .fm-head}

[]{#08.htm_pgfId-1118698}The []{#08.htm_marker-1118697}Kubernetes YAML
file is the object used to launch pods and containers within Kubernetes.
In chapter 5, you learned the configuration files used by Podman are
written using TOML, which is very similar to YAML. Both configuration
languages are attempting to be human readable. YAML relies on indenting
substanzas, which is different syntax than you learned with TOML. You
can go to the [yaml.org](http://yaml.org){.url} website to learn more
about the language.

[]{#08.htm_pgfId-1118700}If you are going to work a lot with Kubernetes
YAML files, it is nice to have a text editor or IDE, like Visual Studio
and VS Code, that can at least understand YAML; it is even better if it
knows the Kubernetes language. Kubernetes YAML is descriptive and
powerful. It allows you to model the desired state of your application
in a declarative language. As stated in the introduction to this
chapter, writing these YAML files is a barrier for developers to get
through when moving their containers from a local system to Kubernetes.
Most developers just web search an existing Kubernetes YAML file and
then begin cutting and pasting their container command, image, and
options into the YAML file. While this works, it can lead to unintended
consequences---and often unnecessary work.

[]{#08.htm_pgfId-1118701}Scott McCarty, product manager of Podman,
tossed out an idea: "What I would really like to do is help users get
from Podman to orchestrating their containers with Kubernetes." This led
the Podman developers to create a new Podman command:
[]{#08.htm_marker-1118702}`podman`{.fm-code-in-text}
`generate`{.fm-code-in-text}
`kube`{.fm-code-in-text}[]{#08.htm_marker-1118703}.

## []{#08.htm_pgfId-1118705}8.2 Generating Kubernetes YAML files with Podman {#08.htm_heading_id_4 .fm-head}

[]{#08.htm_pgfId-1118708}Imagine
[]{#08.htm_marker-1118706}[]{#08.htm_marker-1118707}you want to take the
containers you generated in the previous chapters and run them within
Kubernetes. You need to write the Kubernetes YAML file to make this
happen. Where should you start?

[]{#08.htm_pgfId-1118710}In this chapter, you will learn a new command:
`podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`kube`{.fm-code-in-text}[]{#08.htm_marker-1118709}. This Podman command
captures the description of local pods and containers and then
translates them into Kubernetes YAML. This helps you transition to a
more sophisticated orchestration environment like Kubernetes. The
generated Kubernetes YAML file can then be used by Kubernetes commands
to launch your pods and containers into a Kubernetes cluster.

[]{#08.htm_pgfId-1118711}You can re-create the containers or pods
locally using Podman on the command line with the same Podman
`run`{.fm-code-in-text}[]{#08.htm_marker-1118712},
`create`{.fm-code-in-text}[]{#08.htm_marker-1118713}, and
`stop`{.fm-code-in-text} commands[]{#08.htm_marker-1118714} you have
learned in the previous chapters. Using the following commands,
re-create the container you have been working with.

[]{#08.htm_marker-1121704}[]{#08.htm_pgfId-1118715}First, remove the
container if it exists using `podman`{.fm-code-in-text}
`rm`{.fm-code-in-text}. You will introduce a new flag,
`--ignore`{.fm-code-in-text}[]{#08.htm_marker-1118716}, which tells the
`podman`{.fm-code-in-text} `rm`{.fm-code-in-text}
command[]{#08.htm_marker-1118717} not to report errors when the
container does not exist. Then, re-create the container from the command
line:

``` programlisting
$ podman rm -f --ignore myapp
$ podman create -p 8080:8080 --name myapp quay.io/rhatdan/myimage
9305822e6089ca28a1fdbb005c12f57f4a26be273fe5d49a1908eadbcfdcb7d4
```

[]{#08.htm_pgfId-1118722}Now, use the command `podman`{.fm-code-in-text}
`generate`{.fm-code-in-text} `kube`{.fm-code-in-text}
`myapp`{.fm-code-in-text}[]{#08.htm_marker-1118721} to generate the
Kubernetes YAML file. Podman inspects the existing container or pod in
its database for all of the fields required to run the container in
Kubernetes and then populates them in the Kubernetes YAML file:

``` programlisting
$ podman generate kube myapp > myapp.yaml
```

[]{#08.htm_pgfId-1118725}Figure 8.1 shows the result of a
`podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`kube`{.fm-code-in-text} command[]{#08.htm_marker-1118724}.

::: figure
![](images/08-01.png){.calibre18}

[]{#08.htm_pgfId-1123535}Figure 8.1 Shows the generated myapp.yaml file
from the `myapp`{.fm-code-in-text} container[]{#08.htm_marker-1123534}
:::

[]{#08.htm_pgfId-1118733}Examine parts of the YAML file. Understand that
Kubernetes works with pods, even though you created a container,
`podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`kube`{.fm-code-in-text}, that creates a pod specification. Podman names
the pod `myapp-pod`{.fm-code-in-text}[]{#08.htm_marker-1118734} and the
container `myapp`{.fm-code-in-text}[]{#08.htm_marker-1118735} within the
specification, based on the name of the original container:

``` programlisting
metadata:
  creationTimestamp: "2021-11-22T11:57:12Z"
  labels:
    app: myapppod
  name: myapp-pod
spec:
  containers:
  - args:
    - /usr/bin/run-httpd
    image: quay.io/rhatdan/myimage:latest
    name: myapp
```

[]{#08.htm_pgfId-1118747}Notice, in the containers section, that the
image name, quay.io/rhatdan/myimage: latest, is recorded, which tells
Kubernetes where to download the image for the container from. It also
tells Kubernetes the command arguments to start the app within the
container, /usr/bin/run-httpd:

``` programlisting
spec:  
  containers:
  - args:
    - /usr/bin/run-httpd
    image: quay.io/rhatdan/myimage:latest
```

[]{#08.htm_pgfId-1118753}In the same container section, you see that the
Podman ports are recorded, `-p`{.fm-code-in-text}
`8080: 8080`{.fm-code-in-text} `spec`{.fm-code-in-text}:

``` programlisting
  containers:
  - args:
    - /usr/bin/run-httpd
    image: quay.io/rhatdan/myimage:latest
    name: myapp
    ports:
    - containerPort: 8080
    hostPort: 8080
```

[]{#08.htm_pgfId-1118762}Finally, at the end of the containers section,
you see `securityContext`{.fm-code-in-text}, which records that Podman,
by default, drops three additional Linux capabilities:
`CAP_MKNOD`{.fm-code-in-text}[]{#08.htm_marker-1118763},
`CAP_NET_RAW`{.fm-code-in-text}[]{#08.htm_marker-1118764}, and
`CAP_AUDIT_WRITE`{.fm-code-in-text}[]{#08.htm_marker-1118765}:

``` programlisting
    securityContext:
    capabilities:
    drop:
    - CAP_MKNOD
    - CAP_NET_RAW
    - CAP_AUDIT_WRITE
```

[]{#08.htm_pgfId-1118772}Most containers run fine without these Linux
capabilities, but the OCI specification enables these three by default.
This tells Kubernetes that this pod can run more securely without these
capabilities, and Kubernetes will drop them. You can find out more about
Linux capabilities by running the command `man`{.fm-code-in-text}
`capabilities`{.fm-code-in-text}.

[]{#08.htm_pgfId-1118774}At this point, you can just run this Kubernetes
YAML file in any Kubernetes cluster, usually running a command like the
following:

``` programlisting
kubectl create -f myapp.yml
```

[]{#08.htm_pgfId-1118776}Often you will have to add sophistication and
orchestration to the YAML file and leverage advanced functions of
Kubernetes. For example, the generated Kubernetes YAML file will only
generate a single instance of your application. If you want to run
multiple versions of your applications on different nodes, you could add
a `replicas`{.fm-code-in-text} option[]{#08.htm_marker-1118777} to your
YAML file, as seen in figure 8.2.

::: figure
![](images/08-02.png){.calibre18}

[]{#08.htm_pgfId-1123573}Figure 8.2 The modified Kubernetes YAML file
ready to run two replicas
:::

[]{#08.htm_pgfId-1118788}The `replicas`{.fm-code-in-text}
flag[]{#08.htm_marker-1118787} tells Kubernetes that the myapp.yaml file
wants to have two `myapp`{.fm-code-in-text}
pods[]{#08.htm_marker-1118789} running on two different nodes at all
times. Replicas and other advanced Kubernetes features are out of the
scope of Podman. The `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} command[]{#08.htm_marker-1118790} ignores these
fields.

[]{#08.htm_pgfId-1118791}Some notable `podman`{.fm-code-in-text}
`generate`{.fm-code-in-text} `kube`{.fm-code-in-text} options include
the following:

- []{#08.htm_pgfId-1118792 .calibre17}`-f,`{.fm-code-in-text}
  `--filename`{.fm-code-in-text}---This writes output to the specified
  path.

- []{#08.htm_pgfId-1118793 .calibre17} `-s,`{.fm-code-in-text}
  `--service`{.fm-code-in-text}---This generates YAML for a Kubernetes
  service object.

[]{#08.htm_pgfId-1118794}Now that you have generated a Kubernetes YAML
file, it'd be nice to be able to reverse the process. If you had a
Kubernetes YAML file, you may want to generate Podman pods and
[]{#08.htm_marker-1118795}[]{#08.htm_marker-1118796}containers.

## []{#08.htm_pgfId-1118798}8.3 Generating Podman pods and containers from Kubernetes YAML {#08.htm_heading_id_5 .fm-head}

[]{#08.htm_pgfId-1118803}Imagine
[]{#08.htm_marker-1118799}[]{#08.htm_marker-1118800}[]{#08.htm_marker-1118801}[]{#08.htm_marker-1118802}you
get a Kubernetes YAML file and want to examine it running locally. You
could set up a local Kubernetes cluster, but it would be nice if you
could just play the pods locally. Podman provides a command for doing
this. The `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} command[]{#08.htm_marker-1118804} creates pods,
containers, and volumes based on structured Kubernetes YAML files. The
created pods and containers are automatically started. To test this, you
can simply remove the container you created and then run the generated
myapp.yaml file with the following commands:

``` programlisting
$ podman rm -f --ignore myapp
$ podman play kube myapp.yaml
Pod:
b70aedd8105a6915428928a2b33fd7ecede632298088ea25d9db74ba9b16201e
Container:
a4d78fdfa5d8f751aafb06f3782e36a3aaf5b3804ca57694385de2ea1e400fe6
```

[]{#08.htm_pgfId-1118811}Kubernetes only runs pods with containers; it
does not run just containers by themselves. When the
`podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} command[]{#08.htm_marker-1118812} reads the
YAML, file it launches the pod along with the container. Notice in
figure 8.3 that the `play`{.fm-code-in-text}
command[]{#08.htm_marker-1118813} created a Pod with your container
along with the infra containers.

::: figure
![](images/08-03.png){.calibre18}

[]{#08.htm_pgfId-1123611}Figure 8.3 The `myapp-pod`{.fm-code-in-text}
running with the `myapp`{.fm-code-in-text} container and the infra
container
:::

[]{#08.htm_pgfId-1118822}The `podman`{.fm-code-in-text}
`generate`{.fm-code-in-text} `kube`{.fm-code-in-text}
command[]{#08.htm_marker-1118820} creates the pod named
`myapp-pod`{.fm-code-in-text}[]{#08.htm_marker-1118821}, based on the
name within the myapp.yaml file. The names of the containers are
generated by appending the name of the pod to the name of the container:
`myapp-pod-myapp`{.fm-code-in-text}[]{#08.htm_marker-1118823}. If the
YAML file defines additional containers, they need to be labeled
similarly:

``` programlisting
$ cat myapp.yaml
...
  name: myapp-pod
spec:
  containers:
  - args:
    name: myapp
```

[]{#08.htm_pgfId-1118832}You can display the pods running on your system
with the `podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#08.htm_marker-1118831}. Add the
`--ctr-names`{.fm-code-in-text} option[]{#08.htm_marker-1118833} to also
list the containers running within the pod:

``` programlisting
$ podman pod ps --ctr-names
POD ID       NAME      STATUS  CREATED   INFRA ID     NAMES
b70aedd8105a myapp-pod Running 1 day ago b7a276c62c1d 
➥ myapp-pod-myapp ,b70aedd8105a-infra
```

[]{#08.htm_pgfId-1118839}Now examine the two containers running with the
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text}
command,[]{#08.htm_marker-1118838} using the following command:

``` programlisting
$ podman ps
CONTAINER ID  IMAGE                         COMMAND             CREATED   
➥ STATUS          PORTS                 NAMES
b7a276c62c1d  k8s.gcr.io/pause:3.5                                
➥ 3 minutes ago  Up 3 minutes ago  0.0.0.0:8080->8080/tcp  b70aedd8105a-infra
a4d78fdfa5d8  quay.io/rhatdan/myimage:latest  /usr/bin/run-http...  
➥ 3 minutes ago  Up 3 minutes ago  0.0.0.0:8080->8080/tcp myapp-pod-myapp
```

[]{#08.htm_pgfId-1118847}Shut down the Pod and container with the
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`stop`{.fm-code-in-text} command:

``` programlisting
$ podman pod stop myapp-pod
b70aedd8105a6915428928a2b33fd7ecede632298088ea25d9db74ba9b16201e
```

[]{#08.htm_pgfId-1118850}`podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text} can execute much more
complex YAML files, including with multiple pods, volumes, and
containers defined. In the previous simple example, you can just shut
down the pod with the `podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`stop`{.fm-code-in-text} command[]{#08.htm_marker-1118851}, but when
`podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} generates multiple unique pods, it gets a
little more complex to shut them down.

### []{#08.htm_pgfId-1118853}8.3.1 Shutting down pods and containers based on a Kubernetes YAML file {#08.htm_heading_id_6 .fm-head1}

[]{#08.htm_pgfId-1118859}Although
[]{#08.htm_marker-1118854}[]{#08.htm_marker-1118855}[]{#08.htm_marker-1118856}[]{#08.htm_marker-1118857}[]{#08.htm_marker-1118858}you
can stop each pod started by `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}, sometimes you don't
only want to stop the pods and containers but actually remove them from
the system. The `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} `--down`{.fm-code-in-text}
command[]{#08.htm_marker-1118860} tears down the pods that were created
by a previous run of `play`{.fm-code-in-text} `kube`{.fm-code-in-text}.
The pods are stopped and then removed. Any volumes created are left
intact. Shut down the myapp.yaml pod created in the previous example:

``` programlisting
$ podman play kube myapp.yaml --down
Pods stopped:
B70aedd8105a6915428928a2b33fd7ecede632298088ea25d9db74ba9b16201e
Pods removed:
b70aedd8105a6915428928a2b33fd7ecede632298088ea25d9db74ba9b16201e
```

[]{#08.htm_pgfId-1118866}Notice that Podman not only stopped the pod but
also removed it. You can verify the pod is gone with the
`podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`ps`{.fm-code-in-text} command[]{#08.htm_marker-1118867}:

``` programlisting
$ podman pod ps
POD ID     NAME       STATUS     CREATED    INFRA ID    # OF CONTAINERS
```

[]{#08.htm_pgfId-1118870}This leaves you back in a state where you can
run `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} again, which will create fresh pods and
containers:

``` programlisting
$ podman play kube myapp.yaml
Pod:
302b1d2c0048a49ea32c2e6ffa0e0549af199ab2bc32de285eef5da628efe28c
Container:
b9f080dc6e13b4a4c37fa66a9b727dbeb2af30f0c3824044aba8a46eebfe15c5
```

[]{#08.htm_pgfId-1118876}This mimics what happens with Kubernetes
running pods and containers. Kubernetes always creates pods and
containers fresh and tears them down when it completes. The ability to
generate all of the pods and containers from the YAML file and then
remove them with the `--down`{.fm-code-in-text}
flag[]{#08.htm_marker-1118877} is similar to the workflow of
`docker-compose`{.fm-code-in-text}. Podman has the big advantage of
using the same YAML file for running the pods and containers as in a
multinode, orchestrated environment with Kubernetes. One other feature
`docker-compose`{.fm-code-in-text} has is the ability to build the
images defined within the YAML file, which the Podman developers also
added to
[]{#08.htm_marker-1118878}[]{#08.htm_marker-1118879}[]{#08.htm_marker-1118880}[]{#08.htm_marker-1118881}[]{#08.htm_marker-1118882}`podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}.

### []{#08.htm_pgfId-1118884}8.3.2 Building images using Podman and Kubernetes YAML files {#08.htm_heading_id_7 .fm-head1}

[]{#08.htm_pgfId-1118890}Users
[]{#08.htm_marker-1118885}[]{#08.htm_marker-1118886}[]{#08.htm_marker-1118887}[]{#08.htm_marker-1118888}[]{#08.htm_marker-1118889}who
were using `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} as a replacement for
`docker-compose`{.fm-code-in-text} requested Podman to add a feature to
build images, rather than always pull them from a container registry.
While Kubernetes does not support such a feature, Podman developers
decided to add the `--build`{.fm-code-in-text}
flag[]{#08.htm_marker-1118891} to `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}. Because
`podman`{.fm-code-in-text} `build`{.fm-code-in-text} can process
Containerfiles or Dockerfiles, enhancing `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text} was simple.

[]{#08.htm_pgfId-1118892}The idea is to create a containerized
application via a container image that is produced on demand. Normal
Kubernetes workflow requires developers to build the image using
`podman`{.fm-code-in-text} `build`{.fm-code-in-text} and push it to a
container registry using `podman`{.fm-code-in-text}
`push`{.fm-code-in-text}, as you learned in chapter 2. Then you can
retrieve the image from the registry using `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}. The
`podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text} `--build`{.fm-code-in-text} option allows it to
execute `podman`{.fm-code-in-text} `build`{.fm-code-in-text} internally
and generate the image on demand, rather than forcing you to use a
container registry.

[]{#08.htm_pgfId-1118894}[Note]{.fm-callout-head} The
`--build`{.fm-code-in-text1} option[]{#08.htm_marker-1118893} is not
available with the remote Podman client, so you can't use it on Mac or
Windows.

[]{#08.htm_pgfId-1118895}In this example, you are going to re-create the
Containerfile used in section 6.1.3:

``` programlisting
$ cat > ./Containerfile << _EOF
FROM ubi8-init
RUN dnf -y install httpd; dnf -y clean all
RUN systemctl enable httpd.service
_EOF
```

[]{#08.htm_pgfId-1118901}Recall that this Containerfile builds a
container image with systemd running as the init system and the HTTPD
service running and listening on port `80`{.fm-code-in-text}. First,
remove all pods and containers:

``` programlisting
$ podman pod rm --all --force
$ podman rm --all --force
```

[]{#08.htm_pgfId-1118905}Now rebuild the `my-systemd`{.fm-code-in-text}
image[]{#08.htm_marker-1118904}:

``` programlisting
$ podman build -t mysystemd.
STEP 1/3: FROM ubi8-init
STEP 2/3: RUN dnf -y install httpd; dnf -y clean all
Updating Subscription Management repositories.
Unable to read consumer identity
...
Successfully tagged localhost/mysystemd:latest
bb1634ce1457f2eb70f84af33599d211eae64cb5f951e40e91481b6e58b747bf
```

[]{#08.htm_pgfId-1118914}Now re-create a container on the image with the
./html directory (using a code example from section 3.1) mounted into
the container:

``` programlisting
$ podman create --rm -p 8080:80 --name myapp -v ./:/var/www/
➥ html:Z mysystemd
fec6de5716ac246613723a4cc26407005e0bc315affdc62b56883bd94acd795e
```

[]{#08.htm_pgfId-1118918}Now generate the Kubernetes YAML file using
`podman`{.fm-code-in-text} `generate`{.fm-code-in-text}
`kube`{.fm-code-in-text}:

``` programlisting
$ podman generate kube myapp > myapp2.yaml
```

[]{#08.htm_pgfId-1118920}Notice that this time Podman generated the YAML
file with a volumes section for `html`{.fm-code-in-text}:

``` programlisting
$ cat myapp2.yaml
...
spec:
  containers:
  - image: localhost/mysystemd:latest
    ...
    volumeMounts:
    - mountPath: /var/www/html
    name: home-dwalsh-podman-html-host-0
  volumes:
  - hostPath:
    path: /home/dwalsh/podman/html
    type: Directory
    name: home-dwalsh-podman-html-host-0
```

[]{#08.htm_pgfId-1118935}Get back to a fresh environment by removing all
of the pods with the `podman`{.fm-code-in-text} `pod`{.fm-code-in-text}
`rm`{.fm-code-in-text} `--all`{.fm-code-in-text}
`--force`{.fm-code-in-text} command[]{#08.htm_marker-1118936}. Remove
all containers and images using the `podman`{.fm-code-in-text}
`rm`{.fm-code-in-text}[]{#08.htm_marker-1118937} and
`podman`{.fm-code-in-text} `rmi`{.fm-code-in-text}
commands[]{#08.htm_marker-1118938}, so you can start with a clean slate:

``` programlisting
$ podman pod rm --all --force
$ podman rm --all --force
fec6de5716ac246613723a4cc26407005e0bc315affdc62b56883bd94acd795e
$ podman rmi mysystemd
Untagged: localhost/mysystemd:latest
Deleted: bb1634ce1457f2eb70f84af33599d211eae64cb5f951e40e91481b6e58b747bf
Deleted: 70e0c1a7580089420267b5928210ad59fdd555603e647b462159ea94f97946f9
```

[]{#08.htm_pgfId-1118947}The `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}
`--build`{.fm-code-in-text} command[]{#08.htm_marker-1118946} requires
subdirectories matching the image names to exist for images to be built.
Podman examines the Kubernetes YAML file for all images and then looks
for the matching subdirectory. Each directory is treated as a context
directory and should contain a Containerfile or a Dockerfile. Podman
then executes `podman`{.fm-code-in-text} `build`{.fm-code-in-text} on
each subdirectory. Since the YAML file needs the mysystemd image, you
need to create a mysystemd directory and place the Containerfile in the
directory:

``` programlisting
$ mkdir mysystemd
$ mv Containerfile mysystemd/
```

[]{#08.htm_pgfId-1118950}You can now run `podman`{.fm-code-in-text}
`play`{.fm-code-in-text} `kube`{.fm-code-in-text}
`--build`{.fm-code-in-text}, and it will rebuild the container image and
launch the Pod and containers for your application:

``` programlisting
$ podman play kube myapp2.yaml --build
STEP 1/3: FROM ubi8-init
STEP 2/3: RUN dnf -y install httpd; dnf -y clean all
Updating Subscription Management repositories.
...
--> 305bb9b8da1
Successfully tagged localhost/mysystemd:latest
305bb9b8da12db682b0eae93ad492e632d2ba43e03f6a6b68467d7429a8a2664
a container exists with the same name ("myapp") as the pod in your YAML file;
➥ changing podname to myapp-pod
Pod:
30739dd554acfeab66a9767301127bab0fe994461686f45a3a89b137c3954840
Container:
ce633ac4e7a1e4d08e0428a8401fcfc4ac75fbcca4be07bc167add6093a44afa
```

[]{#08.htm_pgfId-1118965}Podman rebuilt the mysystemd image based on the
mysystemd/Containerfile and then generated the
`myapp-pod`{.fm-code-in-text} pod[]{#08.htm_marker-1118966} and the
`myapp`{.fm-code-in-text} container[]{#08.htm_marker-1118967} for your
application, without even reaching out to a container registry.

[]{#08.htm_pgfId-1118968}You can share this YAML file and the mysystemd
directory with other users, and they can build and launch your
application all with Podman. Remember, though, if they wanted to launch
it inside of Kubernetes, you need to push the built image to a container
registry, and then edit the YAML file to point the image to the registry
image. Now that you have been exposed to the integration of Podman with
Kubernetes, I want to explore one last idea: running Podman within
Podman and
[]{#08.htm_marker-1118969}[]{#08.htm_marker-1118970}[]{#08.htm_marker-1118971}[]{#08.htm_marker-1118972}[]{#08.htm_marker-1118973}Kubernetes
[]{#08.htm_marker-1118974}[]{#08.htm_marker-1118975}[]{#08.htm_marker-1118976}[]{#08.htm_marker-1118977}containers.

## []{#08.htm_pgfId-1118979}8.4 Running Podman within a container {#08.htm_heading_id_8 .fm-head}

[]{#08.htm_pgfId-1118982}Running
[]{#08.htm_marker-1118980}[]{#08.htm_marker-1118981}Podman within a
container, or within a Kubernetes cluster, is a common problem. Users
want to be able to test container images and tools within CI/CD systems
using containers. Often, they want to build container images with
`podman`{.fm-code-in-text} `build`{.fm-code-in-text}. Sometimes, they
just want to test a newer version of Podman than has been released
within their distribution.

[]{#08.htm_pgfId-1118983}One challenge with Podman is that it can be
configured in so many different ways that users were looking for best
practices for running Podman within a container. Because of this I,
along with some of my colleagues, decided to create a container image,
quay.io/podman`/`{.fm-code-in-text}stable, which makes it easier to run
Podman within a container. As you understand, Podman can run in two
different modes: rootful and rootless. By default, Podman containers
start as the container root within their user namespace. To help you
understand running Podman within a container, you will first experiment
with running Podman within Podman. Table 8.1 describes the different
ways you can run a container within a container and the capabilities
required to allow the internal Podman to execute a container.

[]{#08.htm_pgfId-1121343}Table 8.1 Requirements for running Podman
within a container

+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+
| []{#08.htm_pgfId-1121351}Host     | []{#08.htm_pgfId-1121353}Container | []{#08.htm_pgfId-1121355}Capabilities                              | []{#08.htm_pgfId-1121357}Explanation |
| mode                              | mode                               |                                                                    |                                      |
+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+
| []{#08.htm_pgfId-1121359}Rootful  | []{#08.htm_pgfId-1121361}Rootful   | []{#08.htm_pgfId-1121363}`CAP_SYS_ADMIN`{.fm-code-in-text1}        | []{#08.htm_pgfId-1121365}Has full    |
|                                   |                                    |                                                                    | access to the host user's namespace  |
+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+
| []{#08.htm_pgfId-1121367}Rootful  | []{#08.htm_pgfId-1121369}Rootless  | []{#08.htm_pgfId-1121371}`CAP_SETUIDCAP_SETGID`{.fm-code-in-text1} | []{#08.htm_pgfId-1121373}Runs in a   |
|                                   |                                    |                                                                    | separate user's namespace based on   |
|                                   |                                    |                                                                    | /etc/subuid and /etc/subgid inside   |
|                                   |                                    |                                                                    | the container                        |
+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+
| []{#08.htm_pgfId-1121375}Rootless | []{#08.htm_pgfId-1121377}Rootful   | []{#08.htm_pgfId-1121379}Namespaced                                | []{#08.htm_pgfId-1121381}Has full    |
|                                   |                                    | `CAP_SYS_ADMIN`{.fm-code-in-text1}                                 | access to the user's user namespace  |
+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+
| []{#08.htm_pgfId-1121383}Rootless | []{#08.htm_pgfId-1121385}Rootless  | []{#08.htm_pgfId-1121387}Namespaced                                | []{#08.htm_pgfId-1121389}Runs in a   |
|                                   |                                    | `CAP_SETUID`{.fm-code-in-text1}, `CAP_SETGID`{.fm-code-in-text1}   | separate user namespace based on     |
|                                   |                                    |                                                                    | /etc/subuid and /etc/subgid inside   |
|                                   |                                    |                                                                    | the container. The user namespace    |
|                                   |                                    |                                                                    | must be a subset of the user         |
|                                   |                                    |                                                                    | namespace in which you are running   |
|                                   |                                    |                                                                    | the Podman command.                  |
+-----------------------------------+------------------------------------+--------------------------------------------------------------------+--------------------------------------+

### []{#08.htm_pgfId-1119032}8.4.1 Running Podman within a Podman container {#08.htm_heading_id_9 .fm-head1}

[]{#08.htm_pgfId-1119035}In
[]{#08.htm_marker-1121493}[]{#08.htm_marker-1121494}the first example,
you will run a rootful Podman within a rootless container. You need to
use the `--privileged`{.fm-code-in-text}
command[]{#08.htm_marker-1121496} because, to run successfully, Podman
needs to be able to mount filesystems. When Podman is run as root,
mounting requires the `CAP_SYS_ADMIN`{.fm-code-in-text}
capability[]{#08.htm_marker-1121497}, which is given by the
`--privileged`{.fm-code-in-text} option[]{#08.htm_marker-1121498}. Try
it out by executing the following command:

``` programlisting
$ podman run --privileged quay.io/podman/stable podman version
Trying to pull quay.io/podman/stable:latest...
Getting image source signatures
Copying blob b1f89b7294d7 done 
...
Version:    4.1.0
API Version:     4.1.0
Go Version:      go1.18.2
Built:      Mon May 30 12:03:28 2022
OS/Arch:    linux/amd64
```

[]{#08.htm_pgfId-1119049}The quay.io/podman/stable image is also
configured to run a rootless Podman within a Podman container. You can
activate this behavior by adding running as the Podman user with the
`--user`{.fm-code-in-text} `podman`{.fm-code-in-text}
option[]{#08.htm_marker-1119050}. In this mode, Podman within the
container needs `CAP_SETUID`{.fm-code-in-text} and
`CAP_SETGID`{.fm-code-in-text} to set up the user namespace. Luckily,
Podman gives this access to containers by default:

``` programlisting
$ podman run --user podman quay.io/podman/stable podman version
```

[]{#08.htm_pgfId-1119052}If you really want to lock the container down,
you can drop all capabilities other than `CAP_SETUID`{.fm-code-in-text}
and `CAP_SETGID`{.fm-code-in-text}, using the
`--cap-drop=all`{.fm-code-in-text} `--cap-add`{.fm-code-in-text}
`CAP_SETUID,CAP_ SETGID`{.fm-code-in-text}
options[]{#08.htm_marker-1122583}:

``` programlisting
$ podman run --cap-drop=all --cap-add CAP_SETUID,CAP_SETGID 
➥ --user podman quay.io/podman/stable podman version
Version:    4.1.0
API Version:     4.1.0
Go Version:      go1.18.2
Built:      Mon May 30 12:03:28 2022
OS/Arch:    linux/amd64
```

[]{#08.htm_pgfId-1119061}These examples, which show how you can run
Podman within a Podman container, can also easily be done with Docker
running Podman within a container.

[]{#08.htm_pgfId-1119063}Note that Docker runs with a seccomp
filter[]{#08.htm_marker-1119062}, which blocks the unshare and mount
system calls. You need to either disable seccomp filtering in Docker---

``` programlisting
docker run –security-opt seccomp=unconfined ...
```

[]{#08.htm_pgfId-1119066}---or run Docker with Podman's seccomp
filters[]{#08.htm_marker-1119065}:

``` programlisting
docker run –security-opt seccomp=/usr/share/containers/seccomp.json ... .
```

[]{#08.htm_pgfId-1119068}In this section, you learned about Podman
integration with Kubernetes. In the next section, you will learn how to
configure Podman to run within a Kubernetes pod or
[]{#08.htm_marker-1119069}[]{#08.htm_marker-1119070}container.

### []{#08.htm_pgfId-1119072}8.4.2 Running Podman within a Kubernetes pod {#08.htm_heading_id_10 .fm-head1}

[]{#08.htm_pgfId-1119075}A
[]{#08.htm_marker-1119073}[]{#08.htm_marker-1119074}common use case for
CI/CD systems is using Podman to run containers within Kubernetes. As
you learned, running Podman within a container requires either
`CAP_SYS_ADMIN`{.fm-code-in-text} for rootful containers or
`CAP_SETUID`{.fm-code-in-text} and `CAP_SETGID`{.fm-code-in-text} to run
in rootless mode. Understand that Podman containers almost always
require more than one UID to run, especially when running
`podman`{.fm-code-in-text} `build`{.fm-code-in-text}. Lots of Podman
problems have been raised by users of Kubernetes attempting to run
Podman in a locked-down Kubernetes container, with only one UID and
without Linux capabilities. These containers are the default for
OpenShift and lots of the cloud-based Kubernetes environments. Running a
container engine like Podman in environments without some Linux
capabilities and access to more than one UID is impossible.

[]{#08.htm_pgfId-1119076}The equivalent version of running rootful
Podman using the quay.io/podman/stable image within a
`privileged`{.fm-code-in-text} Kubernetes
container[]{#08.htm_marker-1119077} can be launched with this Kubernetes
YAML file:

``` programlisting
apiVersion: v1
kind: Pod
metadata:
 name: podman-priv
spec:
 containers:
   - name: priv
     image: quay.io/podman/stable
     args:
       - podman
       - version
     securityContext:
       privileged: true
```

[]{#08.htm_pgfId-1119091}Similarly, you can launch a rootless Podman
within a Kubernetes container by using the following YAML file. Note
that you specify the `runAsUser`{.fm-code-in-text}:
`1000`{.fm-code-in-text} as the UID, not the `podman`{.fm-code-in-text}
user. Kubernetes does not support translating usernames within
containers to UIDs:

``` programlisting
apiVersion: v1
kind: Pod
metadata:
  name: podman-rootless
spec:
  containers:
  - name: rootless
    image: quay.io/podman/stable
    args:
      - podman 
      - version
    securityContext:
      capabilities:
        add:
          - "SETUID"
          - "SETGID"
      runAsUser: 1000
```

[]{#08.htm_pgfId-1119109}[Note]{.fm-callout-head} See the following
articles written by me along with my colleague, Urvashi Mohnani, that
offer many more examples on running Podman within containers:

- []{#08.htm_pgfId-1119110 .calibre17}"How to Use Podman inside of a
  Container" ([http://mng.bz/vXDM](http://mng.bz/vXDM){.url1})

- []{#08.htm_pgfId-1119111 .calibre17}"How to Use Podman inside of
  Kubernetes" ([http://mng.bz/49EV](http://mng.bz/49EV){.url1})

[]{#08.htm_pgfId-1119112}As you can see, it is fairly easy to run Podman
containers within Kubernetes, as long as you understand the Podman
requirements. There is ongoing work within the Kubernetes community to
take advantage of user namespaces, making it easier to run Podman
containers within Kubernetes containers and making them
[]{#08.htm_marker-1119113}[]{#08.htm_marker-1119114}more
[]{#08.htm_marker-1119115}[]{#08.htm_marker-1119116}secure.

## []{#08.htm_pgfId-1119118}Summary {#08.htm_heading_id_11 .fm-head}

- []{#08.htm_pgfId-1119119 .calibre17}The `podman`{.fm-code-in-text}
  `generate`{.fm-code-in-text} `kube`{.fm-code-in-text} command easily
  allows you to move locally running pods and containers into a
  Kubernetes YAML file suitable for running within a Kubernetes cluster.

- []{#08.htm_pgfId-1119120 .calibre17}These YAML files can also be used
  to generate local pods and containers via the
  `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
  `kube`{.fm-code-in-text} command.

- []{#08.htm_pgfId-1119121 .calibre17}The `--down`{.fm-code-in-text}
  option allows `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
  `kube`{.fm-code-in-text} to shut down all pods and containers launched
  by a previous `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
  `kube`{.fm-code-in-text} command.

- []{#08.htm_pgfId-1119122 .calibre17}The `--build`{.fm-code-in-text}
  option allows `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
  `kube`{.fm-code-in-text} to generate the container image defined
  within the Kubernetes YAML file based on a Containerfile/Dockerfile,
  eliminating the need to push the image to a container registry.

- []{#08.htm_pgfId-1119123 .calibre17}`podman`{.fm-code-in-text}
  `play`{.fm-code-in-text} `kube`{.fm-code-in-text} is a suitable
  replacement for `docker-compose`{.fm-code-in-text} because it shares
  the same YAML format as Kubernetes.

- []{#08.htm_pgfId-1119124 .calibre17}Running Podman within Podman and
  Kubernetes containers is possible as long as you understand the Podman
  requirements for running in a locked-down []{#08.htm_marker-1119125
  .calibre17}environment.

[]{#09.htm}

# []{#09.htm_pgfId-1109408}[]{#09.htm_pgfId-1109409}9 Podman as a service {#09.htm_heading_id_2 .tochead}

[]{#09.htm_pgfId-1109411}This chapter []{#09.htm_marker-1116839}covers

- []{#09.htm_pgfId-1109412 .calibre17}Running Podman as a service
- []{#09.htm_pgfId-1109413 .calibre17}Podman service support for two
  REST APIs
- []{#09.htm_pgfId-1109415 .calibre17}Python libraries
  podman-py[]{#09.htm_marker-1116843 .calibre17} and docker-py for
  managing Podman containers
- []{#09.htm_pgfId-1109416 .calibre17}Support for
  `docker-compose`{.fm-code-in-text}
- []{#09.htm_pgfId-1109417 .calibre17}Remote command-line communication
  with the Podman service
- []{#09.htm_pgfId-1109418 .calibre17}Managing SSH communications with
  remote Podman instances

[]{#09.htm_marker-1111843}[]{#09.htm_pgfId-1109419}In previous chapters,
you learned about the Podman command line. The problem with this is
sometimes you want to work with containers from a remote system.
Similarly, you might want to write code in a scripting language to
interact with containers. Docker, being written as a client-server
application, supports a popular remote API, which led to the creation of
libraries written in Python and JavaScript to access the daemon.
Docker-py is a popular Python library used to interact with the Docker
daemon.

[]{#09.htm_pgfId-1109421}Many CI/CD, GUI, and remote management systems
have been built to manage Docker containers. Code editors like Visual
Studio even have built-in plug-ins that talk directly to the Docker API.
Advanced tools like `docker-compose`{.fm-code-in-text} led to a new
programming language that is used to orchestrate multiple containers on
a host by interacting with the Docker daemon.

[]{#09.htm_pgfId-1109423}Podman provides similar features and can be run
as a service. Podman supports running the Podman service in rootless as
well as rootful mode. In this chapter, you will learn about the service
and how to interact with it. You will write a simple program in Python
that uses the docker-py and newer podman-py libraries to interact with
the Podman service. You will learn how to set up remote Docker-based
tools, including `docker-compose`{.fm-code-in-text}, to actually use the
Podman service, with no Docker daemon available.

[]{#09.htm_pgfId-1109429}[Note]{.fm-callout-head} The Podman service is
only supported on Linux. Because the Podman service launches Linux
containers, it only runs on Linux machines. Windows and Mac versions of
Podman communicate with the Podman service over the REST API to launch
containers. For more information on Podman on Mac, see appendix E, and
for Windows, see appendix F.

[]{#09.htm_pgfId-1109431}The Podman command has a
`--remote`{.fm-code-in-text} option[]{#09.htm_marker-1109430} that
allows you to interact with the Podman service, either on the local
machine or, most often, on a remote machine. You will learn to set up
the Podman connections to make interacting with remote services easy and
secure. But first you need to know how to enable the Podman service.

## []{#09.htm_pgfId-1109433}9.1 Introducing the Podman service {#09.htm_heading_id_3 .fm-head}

[]{#09.htm_pgfId-1109435}The []{#09.htm_marker-1115468}Podman project
supports a REST (or RESTful) API. The `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `service`{.fm-code-in-text}
command[]{#09.htm_marker-1115470} creates a listening service that
answers API calls for Podman. The service can be run in rootful or
rootless mode. This command offers an optional argument to specify a URI
on which the Podman service will listen. For example, the unix:///tmp/
podman.sock URI tells Podman to listen on the /tmp/podman.sock UNIX
domain socket. The tcp:localhost:10000 URI socket tells Podman to listen
on TCP socket, port `10000`{.fm-code-in-text}. By default, Podman
listens on a UNIX domain socket under the /run directory (table 9.1).

[]{#09.htm_pgfId-1109438}[Note]{.fm-callout-head} If you are not
familiar with REST API or remote APIs in general, I recommend that you
read "What is a REST API?" by Red Hat:
[https://www.redhat.com/en/topics/api/what-is-a-rest-api](https://www.redhat.com/en/topics/api/what-is-a-rest-api){.url}.

[]{#09.htm_pgfId-1109440}Podman running as a service in this case is
different from having a centralized daemon, like Docker does, in
multiple ways. The biggest difference is that the Podman command can run
without the service and interacts with containers and images created by
the service. Other container tools can interact with the storage and
containers without going through the service. The service also exits
when there are no connections to it. You could even run multiple
services at the same time on the same datastore (although I would not
recommend this). The Docker daemon forces all interaction with
containers and images to go through the daemon. Table 9.1 shows the
default locations where the Podman service listens for incoming
connections.[]{#09.htm_id_b2mt0jexvb3t}

[]{#09.htm_marker-1112574}[]{#09.htm_pgfId-1112127}Table 9.1 Default
locations for the podman.socket

+-----------------------------------+----------------------------------------------------------------------+
| []{#09.htm_pgfId-1112131}Mode     | []{#09.htm_pgfId-1112133}Default location                            |
+-----------------------------------+----------------------------------------------------------------------+
| []{#09.htm_pgfId-1112135}Rootful  | []{#09.htm_pgfId-1112137}unix:///run/podman/podman.sock              |
+-----------------------------------+----------------------------------------------------------------------+
| []{#09.htm_pgfId-1112139}Rootless | []{#09.htm_pgfId-1112141}unix://\$XDG_RUNTIME_DIR/podman/podman.sock |
|                                   |                                                                      |
|                                   | []{#09.htm_pgfId-1112148}example                                     |
|                                   | unix:///run/user/1000/podman/podman.sock)                            |
+-----------------------------------+----------------------------------------------------------------------+

[]{#09.htm_pgfId-1109460}Although the Podman service can be set up to
run on a TCP socket as well, I caution you to be very careful because
there is no authorization or additional security built into the service
to prevent hackers from gaining access. The service relies on the SSH
service to gain remote access to the Podman service, and this approach
is recommended.

[]{#09.htm_pgfId-1109461}The Podman service was designed to run as an
on-demand service, exiting 5 seconds after the last connection. This
time limit avoids a long-running daemon that uses system resources even
when the service is not being used. While the Podman service could
launch a separate process for each connection, this could become a
bottleneck. Try this out by running the following command; after 5
seconds you will see the command exit. If you had active connections to
the service, it would continue to run:

``` programlisting
$ podman system service
```

[]{#09.htm_pgfId-1109464}You can specify the timeout for this exit in
seconds with the `--time`{.fm-code-in-text}
option[]{#09.htm_marker-1109463}. Specifying `--time`{.fm-code-in-text}
`0`{.fm-code-in-text} causes the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `service`{.fm-code-in-text}
command[]{#09.htm_marker-1109465} to run until you stop it. Most users
never interact directly with the Podman system service to activate the
service but rely on systemd services to manage it.

### []{#09.htm_pgfId-1109467}9.1.1 Systemd services {#09.htm_heading_id_4 .fm-head1}

[]{#09.htm_pgfId-1109470}Podman
[]{#09.htm_marker-1117579}[]{#09.htm_marker-1117580}provides multiple
systemd unit files for running Podman as a service. Because Podman was
not designed as a daemon, and the developers did not want to always have
a long-running daemon, they decided to take advantage of systemd socket
activation. This allows the Podman service to be launched as an
on-demand service. Figure 9.1 shows how systemd listens on the Podman
socket and then launches the Podman service when it receives a
connection.

::: figure
![](images/09-01.png){.calibre18}

[]{#09.htm_pgfId-1117624}[]{#09.htm_id_i88bi4plbk5b}Figure 9.1 Podman
service running under systemd
:::

[]{#09.htm_pgfId-1109477}The Podman package provides two podman.socket
unit files: one for rootful Podman and the other for rootless Podman.
Table 9.2 defines the location of the systemd socket files to be used in
rootful and rootless mode.[]{#09.htm_id_fu3h9sxk6mdw}

[]{#09.htm_pgfId-1112621}Table 9.2 Podman socket unit files

+-----------------------------------+----------------------------------------------------------------+
| []{#09.htm_pgfId-1112625}Mode     | []{#09.htm_pgfId-1112627}Systemd socket file                   |
+-----------------------------------+----------------------------------------------------------------+
| []{#09.htm_pgfId-1112629}Rootful  | []{#09.htm_pgfId-1112631}/usr/lib/systemd/system/podman.socket |
+-----------------------------------+----------------------------------------------------------------+
| []{#09.htm_pgfId-1112633}Rootless | []{#09.htm_pgfId-1112635}/usr/lib/systemd/user/podman.socket   |
+-----------------------------------+----------------------------------------------------------------+

[]{#09.htm_pgfId-1109495}These two socket activation services tell
systemd to listen on the default UNIX domain socket listed in table 9.1.
When a process connects to the socket, systemd launches the matching
service, which runs the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `service`{.fm-code-in-text}
command[]{#09.htm_marker-1109496}. Systemd then hands the socket off to
the service. After the Podman service completes the API request, it
waits for another connection. If no connection happens for 5 seconds,
Podman exits, freeing up the resources it was using. If a new connection
comes in, systemd repeats the process and launches a new instance of the
Podman service.

[]{#09.htm_pgfId-1109497}In the rest of this chapter, you will be
interacting with the Podman service, so you need to start running it.
You can enable and start the Podman socket on your machine using the
`--user`{.fm-code-in-text} option[]{#09.htm_marker-1109498}, which tells
systemd to enable the user service (or rootless mode service):

``` programlisting
$ systemctl --user enable podman.socket
Created symlink 
➥ /home/dwalsh/.config/systemd/user/sockets.target.wants/podman.socket → 
➥ /usr/lib/systemd/user/podman.socket. 
$ systemctl --user start podman.socket
```

[]{#09.htm_pgfId-1109505}You can see that the podman.sock has been
created in your `XDG_RUNTIME_DIR`{.fm-code-in-text}:

``` programlisting
$ ls $XDG_RUNTIME_DIR/podman/podman.sock
/run/user/3267/podman/podman.sock
```

[]{#09.htm_pgfId-1109508}At this point, the systemd is listening on the
socket, and there is no Podman process running. When a packet comes into
the service, systemd launches the Podman service process to handle the
connection.

[]{#09.htm_pgfId-1109510}To try out the service, you can run the
following `curl`{.fm-code-in-text} command[]{#09.htm_marker-1109509} to
probe for the version on the Podman service:

``` programlisting
$ curl -s --unix-socket $XDG_RUNTIME_DIR/podman/podman.sock 
➥ http://d/v1.0.0/libpod/version | jq
{
  "Platform": {
  "Name": "linux/amd64/fedora-35"
  },
  "Components": [
  {
    "Name": "Podman Engine",
    "Version": "4.0.0-dev",
    "Details": {
        "APIVersion": "4.0.0-dev",
          "Arch": "amd64",
          "BuildTime": "2022-01-04T13:42:14-05:00",
          "Experimental": "false",
        "GitCommit": "66ffbc845d1f0fd5c29611ac3f09daa24749dc1e-dirty",
        "GoVersion": "go1.16.12",
        "KernelVersion": "5.15.10-200.fc35.x86_64",
        "MinAPIVersion": "3.1.0",
        "Os": "linux"
      }
  },
  {
      "Name": "Conmon",
      "Version": "conmon version 2.0.30, commit: ",
      "Details": {
        "Package": "conmon-2.0.30-2.fc35.x86_64"
      }
  },
  {
      "Name": "OCI Runtime (crun)",
      "Version": "crun version 1.4\ncommit:
3daded072ef008ef0840e8eccb0b52a7efbd165d\nspec: 1.0.0\n+SYSTEMD 
➥ +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +YAJL",
      "Details": {
        "Package": "crun-1.4-1.fc35.x86_64"
    }
  }
  ],
  "Version": "4.0.0-dev",
  "ApiVersion": "1.40",
  "MinAPIVersion": "1.24",
  "GitCommit": "66ffbc845d1f0fd5c29611ac3f09daa24749dc1e-dirty",
  "GoVersion": "go1.16.12",
  "Os": "linux",
  "Arch": "amd64",
  "KernelVersion": "5.15.10-200.fc35.x86_64",
  "BuildTime": "2022-01-04T13:42:14-05:00"
}
```

[]{#09.htm_pgfId-1109563}Now that you have the service running, it's
time to investigate
[]{#09.htm_marker-1109560}[]{#09.htm_marker-1109561}the
[]{#09.htm_marker-1109562}APIs.

## []{#09.htm_pgfId-1109565}9.2 Podman-supported APIs {#09.htm_heading_id_5 .fm-head}

[]{#09.htm_pgfId-1109568}The
[]{#09.htm_marker-1109566}[]{#09.htm_marker-1109567}Podman service
provides two APIs over the same socket (table 9.1). The compatibility
API targets the latest released version of the Docker API, implementing
all endpoints, except the Swarm APIs. The Podman team treats any problem
concerning a difference with the Docker API as a bug. If the API works
against the Docker daemon, it must work against the Podman service.

[]{#09.htm_pgfId-1109569}The Podman Libpod API provides support for
Podman's unique features, such as pods. While it would be great for all
projects to support the native Libpod API, it takes time to transition,
and it may be impossible for older, no-longer-maintained projects based
on the Docker API.

[]{#09.htm_pgfId-1109570}I recommend that all new users of Podman work
with the Libpod API, but if you are using legacy code or want to develop
code that will work with both Podman and Docker, then you should use the
compatibility API. Table 9.3 lists the two different REST APIs provided
by Podman.[]{#09.htm_id_58xsmdggrfxp}

[]{#09.htm_pgfId-1112682}Table 9.3 Podman-supported APIs

+----------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------+
| []{#09.htm_pgfId-1112688}Mode          | []{#09.htm_pgfId-1112690}Description | []{#09.htm_pgfId-1112692}Documentation                                                                                                 |
+----------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------+
| []{#09.htm_pgfId-1112694}Compatibility | []{#09.htm_pgfId-1112696}A           | []{#09.htm_pgfId-1112698}[https://docs.docker.com/engine/api/](https://docs.docker.com/engine/api/){.url}                              |
|                                        | compatibility layer offering support |                                                                                                                                        |
|                                        | for the Docker v1.40 API             |                                                                                                                                        |
+----------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------+
| []{#09.htm_pgfId-1112700}Libpod        | []{#09.htm_pgfId-1112702}A           | []{#09.htm_pgfId-1112704}[https://docs.podman.io/en/latest/\_static/api.html](https://docs.podman.io/en/latest/_static/api.html){.url} |
|                                        | Podman-native Libpod layer           |                                                                                                                                        |
+----------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------+

[]{#09.htm_pgfId-1109595}The easiest way to interact with the remote API
is via the `curl`{.fm-code-in-text} command[]{#09.htm_marker-1109594}.
Examine the list of images available with the `curl`{.fm-code-in-text}
command[]{#09.htm_marker-1109596} and the `jq`{.fm-code-in-text}
command[]{#09.htm_marker-1109597} to pretty-print the JSON code. Also
notice the `libpod`{.fm-code-in-text} field in the URL. This field tells
Podman to use its native API.

[]{#09.htm_pgfId-1109598}Listing 9.1 The default output when connecting
`curl`{.fm-code-in-text} to the Podman socket

``` programlisting
$ curl -s --unix-socket $XDG_RUNTIME_DIR/podman/podman.sock 
➥ http://d/v1.0.0/libpod/images/json | jq 
[
  {
  "Id":
"Sha256:2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae",
  "ParentId": "",
  "RepoTags": [
    "quay.io/rhatdan/myimage:latest"    ❶
  ],
...
  }
]
```

[]{#09.htm_pgfId-1117132}[❶]{.fm-combinumeral} The image you have been
working on

[]{#09.htm_pgfId-1109613}You can also run the Docker API by eliminating
the `libpod`{.fm-code-in-text} field. For this command, you get the same
output because the APIs have the same output:

``` programlisting
$ curl -s --unix-socket $XDG_RUNTIME_DIR/podman/podman.sock 
➥ http://d/v1.0.0/images/json | jq
[
  {
  "Id":
"Sha256:2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae",
  "ParentId": "",
  "RepoTags": [
    "quay.io/rhatdan/myimage:latest"
  ],
...
  }
]
```

[]{#09.htm_pgfId-1109627}An example in which the APIs differ is listing
pods, since Docker does not support the concept of a pod, the
`compat`{.fm-code-in-text} API does not have interfaces for it.

[]{#09.htm_pgfId-1109628}First, create a pod for the test by running the
following command:

``` programlisting
$ podman pod create --name mypod
116291543d5691c597132ec73a428f29f2c1f71a65fdfbaca17eb5440a5d47f6
```

[]{#09.htm_pgfId-1109631}Now, use the Libpod pods or JSON API to see
JSON related to the pod you just created:

``` programlisting
$ curl -s --unix-socket $XDG_RUNTIME_DIR/podman/podman.sock 
➥ http://d/v1.0.0/libpod/pods/json | jq
[
  {
    "Cgroup": "user.slice",
    “Containers": [
      {
      "Id": "8eeceeb4fd6aa3897e05b5361b5c27c6e98bc29707484f95994f49437536599e",
      "Names": "4b10a21c5b8c-infra",
      "Status": "running"
      }
    ],
    "Created": "2022-01-05T06:51:52.604528462-05:00",
    "Id": "4b10a21c5b8c2b4f8a598de1eace7b94918d813055891276c2472df856a7fbc1",
    "InfraId": 
➥ "8eeceeb4fd6aa3897e05b5361b5c27c6e98bc29707484f95994f49437536599e",
    "Name": "test_pod",
    "Namespace": "",
    “Networks": [],
    "Status": "Running",
    "Labels": {}
  },
  {
    "Cgroup": "user.slice",
    "Containers": [
      {
      "Id": "7a7405a31917da7bde01a6000809e0ee12f40b69fc76963d87a8ae254b34d8c7",
      "Names": "e10eb9303705-infra",
      "Status": "configured"
      }
    ],
    "Created": "2022-01-05T09:18:01.648324833-05:00",
    "Id": "e10eb930370592834fc168a7460fabe9b3e0e20a54b48a2bf3236cecd75f8138",
    "InfraId": 
➥ "7a7405a31917da7bde01a6000809e0ee12f40b69fc76963d87a8ae254b34d8c7",
    "Name": "mypod",
    "Namespace": "",
    "Networks": [],
    "Status": "Created",
    "Labels": {}
  }
]
```

[]{#09.htm_pgfId-1109674}If you try the same query against the Docker
API endpoint, it fails with a Not Found error.

``` programlisting
$ curl -s --unix-socket $XDG_RUNTIME_DIR/podman/podman.sock 
➥ http://d/v1.0.0/pods/json
Not Found
```

[]{#09.htm_pgfId-1109678}This is because the Docker API and Docker
itself do not understand pods. While you can do a lot of testing with
the API directly with tools like `curl`{.fm-code-in-text}, it is better
to have higher-level languages to interact with the API, such as
[]{#09.htm_marker-1109679}[]{#09.htm_marker-1109680}Python.

## []{#09.htm_pgfId-1109682}9.3 Python libraries for interacting with Podman {#09.htm_heading_id_6 .fm-head}

[]{#09.htm_pgfId-1109685}Python
[]{#09.htm_marker-1109683}[]{#09.htm_marker-1109684}is arguably the most
popular scripting language on Linux platforms. Almost every Linux system
has Python installed by default. Just like the API, there are two very
similar Python libraries available: the docker-py library, which works
with the compatibility library, and podman-py, which supports the newer
Libpod API. This section uses some Python commands and might require a
limited knowledge of Python but is easy enough for you to follow along
if you have limited experience.

### []{#09.htm_pgfId-1109687}9.3.1 Using docker-py with the Podman API {#09.htm_heading_id_7 .fm-head1}

[]{#09.htm_pgfId-1109691}The
[]{#09.htm_marker-1114805}[]{#09.htm_marker-1114806}[]{#09.htm_marker-1114807}most
popular Python package for interacting with containers is docker-py
([https://github.com/docker/docker-py](https://github.com/docker/docker-py){.url}).
Docker-py is a Python bindings library used originally to communicate
with the Docker daemon. It can also communicate with the Podman
compatibility service. The Docker-py library allows you to run the same
containers as the Podman command, except you can do it from Python.

[]{#09.htm_pgfId-1109692}Thousands of tools and examples built on
docker-py exist and are running in production. These tools have been
used for CI/CD systems as well as GUIs, management tools, and debugging
tools. For these commands, you can use the Podman
`compat`{.fm-code-in-text} API[]{#09.htm_marker-1109693}, which works
fine with docker-py.

[]{#09.htm_pgfId-1109694}Usually, you can install docker-py with
`apt-get`{.fm-code-in-text} or `dnf`{.fm-code-in-text}
`install`{.fm-code-in-text}. It is also available via PyPI. Consult the
install commands for your Linux platform. On RPM-based systems, the
package is called
`python-docker`{.fm-code-in-text}[]{#09.htm_marker-1109695}.

[]{#09.htm_pgfId-1109697}On my Red Hat-based system, I install it using
the following `dnf`{.fm-code-in-text} command[]{#09.htm_marker-1109696}:

``` programlisting
$ sudo dnf install -y python-docker
```

[]{#09.htm_pgfId-1109699}After docker-py is installed, you can start
using it to interact with the Podman service. Imagine you want to build
a Python script to interact with the Podman service to list the
currently available images. Notice I have to reset the
`DockerClient`{.fm-code-in-text} URL to point at the Podman socket. You
might have to modify the location of podman.sock on your system:

``` programlisting
$ cat > images.py << _EOF
import docker
client=docker.DockerClient(base_url='unix:/run/user/1000/podman/podman.sock')
print(client.images.list(all=True))
_EOF
```

[]{#09.htm_pgfId-1109705}Run the images.py script, and see the images
installed on your box:

``` programlisting
$ python images.py
[<Image: 'quay.io/rhatdan/myimage:latest'>, <Image: 'k8s.gcr.io/pause:3.5'>]
```

[]{#09.htm_pgfId-1109708}It is inconvenient to have to fully specify the
path to the Podman socket inside the Python script, but luckily, Docker
tools support a special environment variable called
`DOCKER_HOST`{.fm-code-in-text}[]{#09.htm_marker-1109709}. You can set
`DOCKER_HOST`{.fm-code-in-text} to point at the socket that implements
the Docker API.

[]{#09.htm_pgfId-1109711}First, set the `DOCKER_HOST`{.fm-code-in-text}
environment variable[]{#09.htm_marker-1109710} to point at podman.sock:

``` programlisting
$ export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/podman/podman.sock
```

[]{#09.htm_pgfId-1109714}Now, change the script to use the
`docker.from_env()`{.fm-code-in-text}
function[]{#09.htm_marker-1109713}:

``` programlisting
$ cat > images.py << _EOF
import docker
client=docker.from_env()
print(client.images.list(all=True))
_EOF
```

[]{#09.htm_pgfId-1109721}Run the new script, and you see that it uses
the `DOCKER_HOST`{.fm-code-in-text} environment
variable[]{#09.htm_marker-1109720} to discover the Podman service
socket:

``` programlisting
$ python images.py
[<Image: 'quay.io/rhatdan/myimage:latest'>, <Image: 'k8s.gcr.io/pause:3.5'>]
```

[]{#09.htm_pgfId-1109725}[Note]{.fm-callout-head} On many Linux
distributions, the `podman-docker`{.fm-code-in-text1}
package[]{#09.htm_marker-1109724} is available locally. When you install
this package, it installs a Docker script that redirects Docker commands
to run Podman commands. It also links all of the Docker man pages to
Podman man pages. Finally, it sets up a symbolic link between the
docker.sock and the podman.sock for rootful containers, allowing Docker
tools to use /var/run/podman/podman.sock, with no environment
modifications.

[]{#09.htm_pgfId-1109726}The great thing is that this
`DOCKER_HOST`{.fm-code-in-text} trick can be used with most docker-py
scripts that have been written over the years, and you can easily switch
your scripts from using the Docker daemon to using the Podman service.
If you want to use more advanced Podman features, you need to use the
[]{#09.htm_marker-1109727}[]{#09.htm_marker-1109728}[]{#09.htm_marker-1109729}podman-py
package.

### []{#09.htm_pgfId-1109731}9.3.2 Using podman-py with the Podman API {#09.htm_heading_id_8 .fm-head1}

[]{#09.htm_pgfId-1109735}Podman-py
[]{#09.htm_marker-1109732}[]{#09.htm_marker-1109733}[]{#09.htm_marker-1109734}([https://github.com/containers/podman-py](https://github.com/containers/podman-py){.url}),
like docker-py, is a Python bindings library used to communicate with
the Podman service. The podman-py library is newer than the docker-py
library and supports all of the advanced features of Podman using the
Libpod API.

[]{#09.htm_pgfId-1109736}The Podman Python library uses the default
locations of the podman.sock and connects to it automatically. When run
as non-root, the library connects to the rootless socket located in
/run/user/\$UID/podman/podman.sock. Running Python with the Podman
library as root connects automatically to /run/podman/podman.sock.

[]{#09.htm_pgfId-1109737}Similarly to docker-py, on my system I can
install the podman-py library via the `python-podman`{.fm-code-in-text}
package:

``` programlisting
$ sudo dnf install -y python-podman
Last metadata expiration check: 0:27:40 ago on Sun 19 Jun 2022 02:14:49 PM EDT.
Dependencies resolved.
...
Installed:
  python3-podman-3:4.0.0-1.fc36.noarch
Complete!
```

[]{#09.htm_pgfId-1109745}Now build a functionally similar script,
podman-images.py, using the podman-py library. This time you don't need
to worry about the location of the Podman socket. The podman-py library
connects to the default location:

``` programlisting
$ cat > podman-images.py << _EOF
import podman
client=podman.PodmanClient()
print(client.images.list())
_EOF
```

[]{#09.htm_pgfId-1109751}Run the script, and you will see the same
results as the docker-py example, but this library uses the Libpod API:

``` programlisting
$ python podman-images.py
[<Image: 'quay.io/rhatdan/myimage:latest'>, <Image: 'k8s.gcr.io/pause:3.5'>]
```

[]{#09.htm_pgfId-1109754}If you want to show advanced features, like
information on all the pods in the Podman database, call the
`pod.lists()`{.fm-code-in-text} function[]{#09.htm_marker-1109755}, and
iterate through each pod:

``` programlisting
$ cat >> podman-images.py << _EOF
for i in client.pods.list():
    print(i.attrs)
_EOF
Now the script shows the images as well as information on the pods.
$ python podman-images.py
[<Image: 'quay.io/rhatdan/myimage:latest'>, <Image: 'k8s.gcr.io/pause:3.5'>]
{'Cgroup': 'user.slice', 'Containers': [{'Id': 
➥ 'f8679839c25729eb422d38e505ae3a4b7ffe18942e2f77a997bd388e0f52313e', 
➥ 'Names': '116291543d56-infra', 'Status': 'configured'}], 'Created': 
➥ '2021-12-14T06:44:04.56055485-05:00', 'Id': '116291543d5691c597132ec73a428f29f2c1f71a65fdfbaca17eb5440a5d47f6', 
➥ 'InfraId': 'f8679839c25729eb422d38e505ae3a4b7ffe18942e2f77a997bd388e0f52313e', 
➥ 'Name': 'mypod', 'Namespace': '', 'Networks': None, 'Status': 
➥ 'Created', 'Labels': {}}
```

[]{#09.htm_pgfId-1109770}As you can see with the Python bindings, you
could begin to build a Python version of Podman, which can communicate
with the remote
[]{#09.htm_marker-1109771}[]{#09.htm_marker-1109772}[]{#09.htm_marker-1109773}socket.

### []{#09.htm_pgfId-1109775}9.3.3 Which Python library should you use? {#09.htm_heading_id_9 .fm-head1}

[]{#09.htm_pgfId-1109778}The
[]{#09.htm_marker-1109776}[]{#09.htm_marker-1109777}developers of the
podman-py library based their design on the
docker-py[]{#09.htm_marker-1116555} library to make it easier for
developers to transition. If you want to build an application that works
with Podman and Docker, the only choice is docker-py because podman-py
does not work with Docker. If you want to take advantage of advanced
features of Podman, you have to use podman-py. Podman-py is under heavy
development, but docker-py has a huge installed base. Podman-py works
out of the box with rootful and rootless Podman service, while if you
use docker-py you have to set the `DOCKER_ HOST`{.fm-code-in-text}
environment variable[]{#09.htm_marker-1109779} to point at the
podman.socket. Table 9.4 compares the features of the podman-py and
docker-py libraries to help you understand when to use a particular
library.[]{#09.htm_id_7luw6aqoktk5}

[]{#09.htm_pgfId-1112881}Table 9.4 Podman-py vs. docker-py

+-----------------------------------+--------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1112887}Support  | []{#09.htm_pgfId-1112889}Podman-py   | []{#09.htm_pgfId-1112891}Docker-py   |
+-----------------------------------+--------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1112893}Podman   | []{#09.htm_pgfId-1112895}[✔]{.segoe} | []{#09.htm_pgfId-1112897}[✔]{.segoe} |
| service                           |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1112899}Docker   | []{#09.htm_pgfId-1112901}[✘]{.segoe} | []{#09.htm_pgfId-1112903}[✔]{.segoe} |
| daemon                            |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1112905}Supports | []{#09.htm_pgfId-1112907}[✔]{.segoe} | []{#09.htm_pgfId-1112909}[✘]{.segoe} |
| pods                              |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1112911}Advanced | []{#09.htm_pgfId-1112913}[✔]{.segoe} | []{#09.htm_pgfId-1112915}[✘]{.segoe} |
| Podman features                   |                                      |                                      |
+-----------------------------------+--------------------------------------+--------------------------------------+

[]{#09.htm_pgfId-1109815}Using the low-level Python libraries docker-py
and podman-py for communicating with container engine daemons and
services, engineers developed higher-level tools to orchestrate and
manage containers. The most popular of these
[]{#09.htm_marker-1109816}[]{#09.htm_marker-1109817}is
[]{#09.htm_marker-1109818}[]{#09.htm_marker-1109819}`docker-compose`{.fm-code-in-text}.

## []{#09.htm_pgfId-1109821}9.4 Using docker-compose with the Podman service {#09.htm_heading_id_10 .fm-head}

[]{#09.htm_pgfId-1109824}In []{#09.htm_marker-1109822}the previous
chapters, you have seen how to manage containers with the Podman command
line as well as how to manage multiple containers using Kubernetes YAML
launched with `podman`{.fm-code-in-text} `play`{.fm-code-in-text}
`kube`{.fm-code-in-text}. You were introduced to launching containers
with Kubernetes. In this section, you will work with yet another
orchestration tool, `docker-compose`{.fm-code-in-text}
([https://docs.docker.com/compose](https://docs.docker.com/compose){.url}),
often referred to as just `compose`{.fm-code-in-text}.

[]{#09.htm_pgfId-1109828}`compose`{.fm-code-in-text}[]{#09.htm_marker-1109826}
is one of the most popular tools for launching containers. The
`compose`{.fm-code-in-text} tool[]{#09.htm_marker-1109827} predates
Kubernetes and concentrates on orchestrating multiple containers on a
single node, whereas Kubernetes orchestrates multiple containers on
multiple nodes. `compose`{.fm-code-in-text}, like Kubernetes, uses a
YAML file for its container definitions. One of the reasons
`compose`{.fm-code-in-text} was created was that building complex
command lines to run multiple containers can be complicated. Using a
structured language like YAML makes it easier to support running complex
applications with multiple containers on a single node.

[]{#09.htm_pgfId-1109832}`compose`{.fm-code-in-text} has a huge user
base, and it is likely you might want to run a
`compose`{.fm-code-in-text} YAML file in your infrastructure. If you
don't believe this will happen, you can skip this section.

[]{#09.htm_pgfId-1109834}The `compose`{.fm-code-in-text} tool was
written using docker-py and launches containers by using the Docker REST
API. Since Podman now supports the `compat`{.fm-code-in-text} REST
API[]{#09.htm_marker-1109835}, it also supports using
`docker-compose`{.fm-code-in-text} to launch Podman containers. Because
Podman works in rootless as well as rootful mode, you can even use
`docker-compose`{.fm-code-in-text} to launch rootless Podman containers.

[]{#09.htm_pgfId-1109836}In the rest of this section, you will create a
`compose`{.fm-code-in-text} YAML file just to get a feel for how the
`compose`{.fm-code-in-text} command works with the Podman service. You
first need to install `docker-compose`{.fm-code-in-text}. On my Fedora
system, I can do this with the following command:

``` programlisting
$ sudo dnf -y install docker-compose
```

[]{#09.htm_pgfId-1109838}Make sure the Podman systemd socket-activated
service is running by running the following command:

``` programlisting
$ systemctl –user start podman.socket
```

[]{#09.htm_pgfId-1109840}Verify the system service is running by hitting
the ping endpoint, and see if you get a response. This step needs to be
successful before you can proceed further.

``` programlisting
$ curl -H "Content-Type: application/json" --unix-socket 
➥ $XDG_RUNTIME_DIR/podman/podman.sock http://localhost/_ping
OK
```

[]{#09.htm_pgfId-1109845}Since `docker-compose`{.fm-code-in-text}
supports the `DOCKER_HOST`{.fm-code-in-text} environment
variable[]{#09.htm_marker-1109844}, make sure it is set using this
command:

``` programlisting
$ export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/podman/podman.sock
```

[]{#09.htm_pgfId-1109848}As was stated earlier in this section,
`compose`{.fm-code-in-text}[]{#09.htm_marker-1109847} supports its own
YAML file, which is different than the Kubernetes YAML described in
chapter 8.

[]{#09.htm_pgfId-1109849}First, create a directory called example, and
then navigate into it. Move the html directory you have been using into
the example directory:

``` programlisting
$ mkdir example
$ mv ./html example
$ cd example
```

[]{#09.htm_pgfId-1109853}You need to create the docker-compose.yaml file
in the example directory you have been working in. The YAML file will
create a container called
`myapp`{.fm-code-in-text}[]{#09.htm_marker-1109854} based on quay.io/
rhatdan/myimage:latest. Set up the container to use volumes from the
host ./html directory as well as a built-in volume,
`myapp_vol`{.fm-code-in-text}[]{#09.htm_marker-1109855}, used just for
the example:

``` programlisting
cat > docker-compose.yaml << _EOF
version: "3.7"
services:
  myapp:
    image: quay.io/rhatdan/myimage:latest
    volumes:
      - ./html:/var/www/html
      - myapp_vol:/vol
    ports:
      - 8080:80
volumes:
  myapp_vol: {}
_EOF
```

[]{#09.htm_pgfId-1109869}Now clean up the images and containers you have
on your system to make sure you are starting from a clean slate. Run the
following commands to do that:

``` programlisting
$ podman pod rm --all --force
$ podman rm --all --force
$ podman rmi --all --force
$ podman volume rm --all --force
```

[]{#09.htm_pgfId-1109875}To show how
`compose`{.fm-code-in-text}[]{#09.htm_marker-1109874} interacts with the
Podman service, launch the container with the
`compose`{.fm-code-in-text} command[]{#09.htm_marker-1109876}. Notice
that `compose`{.fm-code-in-text} tells Podman to pull down the image.
Then `compose`{.fm-code-in-text} tells Podman to create a container
named `example_myapp_1`{.fm-code-in-text} along with a volume named
`example_myapp_vol`{.fm-code-in-text}[]{#09.htm_marker-1109877}, which
will be volume mounted into the container along with the ./html
directory.

[]{#09.htm_pgfId-1109878}Listing 9.2 The output of executing
`docker-compose`{.fm-code-in-text} against the Podman socket

``` programlisting
$ docker-compose up
Pulling myapp (quay.io/rhatdan/myimage:latest)...   ❶
59bf1c3509f3: Download complete
c059bfaa849c: Download complete
Creating example_myapp_1 ... done                   ❷
Attaching to example_myapp_1
```

[]{#09.htm_pgfId-1116983}[❶]{.fm-combinumeral} Pulling the myimage image

[]{#09.htm_pgfId-1117011}[❷]{.fm-combinumeral} Creating the
example_myapp_1 container

[]{#09.htm_pgfId-1109887}In a different terminal, run the
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text} command:

``` programlisting
$ podman ps --format "{{.ID}}  {{.Image}}  {{.Ports}}  {{.Names}}"
230fce823ff6  quay.io/rhatdan/myimage:latest  0.0.0.0:8080->80/tcp  
➥ example_myapp_1
```

[]{#09.htm_pgfId-1109891}Now check to see if Podman created a volume:

``` programlisting
$ podman volume ls
DRIVER    VOLUME NAME
local     example_myapp_vol
```

[]{#09.htm_pgfId-1109895}Go back to the original window, and enter
Ctrl-C to stop `docker-compose`{.fm-code-in-text}:

``` programlisting
^CGracefully stopping... (press Ctrl+C again to force)
Stopping example_myapp_1   ... done
```

[]{#09.htm_pgfId-1109898}This will shut down the container:

``` programlisting
$ podman ps --format "{{.ID}}  {{.Image}}  {{.Ports}}  {{.Names}}"
```

[]{#09.htm_pgfId-1109900}If you execute the `podman`{.fm-code-in-text}
`ps`{.fm-code-in-text} `-a`{.fm-code-in-text} command, you will see that
the container still exists but is not running:

``` programlisting
$ podman ps -a --format "{{.ID}}  {{.Image}}  {{.Ports}}  {{.Names}}"
230fce823ff6  docker.io/library/alpine:latest  0.0.0.0:8080->80/tcp  
➥ example_myapp_1
```

[]{#09.htm_pgfId-1109904}Now, if you run
`docker-compose`{.fm-code-in-text} `down`{.fm-code-in-text}, it will
tell Podman to remove the container from the system:

``` programlisting
$ docker-compose down
Removing example_myapp_1 ... done
Removing network example_default
```

[]{#09.htm_pgfId-1109909}Verify all containers are gone with the
`podman`{.fm-code-in-text} `ps`{.fm-code-in-text} `-a`{.fm-code-in-text}
command[]{#09.htm_marker-1109908} again:

``` programlisting
$ podman ps -a --format "{{.ID}}  {{.Image}}  {{.Ports}}  {{.Names}}"
```

[]{#09.htm_marker-1109930}[]{#09.htm_pgfId-1109911}As you can see,
Podman works nicely with `docker-compose`{.fm-code-in-text} to
orchestrate containers.

[]{#09.htm_pgfId-1109912}[Tip]{.fm-callout-head} While
`docker-compose`{.fm-code-in-text1} works nicely with the Podman
service, I think if you are starting a fresh project, it is better to
work with Kubernetes YAML and `podman`{.fm-code-in-text1}
`play`{.fm-code-in-text1} `kube`{.fm-code-in-text1} because this allows
you to more easily move your containers into Kubernetes.

[]{#09.htm_pgfId-1109913}As you have seen, the Podman service is useful
for allowing remote processes to manipulate your pods and containers.
Even the Podman command can be used as a client and communicate with the
Podman []{#09.htm_marker-1109914}[]{#09.htm_marker-1109915}service.

## []{#09.htm_pgfId-1109917}9.5 podman - -remote {#09.htm_heading_id_11 .fm-head}

[]{#09.htm_pgfId-1109920}As
[]{#09.htm_marker-1109918}[]{#09.htm_marker-1109919}you scale out
applications, you probably want to run your containerized applications
on multiple machines. You could `ssh`{.fm-code-in-text} into each box
and run Podman commands locally to manage the environment, or you could
write code to use the Python library described in section 9.4. The
Podman developers also built client support into the Podman command. You
can use the `podman`{.fm-code-in-text} command[]{#09.htm_marker-1109921}
to directly connect to these remote Podman services and manage the
container environment on the remote machines.

[]{#09.htm_pgfId-1109923}The Podman command has a special option,
`--remote`{.fm-code-in-text}[]{#09.htm_marker-1117659}, allowing it to
communicate with the socket-activated Podman service. Instead of
executing the commands and containers as a child of the Podman process,
it communicates with the service over the REST API.

::: figure
![](images/09-02.png){.calibre18}

[]{#09.htm_pgfId-1117688}[]{#09.htm_id_y3fj7xwuq1cf}Figure 9.2
`podman`{.fm-code-in-text} `--remote`{.fm-code-in-text} connecting to
local podman.socket
:::

[]{#09.htm_pgfId-1109931}Because Podman is a tool for running Linux
containers, the `complete`{.fm-code-in-text} `podman`{.fm-code-in-text}
command[]{#09.htm_marker-1117669} can only be run on Linux. The Podman
developers wanted to support other operating systems, at least in client
mode. To support running Podman on non-Linux machines, Podman can be
built in two different ways. Up until now, you have been working with
the fully fledged Podman, which has the `--remote`{.fm-code-in-text}
option[]{#09.htm_marker-1117670}. The Podman executable can be compiled
with only support for communicating with the Podman service. Podman
built this way is often called `podman-remote`{.fm-code-in-text}. The
`podman-remote`{.fm-code-in-text} command[]{#09.htm_marker-1117671} is
the command that is shipped on some operating systems, like Mac and
Windows (covered more fully in appendixes E and F). If you have been
testing Podman on a Mac or Windows machine while reading this book, then
you have already been using `podman-remote`{.fm-code-in-text}, which
transparently communicates with the Podman service running in a VM or on
a different machine.

### []{#09.htm_pgfId-1109935}9.5.1 Local connections {#09.htm_heading_id_12 .fm-head1}

[]{#09.htm_pgfId-1109941}[]{#09.htm_id_vtahb6ww8z16}As[]{#09.htm_marker-1115139}[]{#09.htm_marker-1115140}[]{#09.htm_marker-1115141}
previously mentioned, the `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} command[]{#09.htm_marker-1115154} connects,
by default, to the local podman.socket, referred to as a local
connection (figure 9.2). Try out `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} with the Podman system service you enabled
in section 9.1.1. Notice how the `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} version shows you the version of the Podman
client as well as the Podman server; in this case, they are the same
executable.

[]{#09.htm_pgfId-1109942}Listing 9.3 The output of
`podman`{.fm-code-in-text} `--remote`{.fm-code-in-text} executing the
version API

``` programlisting
$ podman --remote version
Client:
Version:      4.1.0        ❶
API Version:  4.1.0
Go Version:   go1.18.2
Built:        Sun Jun 19 07:35:42 2022
OS/Arch:      linux/amd64
Server:
Version:      4.1.0        ❷
API Version:  4.1.0
Go Version:   go1.18.2
Git Commit:   a2b78b627f0a9deef83a5b5e4ecffc9cdb5a72b1-dirty
Built:        Sun Jun 19 07:35:42 2022
OS/Arch:      linux/amd64
```

[]{#09.htm_pgfId-1116895}[❶]{.fm-combinumeral} Client version of Podman

[]{#09.htm_pgfId-1116896}[❷]{.fm-combinumeral} Server version of Podman

[]{#09.htm_pgfId-1109959}You can use the exact same commands to start
the container:

``` programlisting
$ podman --remote run ubi8 echo hi
Resolved "ubi8" as an alias (/etc/containers/registries.conf.d/
➥ 000-shortnames.conf)
Trying to pull registry.access.redhat.com/ubi8:latest...
..
hi
```

[]{#09.htm_pgfId-1109967}[]{#09.htm_id_aphjd9kd4zks}As you can imagine,
it is not that useful in this mode, since you can run Podman without the
`--remote`{.fm-code-in-text} optio[]{#09.htm_marker-1109968}n and manage
the same container environment. Local connections are mainly used for
testing of the API, especially in continuous integration
([]{#09.htm_marker-1109969}CI) systems. `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} becomes much more interesting when you use
it to communicate with truly
remo[]{#09.htm_marker-1109970}[]{#09.htm_marker-1109971}[]{#09.htm_marker-1109972}te
machines.

### []{#09.htm_pgfId-1109974}9.5.2 Remote connections {#09.htm_heading_id_13 .fm-head1}

[]{#09.htm_pgfId-1109978}The
[]{#09.htm_marker-1112090}[]{#09.htm_marker-1112091}[]{#09.htm_marker-1112092}main
purpose of the `podman`{.fm-code-in-text} `--remote`{.fm-code-in-text}
command is allowing you to manipulate pods and containers on a separate
machine using the Podman service. Install Podman on a Linux machine or
VM, which also has the SSH daemon running. On the local operating
system, when you run a Podman command, Podman connects to the server via
SSH. It then connects to the Podman service by using systemd socket
activation and communicating with our REST API, as shown in figure
9.3.[]{#09.htm_id_x2sukq7nfn9t}[]{#09.htm_id_xehzr5i0ipj2}[]{#09.htm_id_b0mmeax3hyir}[]{#09.htm_id_u61su794t7r7}[]{#09.htm_id_h07up9l04rih}[]{#09.htm_id_w7f0w92kjs8q}

::: figure
![](images/09-03.png){.calibre18}

[]{#09.htm_pgfId-1117726}Figure 9.3 `podman --remote`{.fm-code-in-text}
connecting over SSH to the server machine
:::

[]{#09.htm_pgfId-1109991}The command-line interface of Podman with the
`--remote`{.fm-code-in-text} option[]{#09.htm_marker-1116001} is exactly
the same as the regular Podman commands. When you run the Podman
commands, it feels like you are running the containers locally; however,
the container processes are running on the remote machine. There are a
few options that are not supported in remote mode, listed in table
9.5.[]{#09.htm_id_deb3mbem3z0l}

[]{#09.htm_pgfId-1113372}Table 9.5 Options not supported by the
`podman --remote`{.fm-code-in-text} command

+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113376}Options                                                                | []{#09.htm_pgfId-1113378}Explanation                |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113380} `--env-host`{.fm-code-in-text1}[]{#09.htm_marker-1116014}             | []{#09.htm_pgfId-1113382}The environment on two     |
|                                                                                                 | different machines makes little sense to share; in  |
|                                                                                                 | some cases these can be two different operating     |
|                                                                                                 | systems, like Windows and Macs talking to a Linux   |
|                                                                                                 | Podman service.                                     |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113384}`--group-add=keep-groups`{.fm-code-in-text1}[]{#09.htm_marker-1116020} | []{#09.htm_pgfId-1113386}The                        |
|                                                                                                 | `--group-add`{.fm-code-in-text1} option works in    |
|                                                                                                 | `--remote`{.fm-code-in-text1} mode, but the         |
|                                                                                                 | `keep-groups`{.fm-code-in-text1} special flag does  |
|                                                                                                 | not. The `keep-groups`{.fm-code-in-text1} flag      |
|                                                                                                 | tells Podman to leak the groups that the current    |
|                                                                                                 | process has access to into the container. Since     |
|                                                                                                 | this is a client-server procedure, the leaking is   |
|                                                                                                 | impossible.                                         |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113388}`--http-proxy`{.fm-code-in-text1}[]{#09.htm_marker-1116024}            | []{#09.htm_pgfId-1113390}The                        |
|                                                                                                 | `--http-proxy`{.fm-code-in-text1} option tells      |
|                                                                                                 | Podman to use the HTTP proxy environment variables  |
|                                                                                                 | off of the client machine and leak them into the    |
|                                                                                                 | server. Since the proxy is normally set up on the   |
|                                                                                                 | server, the `--http-proxy`{.fm-code-in-text1}       |
|                                                                                                 | option is not allowed with the                      |
|                                                                                                 | `--remote`{.fm-code-in-text1} option.               |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113392}`--preserve-fds`{.fm-code-in-text1}[]{#09.htm_marker-1116029}          | []{#09.htm_pgfId-1113394}The                        |
|                                                                                                 | `--preserve-fds`{.fm-code-in-text1} option leaks    |
|                                                                                                 | file descriptors from the calling process into the  |
|                                                                                                 | container; since this is a remote connection, there |
|                                                                                                 | is no way to leak the file descriptors.             |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113396}`--volume`{.fm-code-in-text1}[]{#09.htm_marker-1116034}                | []{#09.htm_pgfId-1113398}This is supported, except  |
|                                                                                                 | that the source volume will come from the remote    |
|                                                                                                 | machine, not necessarily the one that is running    |
|                                                                                                 | the `podman`{.fm-code-in-text1} command (unless     |
|                                                                                                 | they are on the same machine). If you are using a   |
|                                                                                                 | VM, you need to mount the directory on the host     |
|                                                                                                 | machine into the VM first; then Podman inside of    |
|                                                                                                 | the VM sees the mount and mounts it into the        |
|                                                                                                 | container.                                          |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#09.htm_pgfId-1113400}`--latest`{.fm-code-in-text1},                                         | []{#09.htm_pgfId-1113402}Since there are            |
| `-l`{.fm-code-in-text1}[]{#09.htm_marker-1116039}                                               | potentially multiple different users talking to the |
|                                                                                                 | same server at the same time, the concept of        |
|                                                                                                 | `--latest`{.fm-code-in-text1} was too racy, so it   |
|                                                                                                 | is not supported.                                   |
+-------------------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#09.htm_pgfId-1110031}Podman commands are executed on the server.
From the client's point of view, it seems like Podman runs locally. Now
you need to complete the configuration of the Podman service on the
remote server.

[]{#09.htm_pgfId-1110033}Enabling SSHD connections

[]{#09.htm_pgfId-1110037}For
[]{#09.htm_marker-1110034}[]{#09.htm_marker-1110035}[]{#09.htm_marker-1110036}the
Podman client to communicate with the server, you need to enable and
start the SSH daemon on your Linux machine, if it is not already
enabled:

``` programlisting
$ sudo systemctl enable --now -s sshd
```

[]{#09.htm_pgfId-1110039}Now that the SSHD daemon is running, you need
to enable the Podman service on the remote
[]{#09.htm_marker-1116093}[]{#09.htm_marker-1116094}[]{#09.htm_marker-1116095}machine.

[]{#09.htm_pgfId-1110044}Enabling the Podman service on the server
machine

[]{#09.htm_pgfId-1110048}Before
[]{#09.htm_marker-1116097}[]{#09.htm_marker-1116098}[]{#09.htm_marker-1116099}performing
any Podman client commands, you must enable the podman.sock systemd
service on the Linux server or VM. In these examples, you are running
Podman as a normal, unprivileged user. For rootless Podman on a server
to run properly, enable this socket permanently using the following
command:

``` programlisting
$ systemctl --user enable --now podman.socket
```

[]{#09.htm_pgfId-1110050}Normally, when you log out of a system, systemd
stops all processes on the system. You need to tell systemd to allow the
remote users processes to `linger`{.fm-code-in-text} for rootless mode:

``` programlisting
$ sudo loginctl enable-linger $USER
```

[]{#09.htm_pgfId-1110052}This also tells systemd to start listening on
this socket at boot time. Once you have the service running on one
system, you can verify the socket is listening with a Podman command:

``` programlisting
$ podman --remote info
Host:
  arch: amd64
  buildahVersion: 1.16.0-dev
...
```

[]{#09.htm_pgfId-1110058}[Note]{.fm-callout-head} You can enable the
rootful `podman`{.fm-code-in-text1} service with the following command:

``` programlisting
$ sudo systemctl enable --now podman.socket
```

[]{#09.htm_pgfId-1110060}The previous `enable-linger`{.fm-code-in-text}
command is only for rootless mode. Now that you have the remote service
enabled and running along with the SSHD daemon, you can go back to the
[]{#09.htm_marker-1110061}[]{#09.htm_marker-1110062}[]{#09.htm_marker-1110063}client
[]{#09.htm_marker-1110064}[]{#09.htm_marker-1110065}[]{#09.htm_marker-1110066}machine.

### []{#09.htm_pgfId-1110068}9.5.3 Setting up SSH on the client machine {#09.htm_heading_id_14 .fm-head1}

[]{#09.htm_pgfId-1110073}Remote
[]{#09.htm_marker-1110069}[]{#09.htm_marker-1110070}[]{#09.htm_marker-1110071}[]{#09.htm_marker-1110072}Podman
uses SSH to communicate between the client and server when they are on
separate machines. By default, SSH will ask you to provide the usernames
and passwords on each command, unless you set up SSH keys. To set up
your SSH connection, you need to generate an SSH key pair from your
client machine. If you have existing SSH keys, you can just use them;
it's even better if you already have shared keys with the server. On my
Linux system, I can generate SSH keys with a command like the following:

``` programlisting
$ ssh-keygen -t ed25519
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/myuser/.ssh/id_ed25519):
```

[]{#09.htm_pgfId-1110077}Once you have finished generating your keys,
you can set up trust between the client and server machine with the
`ssh-copy-id`{.fm-code-in-text} command[]{#09.htm_marker-1110078} or
some similar command. The public key, by default, will be in your home
directory under \$HOME/.ssh/id_ed25519 .pub. You need to copy the
contents of id_ed25519.pub and append it into \~/.ssh/ authorized_keys
on the Linux server. See
[https://red.ht/3HuxPT6](https://red.ht/3HuxPT6){.url} for more
information on configuring your SSH environment:

``` programlisting
$ ssh-copy-id myuser@192.168.122.1
passwd:
```

[]{#09.htm_pgfId-1110081}If you do not wish to use SSH keys, you will be
prompted with each Podman command for your login password. Now that you
have shared your SSH keys with the server, the next step is configuring
the connection with
[]{#09.htm_marker-1110082}[]{#09.htm_marker-1110083}[]{#09.htm_marker-1110084}[]{#09.htm_marker-1110085}Podman.

### []{#09.htm_pgfId-1110087}9.5.4 Configuring a connection {#09.htm_heading_id_15 .fm-head1}

[]{#09.htm_pgfId-1110091}The
[]{#09.htm_marker-1110088}[]{#09.htm_marker-1110089}`podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text} command
allows[]{#09.htm_marker-1110090} you to manage SSH connections to be
used by the `podman`{.fm-code-in-text} `--remote`{.fm-code-in-text}
command. You can add a connection by using the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} `add`{.fm-code-in-text}
command[]{#09.htm_marker-1110092}; name the connection
`server1`{.fm-code-in-text}. The default identity file will be chosen,
or you can use the `-–identity`{.fm-code-in-text}
option[]{#09.htm_marker-1110093} to specify the SSH key to use. Finally,
you need to specify the full SSH URL for the Podman socket. This
includes the user account,
`myuser`{.fm-code-in-text}[]{#09.htm_marker-1110094}, and IP address, as
well as the path to the Podman socket for the user account:

``` programlisting
$ podman system connection add server1 --identity ~/.ssh/id_ed25519 
➥ ssh://myuser@192.168.122.1/run/user/1000/podman/podman.sock
```

[]{#09.htm_pgfId-1110097}This Podman command adds a remote connection to
Podman. Since this was the first connection added, Podman marks the
connection as the default.

[]{#09.htm_pgfId-1110099}List the available connections with the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} `list`{.fm-code-in-text}
command[]{#09.htm_marker-1110098}. Notice that the `*`{.fm-code-in-text}
after the connection name indicates it is the default connection:

``` programlisting
$ podman system connection list
Name    Identity          URI
system1*    id_ed25519     
➥ ssh://myuser@192.168.122.1/run/user/1000/podman/podman.sock
```

[]{#09.htm_pgfId-1110104}Now you can test the connection with
`podman`{.fm-code-in-text} `info`{.fm-code-in-text}:

``` programlisting
$ podman --remote info
host:
  arch: amd64
  buildahVersion: 1.23.1
  cgroupControllers:
...
```

[]{#09.htm_pgfId-1110111}[Note]{.fm-callout-head} You can use the
`--connection`{.fm-code-in-text1} `(-c)`{.fm-code-in-text1} if you have
more than one connection and want to choose the non-default
`man`{.fm-code-in-text1} `podman-system-connection`{.fm-code-in-text1}
for all possible options.

[]{#09.htm_pgfId-1110114}You can use the `podman`{.fm-code-in-text}
option[]{#09.htm_marker-1116219} or the
`podman-remote`{.fm-code-in-text} clients[]{#09.htm_marker-1116220} to
manage containers running on Linux servers or VMs. The communication
between client and server relies heavily on SSH connections, and the use
of SSH keys is encouraged. Once you have Podman installed on your remote
server, you need to set up a connection using `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text}
`add`{.fm-code-in-text}, which can then be used by subsequent
[]{#09.htm_marker-1116222}[]{#09.htm_marker-1116223}Podman
[]{#09.htm_marker-1116224}[]{#09.htm_marker-1116225}commands.[]{#09.htm_id_n2kx94l968}
Table 9.6 lists the available Podman system commands.

[]{#09.htm_pgfId-1113524}Table 9.6 Podman system commands

+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113530}Command                                                   | []{#09.htm_pgfId-1113532}Man page                                         | []{#09.htm_pgfId-1113534}Description |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113536}`connection`{.fm-code-in-text1}[]{#09.htm_marker-1116332} | []{#09.htm_pgfId-1113538}`podman-system-connection(1)`{.fm-code-in-text1} | []{#09.htm_pgfId-1113540}Manages     |
|                                                                                    |                                                                           | remote SSH destinations              |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113542}`df`{.fm-code-in-text1}[]{#09.htm_marker-1116339}         | []{#09.htm_pgfId-1113544}`podman-system-df(1)`{.fm-code-in-text1}         | []{#09.htm_pgfId-1113546}Shows       |
|                                                                                    |                                                                           | Podman's disk usage                  |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113548}`info`{.fm-code-in-text1}[]{#09.htm_marker-1116346}       | []{#09.htm_pgfId-1113550}`podman-system-info(1)`{.fm-code-in-text1}       | []{#09.htm_pgfId-1113552}Displays    |
|                                                                                    |                                                                           | Podman system information            |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113554}`migrate`{.fm-code-in-text1}[]{#09.htm_marker-1116353}    | []{#09.htm_pgfId-1113556}`podman-system-migrate(1)`{.fm-code-in-text1}    | []{#09.htm_pgfId-1113558}Migrates    |
|                                                                                    |                                                                           | containers to a new user namespace   |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113560}`prune`{.fm-code-in-text1}[]{#09.htm_marker-1116360}      | []{#09.htm_pgfId-1113562}`podman-system-prune(1)`{.fm-code-in-text1}      | []{#09.htm_pgfId-1113564}Removes     |
|                                                                                    |                                                                           | unused pod, container, volume, and   |
|                                                                                    |                                                                           | image data                           |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113566}`renumber`{.fm-code-in-text1}[]{#09.htm_marker-1116367}   | []{#09.htm_pgfId-1113568}`podman-system-renumber(1)`{.fm-code-in-text1}   | []{#09.htm_pgfId-1113570}Migrates    |
|                                                                                    |                                                                           | lock numbers                         |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113572}`reset`{.fm-code-in-text1}[]{#09.htm_marker-1116374}      | []{#09.htm_pgfId-1113574}`podman-system-reset(1)`{.fm-code-in-text1}      | []{#09.htm_pgfId-1113576}Resets      |
|                                                                                    |                                                                           | Podman storage                       |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+
| []{#09.htm_pgfId-1113578}`service`{.fm-code-in-text1}[]{#09.htm_marker-1116381}    | []{#09.htm_pgfId-1113580}`podman-system-service(1)`{.fm-code-in-text1}    | []{#09.htm_pgfId-1113582}Runs the    |
|                                                                                    |                                                                           | API service                          |
+------------------------------------------------------------------------------------+---------------------------------------------------------------------------+--------------------------------------+

## []{#09.htm_pgfId-1110187}Summary {#09.htm_heading_id_16 .fm-head}

- []{#09.htm_pgfId-1110188 .calibre17}Podman can be run as a REST API
  service.

- []{#09.htm_pgfId-1110189 .calibre17}Podman supports two REST API
  endpoints.

- []{#09.htm_pgfId-1110190 .calibre17}The Podman socket supports two
  APIs.

- []{#09.htm_pgfId-1110191 .calibre17}Compatibility mode or Docker mode
  allows Docker client tools to work with Podman.

- []{#09.htm_pgfId-1110192 .calibre17}Podman mode allows remote clients
  to take advantage of advanced Podman features.

- []{#09.htm_pgfId-1110193 .calibre17}Podman-py is a Python bindings
  library used to communicate with the Podman service.

- []{#09.htm_pgfId-1110194 .calibre17}Docker-py is a Python bindings
  library used to communicate with the Podman compatibility service.

- []{#09.htm_pgfId-1110195 .calibre17}Podman supports running
  `docker-compose`{.fm-code-in-text} with the compatibility service to
  orchestrate `compose`{.fm-code-in-text} containers on a single node.

- []{#09.htm_pgfId-1110196 .calibre17}The `podman`{.fm-code-in-text}
  `--remote`{.fm-code-in-text} command communicates with the Podman
  service over SSH to manage containers.

- []{#09.htm_pgfId-1110197 .calibre17}The `podman`{.fm-code-in-text}
  `system`{.fm-code-in-text} `connect`{.fm-code-in-text} command manages
  SSH connections to remote Podman services, making it easier to manage
  containers in your []{#09.htm_marker-1110198 .calibre17}environment.

[]{#p4.htm}

# []{#p4.htm_pgfId-998407} []{#p4.htm_id_Hlk73883217}[]{#p4.htm_pgfId-1017166}Part 4. Container security {#p4.htm_heading_id_2 .tochead}

[]{#p4.htm_pgfId-1017170}[I]{.fm-part-initial-cap}n the final part of
the book, part 4, I divulge all I know about container security. This
part is very technical, but you learn some key concepts that will help
you understand when a container gets permission denied. It also explains
the benefits of running applications within a container from a security
point of view. Containerizing applications adds tremendous protection
from potential hacks to your host system.

[]{#p4.htm_pgfId-1017171}In chapter 10, I explain all of the features of
the kernel that Podman uses to isolate containers from each other as
well as the host system. I explain SELinux, seccomp, Linux capabilities,
read-only mount points, and many other features.

[]{#p4.htm_pgfId-1017172}Chapter 11 digs into security considerations.
You learn the security best practices for running your containers in
production, how you should design your application, and how you should
run your containerized application in production.

[]{#10.htm}

# []{#10.htm_pgfId-1114065}[]{#10.htm_id_3e1g3umbrs9r}[]{#10.htm_pgfId-1114067}10 Security container isolation {#10.htm_heading_id_2 .tochead}

[]{#10.htm_pgfId-1114069}This chapter []{#10.htm_marker-1121657}covers

- []{#10.htm_pgfId-1114070 .calibre17}All Linux security features used
  to keep containers isolated from each other
- []{#10.htm_pgfId-1114072 .calibre17}Read-only access to kernel
  filesystems needed for processes within a container but which must be
  blocked from write access
- []{#10.htm_pgfId-1114073 .calibre17}Masking of kernel filesystems to
  hide information from the host system
- []{#10.htm_pgfId-1114074 .calibre17}Linux capabilities limiting the
  power of root
- []{#10.htm_pgfId-1114075 .calibre17}The PID, IPC and network
  namespaces, which hide most of the operating system from processes
  within containers
- []{#10.htm_pgfId-1114076 .calibre17}The mount namespace, which along
  with SELinux limit the container processes' access to only the
  designated image and volumes
- []{#10.htm_pgfId-1114077 .calibre17}The user namespace, which allows
  you to write root processes inside of a container that are not root
  outside of a container

[]{#10.htm_pgfId-1114078}In this chapter and chapter 11, I review and
demonstrate some additional security considerations when using Podman to
run containers. Some of the content was covered in other chapters, but I
think it is useful to concentrate on these features from a security
perspective.

[]{#10.htm_pgfId-1114079}One of the most frequent problems I see with
people running containers is that when the container process is denied
some access, the user's first reaction is to run the container in
`--privileged`{.fm-code-in-text} mode[]{#10.htm_marker-1124108}, which
turns off all security separation for your container. Understanding how
to deal with the security features discussed in this chapter helps you
avoid needing to do this.

[]{#10.htm_pgfId-1114081}When I look at containers from a security point
of view, I examine how to protect the host kernel and filesystem from
the processes inside the container. I wrote a coloring book, *The
Container Coloring Book*
([https://red.ht/3gfVlHF](https://red.ht/3gfVlHF){.url}), illustrated by
Máirín Duffy[]{#10.htm_marker-1114083}[]{#10.htm_marker-1114084}
(@marin), describing the security features of containers based on the
three pigs (figure 10.1).

::: figure
![](images/10-01.png){.calibre18}

[]{#10.htm_pgfId-1130030}Figure 10.1 *The Container Coloring Book*
([https://red.ht/3gfVlHF](https://red.ht/3gfVlHF){.url})
:::

[]{#10.htm_pgfId-1114092}The analogy I use in the book is that the three
pigs are applications. I then discuss where they live and their choices
of housing compared to computer systems.

[]{#10.htm_pgfId-1114093}The single-family house is equivalent to one
application on a single isolated node. Living in a duplex is equivalent
to running each application in a separate VM. Living in a hotel or
apartment building is similar to containers, where you get your own
apartment, but you rely on the security of the front desk to control the
access to your living space. If the front desk is compromised, then your
apartment is going to be compromised. Containers are similar to this in
that they rely on the security of the kernel. If one container can take
over the host kernel, then it can take over all of the container
applications running on the system. Also, if they escape to the
underlying filesystem, they might be able to read and write all of the
data of the containers on the system.

[]{#10.htm_pgfId-1114094}From this perspective, I see the number-one
goal of the host as being to protect the host kernel and filesystems
from the container processes. The rest of this chapter describes the
tools used to protect the host kernel and filesystem from container
processes.

[]{#10.htm_pgfId-1114095}Protecting the kernel from potentially hostile
containers is the primary goal of container security. If the kernel is
vulnerable, then the rest of the system and all containers are
vulnerable. In many cases, the only exposure to the host system for a
container is the host kernel itself.

[]{#10.htm_pgfId-1114096}Processes within a container can interact with
the kernel in many different ways. This section examines these
communications and the operating system features used to secure the
container processes.

[]{#10.htm_pgfId-1114098}The Linux kernel provides filesystems that
allow processes to communicate and configure the kernel. Protecting
these filesystems from confined container processes is the first
security feature you will examine.

## []{#10.htm_pgfId-1114100}10.1 Read-only Linux kernel pseudo filesystems {#10.htm_heading_id_3 .fm-head}

[]{#10.htm_pgfId-1114103}These
[]{#10.htm_marker-1114101}[]{#10.htm_marker-1114102}Linux kernel pseudo
filesystems are generally mounted under /proc and /sys. Table 10.1 lists
some of the Linux kernel pseudo filesystems mounted on my
machine.[]{#10.htm_id_yj2rnzt9ihp6}

[]{#10.htm_pgfId-1118386}Table 10.1 Filesystems mounted as read only

+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118390}Filesystem mount     | []{#10.htm_pgfId-1118392}Pseudo filesystem          |
| point                                         | description                                         |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118394}/sys                 | []{#10.htm_pgfId-1118396}The sysfs filesystem       |
|                                               | allows viewing and manipulating objects from        |
|                                               | `user-space`{.fm-code-in-text1}, which are created  |
|                                               | and destroyed by kernel space.                      |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118398}/sys/kernel/security | []{#10.htm_pgfId-1118400}The security pseudo        |
|                                               | filesystem is used to read and configure general    |
|                                               | security modules. An example is the Integrity       |
|                                               | Measurement Architecture (IMA) model.               |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118402}/sys/fs/cgroup       | []{#10.htm_pgfId-1118404}The cgroup filesystem is   |
|                                               | used to manage control groups.                      |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118406}/sys/fs/pstore       | []{#10.htm_pgfId-1118408}The pstore filesystem      |
|                                               | stores nonvolatile information useful for           |
|                                               | diagnosing the cause of a system crash.             |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118410}/sys/fs/bpf          | []{#10.htm_pgfId-1118412}The Berkeley Packet Filter |
|                                               | (BPF) filesystem is a mechanism to instrument the   |
|                                               | Linux kernel with user programs that reveal kernel  |
|                                               | information and control the way processes run on a  |
|                                               | system.                                             |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118414}/sys/fs/selinux      | []{#10.htm_pgfId-1118416}The SELinux filesystem is  |
|                                               | used to configure SELinux in the kernel (see        |
|                                               | section 10.2.7).                                    |
+-----------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118418}/sys/kernel/config   | []{#10.htm_pgfId-1118420}The configfs filesystem is |
|                                               | for creating, managing, and destroying kernel       |
|                                               | objects from `user-space`{.fm-code-in-text1}.       |
+-----------------------------------------------+-----------------------------------------------------+

[]{#10.htm_pgfId-1114141}Most processes require read access to these
pseudo kernel filesystems to succeed, but only administrator processes
require write access. Normally, the kernel relies on the separation of
root from non-root or possession of the
`CAP_SYS_ADMIN`{.fm-code-in-text} capability[]{#10.htm_marker-1114142}
(see section 10.2.2) to modify these filesystems.

[]{#10.htm_pgfId-1114143}Often containers need to run as root, requiring
container security to use other means to prevent the writing of these
kernel filesystems by the root process. Podman does not mount most of
these advanced kernel pseudo filesystems. It does mount /sys,
/sys/fs/cgroup, and /sys/fs/selinux as read only. When you are in a PID
namespace, the /proc filesystem changes, meaning the /proc inside a
container is not the host's /proc. Processes within the container can
only affect other processes within the container.

[]{#10.htm_pgfId-1114144}The /sys filesystems and the namespaced /proc
filesystem sometimes leak host information into the container. Because
of this, Podman mounts /dev/null over files and mounts read-only tmpfs
filesystems over directories to prevent container access. Podman also
bind mounts certain subdirectories as read only over themselves to
prevent the container process from writing to
them.[]{#10.htm_id_6wlyiab1lct1}[]{#10.htm_id_6ewp0of2k2z2} See table
10.2 for a complete list of files and directories that Podman masks over
for security purposes.

[]{#10.htm_pgfId-1118489}Table 10.2 Filesystem fields masked over with
Podman

+------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118493}Type of   | []{#10.htm_pgfId-1118495}Paths                      |
| masking                            |                                                     |
+------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118497}Read-only | []{#10.htm_pgfId-1118499}/proc/acpi, /proc/kcore,   |
| tmpfs mounted over the directory   | /proc/keys, /proc/latency_stats, /proc/timer_list,  |
|                                    | /proc/timer_stats, /proc/sched_debug, /proc/scsi,   |
|                                    | /sys/firmware, /sys/fs/selinux, /sys/dev/block      |
+------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118501}Read-only | []{#10.htm_pgfId-1118503} /proc/asound, /proc/bus,  |
| bind mount over the directory      | /proc/fs, /proc/irq, /proc/sys, /proc/sysrq-trigger |
+------------------------------------+-----------------------------------------------------+

[]{#10.htm_pgfId-1114163}I have found that almost all container images
run fine with this additional security. Sometimes a containerized
application may need additional access to one of these masked-over
directories.

### []{#10.htm_pgfId-1114165}10.1.1 Unmasking the masked paths {#10.htm_heading_id_4 .fm-head1}

[]{#10.htm_pgfId-1114170}Rather
[]{#10.htm_marker-1114166}[]{#10.htm_marker-1114167}[]{#10.htm_marker-1114168}than
force the container to run `--privileged`{.fm-code-in-text}
mode[]{#10.htm_marker-1114169}, you can tell Podman to unmask a
directory. In the following example, you run a container and see there
are no files or directories under /proc/scsi because it is mounted over
with a tmpfs:

``` programlisting
$ podman run --rm ubi8 ls /proc/scsi
```

[]{#10.htm_pgfId-1114173}You can use the
`--security-opt`{.fm-code-in-text} `unmask=/proc/scsi`{.fm-code-in-text}
flag[]{#10.htm_marker-1114172} to remove the mount point and expose the
underlying files and directories:

``` programlisting
$ podman run --rm --security-opt unmask=/proc/scsi ubi8 ls /proc/scsi
device_info
scsi
sg
```

[]{#10.htm_pgfId-1114178}You can even use a `*`{.fm-code-in-text} to
unmount all directories under a certain path:

``` programlisting
$ podman run --rm --security-opt unmask=/proc/* ubi8 ls /proc/scsi
device_info
scsi
sg
```

[]{#10.htm_pgfId-1114183}Unmasking makes your container slightly less
secure, but it is much better than going all the way to
`--privileged`{.fm-code-in-text} and turning off all of the security. In
certain situations, you might want to make the system more secure by
masking over parts of the pseudo filesystems. The
`podman`{.fm-code-in-text} `run`{.fm-code-in-text} man
pages[]{#10.htm_marker-1123817} list the masked
file[]{#10.htm_marker-1123818}[]{#10.htm_marker-1123819}[]{#10.htm_marker-1123820}systems:

``` programlisting
$ man podman run
...
   • unmask=ALL or /path/1:/path/2, or shell expanded paths (/proc/*): 
Paths to unmask separated by a colon. If set to ALL, it will unmask all the 
paths that are masked or made read only by default. The default masked
    paths are /proc/acpi, /proc/kcore, /proc/keys, /proc/latency_stats, 
/proc/sched_debug, /proc/scsi, /proc/timer_list, /proc/timer_stats, 
/sys/firmware, and /sys/fs/selinux. 
    The default paths that are read only are /proc/asound, /proc/bus, 
/proc/fs, /proc/irq, /proc/sys, /proc/sysrq-trigger, /sys/fs/cgroup.
```

### []{#10.htm_pgfId-1114200}10.1.2 Masking additional paths {#10.htm_heading_id_5 .fm-head1}

[]{#10.htm_pgfId-1114205}If
[]{#10.htm_marker-1114201}[]{#10.htm_marker-1114202}[]{#10.htm_marker-1114203}you
are very security conscious or have a container you don't trust with
certain access provided to containers, you can add additional masked
paths with the `--security-opt`{.fm-code-in-text} mask
flag[]{#10.htm_marker-1114206}. For example, if you want to prevent a
container process from seeing the devices in /proc/sys/dev, run the
following:

``` programlisting
$ podman run --rm ubi8 ls /proc/sys/dev
cdrom
hpet
i915
mac_hid
raid
scsi
tty
```

[]{#10.htm_pgfId-1114216}You can mask over it with the
`--security-opt`{.fm-code-in-text}
`mask=/proc/sys/dev`{.fm-code-in-text} flag[]{#10.htm_marker-1114215}:

``` programlisting
$ podman run --rm --security-opt mask=/proc/sys/dev ubi8 ls /proc/sys/dev
```

[]{#10.htm_pgfId-1114218}You saw how Podman prevents root processes from
reading and, more importantly, writing to pseudo filesystems. The
container processes can actually see what is mounted over within the
container by looking at /proc/self/mountinfo.

[]{#10.htm_pgfId-1114219}Listing 10.1 The mount table within a Podman
container

``` programlisting
$ podman run –rm ubi8 cat /proc/self/mountinfo
...
1628 1610 0:5 /null /proc/kcore rw,nosuid – 
➥ devtmpfs devtmpfs rw,seclabel,size=4096k,
➥ nr_inodes=1048576,mode=755,inode64                          ❶
...
1620 1595 0:86 / /sys/firmware ro,relatime - tmpfs tmpfs       ❷
rw,context="system_u:object_r:container_file_t:s0:c406,c915",size=0k,uid=32
➥ 67,gid=3267,inode64
...
```

[]{#10.htm_pgfId-1129169}[❶]{.fm-combinumeral} Shows /dev/null mounted
over /proc/kcore

[]{#10.htm_pgfId-1129190}[❷]{.fm-combinumeral} Shows a tmpfs mounted
read-only over /sys/firmware

[]{#10.htm_pgfId-1114231}You might be asking yourself, "If the container
knows what has been mounted, what prevents the root user within the
container from removing the mounts or remounting filesystems' read/write
and then attacking the
[]{#10.htm_marker-1114232}[]{#10.htm_marker-1114233}[]{#10.htm_marker-1114234}host
[]{#10.htm_marker-1114235}[]{#10.htm_marker-1114236}kernel?

## []{#10.htm_pgfId-1114238}10.2 Linux capabilities {#10.htm_heading_id_6 .fm-head}

[]{#10.htm_pgfId-1114241}Most
[]{#10.htm_marker-1114239}[]{#10.htm_marker-1114240}Linux people
understand Linux has two types of users: root (privileged process) and
everyone else (nonprivileged processes). Root is all powerful, and
non-root has much more limited powers, specifically when configuring and
modifying the kernel. Sometimes a non-privileged process needs
privileges to execute a certain command-line `ping`{.fm-code-in-text} or
`sudo`{.fm-code-in-text}. Linux supports a way to mark these files as
`setuid`{.fm-code-in-text}, and when a nonprivileged process executes
them, the new process gains the privilege.

[]{#10.htm_pgfId-1114242}The binary difference between privileged and
unprivileged processes ended in Linux around 2000. Kernel engineers
broke down the power of root into a group of different privileged
capabilities. Currently, on my system, the Linux kernel supports 41. You
can see the complete list of capabilities using the
`capsh`{.fm-code-in-text} program[]{#10.htm_marker-1114243}. Execute the
`capsh`{.fm-code-in-text} program to see the list of capabilities on
your system. You will see the `current`{.fm-code-in-text} set of
capabilities for your processes as being empty. The
`Bounding`{.fm-code-in-text} set of
capabilities[]{#10.htm_marker-1114244} is the set of capabilities your
process can get from executing a `setuid`{.fm-code-in-text}
program[]{#10.htm_marker-1114245}.

[]{#10.htm_pgfId-1114246}Listing 10.2 `capsh`{.fm-code-in-text}
`–print`{.fm-code-in-text} showing the capabilities available to your
user's process

``` programlisting
$ capsh --print
Current: =                                 ❶
Bounding set =                             ❷
cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,
➥ cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,
➥ cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,
➥ cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,
➥ cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,
➥ cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,
➥ cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,
➥ cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
Ambient set =
...
uid=3267(dwalsh) euid=3267(dwalsh)          ❸
gid=3267(dwalsh)
```

[]{#10.htm_pgfId-1128949}[❶]{.fm-combinumeral} The Current set of
capabilities shows no capabilities.

[]{#10.htm_pgfId-1128970}[❷]{.fm-combinumeral} The Bounding set of
capabilities shows all (41) capabilities.

[]{#10.htm_pgfId-1128987}[❸]{.fm-combinumeral} Because you ran the capsh
command as a normal user, you see your UID and GID listed.

[]{#10.htm_pgfId-1114265}This means your user process can execute the
`sudo`{.fm-code-in-text} command[]{#10.htm_marker-1114264} and get the
full set of capabilities as root. You can read information about what
each capability does in the capabilities man page by executing
`man`{.fm-code-in-text} `capabilities`{.fm-code-in-text}. Over the
years, the community has figured out that almost all containers do not
require the full list of capabilities because they seldom modify the
kernel.

### []{#10.htm_pgfId-1114267}10.2.1 Dropped Linux capabilities {#10.htm_heading_id_7 .fm-head1}

[]{#10.htm_pgfId-1114271}Because
[]{#10.htm_marker-1114268}[]{#10.htm_marker-1114269}[]{#10.htm_marker-1114270}container-confined
processes are not supposed to manipulate the operating system, and
specifically the kernel, Podman can run root within its containers with
far fewer capabilities. You can examine the default list of capabilities
available within a Podman container by executing the same
`capsh`{.fm-code-in-text} program[]{#10.htm_marker-1114272}.

[]{#10.htm_pgfId-1114273}Listing 10.3 The default list of capabilities
available within a Podman container

``` programlisting
$ podman run --rm ubi8 capsh --print
Current: =                                                             ❶
cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,
➥ cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,
➥ cap_setfcap+eip
Bounding set =                                                         ❷
cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,
➥ cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,cap_setfcap
...
uid=0(root)                                                            ❸
gid=0(root)
groups=
```

[]{#10.htm_pgfId-1128609}[❶]{.fm-combinumeral} The Current set of
capabilities shows just 11 capabilities, since the container process is
running as root.

[]{#10.htm_pgfId-1128637}[❷]{.fm-combinumeral} The Bounding set of
capabilities shows the same (11) capabilities.

[]{#10.htm_pgfId-1128654}[❸]{.fm-combinumeral} Because containers
default to running as root, you see the UID and GID as root.

[]{#10.htm_pgfId-1114288}As you observe, Podman, by default, dropped 30
capabilities---from 41 down to 11---when running a container. Even
though the container has root privileges, it is far less powerful than
root on the system.

[]{#10.htm_pgfId-1114289}[Note]{.fm-callout-head} Docker also drops
capabilities but leaves 14 capabilities. Podman runs with tighter
security by dropping the following additional capabilities:
`CAP_ MKNOD`{.fm-code-in-text1}[]{#10.htm_marker-1114290},
`CAP_AUDIT_WRITE`{.fm-code-in-text1}[]{#10.htm_marker-1114291}, and
`CAP_NET_RAW`{.fm-code-in-text1}[]{#10.htm_marker-1114292}.

[]{#10.htm_pgfId-1114293}The list of capabilities still allowed within a
container mainly concern controlling multiple processes; for example,
`CAP_SETUID`{.fm-code-in-text} and `CAP_SETGID`{.fm-code-in-text} allow
processes inside the container to change to different UIDs. An example
of where this is important is running your web application as
`UID=60`{.fm-code-in-text}, but when the container process started, it
needed to run as root for a short time before changing its UID to
`60`{.fm-code-in-text}. If Podman dropped
`CAP_SETUID`{.fm-code-in-text}, then the root process within the
container is not allowed to change to the web services UID.

[]{#10.htm_pgfId-1114294}Another interesting capability Podman allows is
`CAP_NET_BIND_SERVICE`{.fm-code-in-text}, which enables a process to
bind to a network port less than `1024`{.fm-code-in-text}---for example,
port `80`{.fm-code-in-text}. Recall from chapter 2 that you cannot bind
port `80`{.fm-code-in-text} on your host to port `80`{.fm-code-in-text}
within the container. User processes do not have
`CAP_NET_BIND_SERVICE`{.fm-code-in-text}, so they cannot bind to port
`80`{.fm-code-in-text}. Table 10.3 lists the default capabilities
available to root running within a container with Podman. This list can
be modified in the containers.conf file using the
`default_capabilities`{.fm-code-in-text} field under the containers
table.[]{#10.htm_id_tnckf94w0qwk}[]{#10.htm_id_k51d5sudgzug}[]{#10.htm_id_4hrvi2og09zg}[]{#10.htm_id_mav5p9a6hdrw}[]{#10.htm_id_q0cwpuhoolzu}

[]{#10.htm_pgfId-1118917}Table 10.3 Default list of capabilities allowed
root processes in a container

+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118921}Option                                                              | []{#10.htm_pgfId-1118923}Description                |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118925}`CAP_CHOWN`{.fm-code-in-text1}[]{#10.htm_marker-1118968}            | []{#10.htm_pgfId-1118927}Make arbitrary changes to  |
|                                                                                              | file UIDs and GIDs.                                 |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118929}`CAP_DAC_OVERRIDE`{.fm-code-in-text1}[]{#10.htm_marker-1118969}     | []{#10.htm_pgfId-1118931}Bypass file read, write,   |
|                                                                                              | and execute permission checks.                      |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118933}`CAP_FOWNER`{.fm-code-in-text1}[]{#10.htm_marker-1118970}           | []{#10.htm_pgfId-1118935}Bypass permission checks   |
|                                                                                              | on operations on the filesystem UID.                |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118937}`CAP_SETFSID`{.fm-code-in-text1}[]{#10.htm_marker-1118971}          | []{#10.htm_pgfId-1118939}Don\'t clear               |
|                                                                                              | `set-user-ID`{.fm-code-in-text1} and                |
|                                                                                              | `set-group-ID`{.fm-code-in-text1} mode bits when    |
|                                                                                              | modifying a file.                                   |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118941}`CAP_KILL`{.fm-code-in-text1}[]{#10.htm_marker-1118972}             | []{#10.htm_pgfId-1118943}Bypass permission checks   |
|                                                                                              | for sending signals.                                |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118945}`CAP_NET_BIND_SERVICE`{.fm-code-in-text1}[]{#10.htm_marker-1118973} | []{#10.htm_pgfId-1118947}Bind a socket to internet  |
|                                                                                              | domain privileged ports (port numbers less than     |
|                                                                                              | `1024`{.fm-code-in-text1}).                         |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118949}`CAP_SETFCAP`{.fm-code-in-text1}[]{#10.htm_marker-1118974}          | []{#10.htm_pgfId-1118951}Set arbitrary capabilities |
|                                                                                              | on a file.                                          |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118953}`CAP_SETGID`{.fm-code-in-text1}[]{#10.htm_marker-1118975}           | []{#10.htm_pgfId-1118955}Change a process's group   |
|                                                                                              | ID (GID) or supplementary GID list.                 |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118957}`SET_SETPCAP`{.fm-code-in-text1}[]{#10.htm_marker-1118976}          | []{#10.htm_pgfId-1118959}Add and drop any           |
|                                                                                              | capability from the calling thread\'s bounding set. |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118961}`CAP_SETUID`{.fm-code-in-text1}[]{#10.htm_marker-1118977}           | []{#10.htm_pgfId-1118963}Make arbitrary             |
|                                                                                              | manipulations of the process user ID (UID).         |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1118965}`CAP_SYS_CHROOT`{.fm-code-in-text1}[]{#10.htm_marker-1118978}       | []{#10.htm_pgfId-1118967}Allow                      |
|                                                                                              | `chroot`{.fm-code-in-text1}, and change mount       |
|                                                                                              | namespaces.                                         |
+----------------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#10.htm_pgfId-1114363}I introduced section 10.2 by asking what
prevents the root process from unmounting or remounting the read-only
filesystems. The answer is Podman dropping the
`CAP_ SYS_ADMIN`{.fm-code-in-text}[]{#10.htm_marker-1122765}[]{#10.htm_marker-1122766}[]{#10.htm_marker-1122767}
c`apability`{.fm-code-in-text}[]{#10.htm_marker-1122768}.

### []{#10.htm_pgfId-1114369}10.2.2 Dropped CAP_SYS_ADMIN {#10.htm_heading_id_8 .fm-head1}

[]{#10.htm_pgfId-1114375}The
[]{#10.htm_marker-1114370}[]{#10.htm_marker-1114371}[]{#10.htm_marker-1114372}most
powerful Linux capability is `CAP_SYS_ADMIN`{.fm-code-in-text}. I
describe this capability in the following way: Imagine you are a kernel
engineer adding a new feature into the kernel, and this feature requires
privilege access. You look to see the list of capabilities, and you
don't find a capability that is a great match for the access. Kernel
engineers can go through the hassle of creating a new capability; or,
say this is something a system administrator needs to do and there is a
`CAP_SYS_ADMIN`{.fm-code-in-text}. I might as well require that
capability. If you look at the man capabilities information, you see
multiple pages of features the `CAP_SYS_ADMIN`{.fm-code-in-text}
capability blocks.

[]{#10.htm_pgfId-1114377}One feature `CAP_SYS_ADMIN`{.fm-code-in-text}
controls is the ability to mount and unmount filesystems. Because this
capability is dropped by default, root processes in Podman containers
cannot unmount or remount the read-only mount points.

[]{#10.htm_pgfId-1114378}As you learned previously, 11 capabilities are
still allowed. In most cases, your containerized process does not even
need those capabilities, meaning you can drop additional
[]{#10.htm_marker-1114379}[]{#10.htm_marker-1114380}[]{#10.htm_marker-1114381}ones.

### []{#10.htm_pgfId-1114384}10.2.3 Dropping capabilities {#10.htm_heading_id_9 .fm-head1}

[]{#10.htm_pgfId-1114388}I
[]{#10.htm_marker-1114385}[]{#10.htm_marker-1114386}[]{#10.htm_marker-1114387}recommend
people run their applications with the least privileges possible. One
way of increasing the security of the system is dropping additional
capabilities.

[]{#10.htm_pgfId-1114389}Imagine your containerized process does not
need to bind to ports \< `1024`{.fm-code-in-text}. You can execute
Podman with the `--cap-drop=CAP_NET_BIND_SERVICE`{.fm-code-in-text}
flag[]{#10.htm_marker-1114390} and drop that capability from your
container.

[]{#10.htm_pgfId-1114391}Listing 10.4 Capabilities inside a container
when you drop `CAP_NET_BIND_SERVICE`{.fm-code-in-text}

``` programlisting
$ podman run --cap-drop CAP_NET_BIND_SERVICE ubi8 capsh --print
Current: =                                                             ❶
cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,
➥ cap_setuid,cap_setpcap,cap_sys_chroot,cap_setfcap+eip
Bounding set =                                                         ❷
cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,
➥ cap_setuid,cap_setpcap,cap_sys_chroot,cap_setfcap
...
```

[]{#10.htm_pgfId-1128376}[❶]{.fm-combinumeral} Notice the list of
Current capabilities no longer includes CAP_NET_BIND_SERVICE.

[]{#10.htm_pgfId-1128404}[❷]{.fm-combinumeral} Notice that the list of
Bounding capabilities no longer includes CAP_NET_BIND_SERVICE.

[]{#10.htm_pgfId-1114404}You can even drop all capabilities using the
`--cap-drop=all`{.fm-code-in-text} flag:

``` programlisting
$ podman run --cap-drop all ubi8 capsh --print
Current: =
Bounding set =
```

[]{#10.htm_pgfId-1114408}Even though your container is running as root,
it has no capabilities to modify the kernel. Sometimes your container
fails to run with the limited list of capabilities provided by Podman;
in this case, you can add required
[]{#10.htm_marker-1114409}[]{#10.htm_marker-1114410}[]{#10.htm_marker-1114411}capabilities.

### []{#10.htm_pgfId-1114413}10.2.4 Adding capabilities {#10.htm_heading_id_10 .fm-head1}

[]{#10.htm_pgfId-1114417}In
[]{#10.htm_marker-1114414}[]{#10.htm_marker-1114415}[]{#10.htm_marker-1114416}some
situations, your container might fail because it does not have a certain
capability. You can simply run `--privileged`{.fm-code-in-text} and turn
off all security in these cases, but a better solution is just adding
required capabilities.

[]{#10.htm_pgfId-1114418}Imagine you have a container that wants to
create a raw IP packet on its namespaced network, which requires
`CAP_NET_RAW`{.fm-code-in-text}. Podman, by default, does not allow
this. Rather than running the container as
`--privileged`{.fm-code-in-text}, you can use the
`--cap-add`{.fm-code-in-text} `CAP_NET_RAW`{.fm-code-in-text}
flag[]{#10.htm_marker-1114419}:

``` programlisting
$ podman run --cap-add CAP_NET_RAW ubi8 capsh --print
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
➥ cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_
➥ sys_chroot,cap_setfcap+eip
Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
➥ cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_
➥ sys_chroot,cap_setfcap
...
```

[]{#10.htm_marker-1114464}[]{#10.htm_pgfId-1114428}If this is the only
capability needed by your container, you can both drop all capabilities
and just add back in this `CAP_NET_RAW`{.fm-code-in-text} by using the
`--cap-drop`{.fm-code-in-text}[]{#10.htm_marker-1114429} and
`--cap-add`{.fm-code-in-text} flags[]{#10.htm_marker-1114430} at the
same
[]{#10.htm_marker-1114431}[]{#10.htm_marker-1114432}[]{#10.htm_marker-1114433}time:

``` programlisting
$ podman run --cap-drop=all --cap-add CAP_NET_RAW ubi8 capsh --print
Current: = cap_net_raw+eip
Bounding set =cap_net_raw
...
```

### []{#10.htm_pgfId-1114439}10.2.5 No new privileges {#10.htm_heading_id_11 .fm-head1}

[]{#10.htm_pgfId-1114444}Podman
[]{#10.htm_marker-1114440}[]{#10.htm_marker-1114441}[]{#10.htm_marker-1114442}has
an option, `--security-opt`{.fm-code-in-text}
`no-new-privileges`{.fm-code-in-text}[]{#10.htm_marker-1114443}, which
disables the ability for container processes to gain additional
privileges. Basically, it locks the processes into the group of Linux
capabilities they have when they are started. Even if they can execute a
`setuid`{.fm-code-in-text} program, the kernel denies it from gaining
additional capabilities. The `no-new-privileges`{.fm-code-in-text}
option[]{#10.htm_marker-1114445} also affects SELinux and prevents
SELinux label transitions. Even if SELinux had a bug in its rules
database, the container process would not be allowed to change its
[]{#10.htm_marker-1114446}[]{#10.htm_marker-1114447}[]{#10.htm_marker-1114448}label.

### []{#10.htm_pgfId-1114450}10.2.6 Root with no capabilities is still dangerous {#10.htm_heading_id_12 .fm-head1}

[]{#10.htm_pgfId-1114454}Dropping
[]{#10.htm_marker-1114451}[]{#10.htm_marker-1114452}[]{#10.htm_marker-1114453}capabilities
means your container is running much more securely, but running all of
your containers without any Linux capabilities is much more secure.
Another problem to consider when running a container as root, even if
you drop all capabilities, is that the process is still running as root.
The root process is allowed to modify all files on the system that are
owned by root. The root process can modify a system file and trick a
privileged administrator into executing it. Also, some client-server
applications trust the client side of the connection simply if it is
running as root (e.g., Docker). Podman can solve both of these problems
by using the
[]{#10.htm_marker-1114455}[]{#10.htm_marker-1114456}[]{#10.htm_marker-1114457}user
[]{#10.htm_marker-1114458}[]{#10.htm_marker-1114459}namespace.

## []{#10.htm_pgfId-1114461}10.3 UID isolation: User namespace {#10.htm_heading_id_13 .fm-head}

[]{#10.htm_pgfId-1114465}Back
[]{#10.htm_marker-1130059}[]{#10.htm_marker-1130060}[]{#10.htm_marker-1130061}in
section 6.1.1, I introduced the concept of the user namespace. Recall
that UIDs were allocated via the /etc/subuid and /etc/subgid files for a
rootless user. For my accounts, the range of UIDs from
`100000`{.fm-code-in-text}--`165535`{.fm-code-in-text} was allocated
along with my UID `3265`{.fm-code-in-text} and was used by Podman when
launching containers. See figure 10.2 for a description of the user
namespace mapping.

::: figure
![](images/10-02.png){.calibre18}

[]{#10.htm_pgfId-1130085}Figure 10.2 The mapping of UIDs used by
rootless Podman for my account
:::

[]{#10.htm_pgfId-1114472}This user namespace allows my account to have
root access within the container that is not root on the host. Running
containers in a user namespace eliminates the problem of having
processes running as the root user, and the inherent trust is built into
some daemons.

[]{#10.htm_pgfId-1114473}One problem with rootless users is that, by
default, all of the containers run with the same user namespace.
Theoretically, from a user namespace point of view, one container can
attack another container, since they run with duplicate UIDs. Also, if
the container processes break out, they can read/write content in your
home directory, since the root processes within the containers are
running with your UID.

### []{#10.htm_pgfId-1114475}10.3.1 Isolating containers using the - -userns=auto flag {#10.htm_heading_id_14 .fm-head1}

[]{#10.htm_pgfId-1114480}Podman
[]{#10.htm_marker-1114476}[]{#10.htm_marker-1114477}[]{#10.htm_marker-1114478}[]{#10.htm_marker-1114479}has
a feature for allocating unique ranges of UIDs for every container it
launches. Since there are limited UIDs allocated for each user account,
this feature works best when launched by the root user.

[]{#10.htm_pgfId-1114481}To launch multiple containers within their own
user namespace, you need to first allocate the UIDs and GIDs to be used
for these containers. On a Linux system, there are 4 billion UIDs
available. Podman recommends that you allocate the highest 2 billion
UIDs for your containers. You can do this by adding the following
containers line to your /etc/subuid and /etc/subgid file.

[]{#10.htm_pgfId-1114482}Listing 10.5 The contents of the /etc/subuid
and /etc/subgid files

``` programlisting
# cat /etc/subuid
dwalsh:100000:65536
containers:2147483647:2147483648   ❶
# cat /etc/subgid
dwalsh:100000:65536
containers:2147483647:2147483648   ❶
```

[]{#10.htm_pgfId-1128297}[❶]{.fm-combinumeral} Allocates the top 2
billion UIDs to the container user used by Podman. Adding this line
tells other tools on your system, like useradd, to avoid allocating UIDs
and GIDs within this range.

[]{#10.htm_pgfId-1114490}You[]{#10.htm_marker-1123372} can launch a
container within a unique user namespace using the
`--userns=auto`{.fm-code-in-text} option. Podman allocates the UIDs for
the container starting with UID `2147483647`{.fm-code-in-text}, which
you specified in the /etc/subuid file. Podman then examines the
container image for all UIDs defined within it as well as the
/etc/passwd file if it exists in the image and then uses this to
allocate the number of UIDs required to run the container with a default
minimum of `1024`{.fm-code-in-text}:

``` programlisting
# podman run --userns=auto ubi8 cat /proc/self/uid_map
     0 2147483647   1024
```

[]{#10.htm_pgfId-1114493}If I run a second container with a specific
user `2000`{.fm-code-in-text}, then the allocation of UIDs reflects
this. You see that the number of UIDs allocated is
`2001`{.fm-code-in-text}---UID `2000`{.fm-code-in-text} plus one for the
root user:

``` programlisting
# podman run --user=2000 --userns=auto ubi8 cat /proc/self/uid_map
     0 2147484671   2001
```

[]{#10.htm_pgfId-1114496}Also, note that the starting UID for the first
container was `2147483647,`{.fm-code-in-text} while the starting UID for
the second container was `2147484671`{.fm-code-in-text}. Subtracting the
first UID `2147483647`{.fm-code-in-text} from the second UID
`2147484671`{.fm-code-in-text} gives you `1024`{.fm-code-in-text}, which
is the number of UIDs allocated for the first container. No UID within
the first container overlaps with the second container, meaning no
process within the first container can attack processes within the
second container, and vice versa.

[]{#10.htm_pgfId-1114497}You can override the default size of the user
namespace used within the container with a size option if Podman does
not allocate enough UIDs or GIDs for your container. In this example,
you tell Podman to allocate `5000`{.fm-code-in-text} UIDs for the
container with `--userns=auto:size=5000`{.fm-code-in-text}:

``` programlisting
# podman run --userns=auto:size=5000 ubi8 cat /proc/self/uid_map
     0 2147486672   5000
```

[]{#10.htm_pgfId-1114500}When containers are removed, Podman reclaims
the UIDs used for the deleted containers and uses those UIDs for the
next container created with the `--userns=auto`{.fm-code-in-text}
`flag`{.fm-code-in-text}. You see this when you launch back-to-back
containers with the `--rm`{.fm-code-in-text}
option[]{#10.htm_marker-1114501}. Notice that they start with the same
UID. In the following example, both containers start with UID
`2147491672`{.fm-code-in-text}:

``` programlisting
# podman run --rm --userns=auto ubi8 cat /proc/self/uid_map
     0 2147491672   1024
# podman run --rm --userns=auto ubi8 cat /proc/self/uid_map
     0 2147491672   1024
```

[]{#10.htm_pgfId-1114506}The name used in /etc/subuid and the minimum
and maximum number of UIDs used for user namespaces is defined in the
storage.conf file described in
[]{#10.htm_marker-1114507}[]{#10.htm_marker-1114508}[]{#10.htm_marker-1114509}[]{#10.htm_marker-1114510}table
10.4.[]{#10.htm_id_z912g9l4dv}

[]{#10.htm_pgfId-1119178}Table 10.4  The fields used within storage.conf
files to override the user namespace auto settings

+-----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1119182}Option                                                               | []{#10.htm_pgfId-1119184}Description                |
+-----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1119186}`root-auto-userns-user`{.fm-code-in-text1}[]{#10.htm_marker-1121477} | []{#10.htm_pgfId-1119188}Defines the username used  |
|                                                                                               | to look up one or more UID/GID ranges in the        |
|                                                                                               | /etc/subuid and /etc/subgid file. These ranges are  |
|                                                                                               | partitioned into containers configured to create a  |
|                                                                                               | user namespace automatically. Containers configured |
|                                                                                               | to automatically create a user namespace can still  |
|                                                                                               | overlap with containers with an explicit mapping    |
|                                                                                               | set. The `root-auto-userns-user`{.fm-code-in-text1} |
|                                                                                               | setting is ignored by rootless users. It defaults   |
|                                                                                               | to `containers`{.fm-code-in-text1}.                 |
+-----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1119190}`auto-userns-min-size`{.fm-code-in-text1}[]{#10.htm_marker-1121482}  | []{#10.htm_pgfId-1119192}Defines the minimum size   |
|                                                                                               | for a user namespace created automatically. It      |
|                                                                                               | defaults to `1024`{.fm-code-in-text1}.              |
+-----------------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1119194}`auto-userns-max-size`{.fm-code-in-text1}[]{#10.htm_marker-1121487}  | []{#10.htm_pgfId-1119196}Defines the maximum size   |
|                                                                                               | for a user namespace created automatically. It      |
|                                                                                               | defaults to `65536`{.fm-code-in-text1}.             |
+-----------------------------------------------------------------------------------------------+-----------------------------------------------------+

### []{#10.htm_pgfId-1114536}10.3.2 User-namespaced Linux capabilities {#10.htm_heading_id_15 .fm-head1}

[]{#10.htm_pgfId-1114542}In
[]{#10.htm_marker-1114537}[]{#10.htm_marker-1114538}[]{#10.htm_marker-1114539}[]{#10.htm_marker-1114540}[]{#10.htm_marker-1114541}section
10.2 you learned about Linux capabilities and how they are used to break
up the power of root. When a container is launched within a user
namespace, it can have Linux capabilities. These capabilities can only
affect the UIDs and GIDs mapped into the user namespace. Capabilities
that do not involve UIDs and GIDs are limited. Usually, they only affect
the other namespaces that are mapped with the user namespace.

[]{#10.htm_pgfId-1114543}For example, `CAP_NET_ADMIN`{.fm-code-in-text}
is the capability that allows you to manipulate the network stack. It
allows a process to set up firewall rules and network routing tables. A
process with a namespaced `CAP_NET_ADMIN`{.fm-code-in-text} is only
allowed to modify the namespaced network assigned to the user namespace,
not the host's network namespace.

[]{#10.htm_pgfId-1114544}In the following example, the list of
capabilities within a user-namespaced container is the same as when you
launch one without a user namespace. In the second command using the
`--userns=auto`{.fm-code-in-text} flag[]{#10.htm_marker-1114545}, the
capabilities are namespaced capabilities:

``` programlisting
# podman run --rm ubi8 capsh --print | grep Current
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
➥ cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,
➥ cap_setfcap+eip
# podman run --rm --userns=auto ubi8 capsh --print | grep Current
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
➥ cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,
➥ cap_setfcap+eip
```

[]{#10.htm_pgfId-1114554}To prove this, attempt to
`chown`{.fm-code-in-text} a file within a container to a nonexistent
UID. It fails because the `CAP_CHOWN`{.fm-code-in-text}
capability[]{#10.htm_marker-1114555} only allows the root process inside
a container to `chown`{.fm-code-in-text} files to any UID as long as the
UID is mapped to the user namespace:

``` programlisting
# podman run --rm --userns=auto:size=5000 ubi8 chown 6000 /etc/motd
chown: changing ownership of '/etc/motd': Invalid argument
```

[]{#10.htm_pgfId-1114558}It succeeds if you `chown`{.fm-code-in-text} to
a UID mapped within the user namespace:

``` programlisting
# podman run --rm --userns=auto:size=5000 ubi8 chown 4000 /etc/motd
```

[]{#10.htm_pgfId-1114560}Suppose you launch all of your system
containers with the `--userns=auto`{.fm-code-in-text}
`flag`{.fm-code-in-text}. In that case, you get the benefit of running
the container within its unique user namespace isolated from all other
containers and UIDs on the host system. You also get root privileges
with limited capabilities, and these processes outside the container
have no capabilities on the host
[]{#10.htm_marker-1114561}[]{#10.htm_marker-1114562}[]{#10.htm_marker-1114563}[]{#10.htm_marker-1114564}[]{#10.htm_marker-1114565}system.

### []{#10.htm_pgfId-1114567}10.3.3 Rootless Podman with the - -userns=auto flag {#10.htm_heading_id_16 .fm-head1}

[]{#10.htm_pgfId-1114572}The[]{#10.htm_marker-1114568}[]{#10.htm_marker-1114569}[]{#10.htm_marker-1114570}[]{#10.htm_marker-1114571}
`--userns=auto`{.fm-code-in-text} works with rootless containers, based
on the number of UIDs available to the user. But this number is very
limited. You can run the previous examples and see that the user
namespaces start at UID `1`{.fm-code-in-text}. UID `1`{.fm-code-in-text}
is relative to the user namespace of the rootless user:

``` programlisting
$ podman run --userns=auto ubi8 cat /proc/self/uid_map
     0   1      1024
$ podman run --userns=auto ubi8 cat /proc/self/uid_map
     0   1025   1024
```

[]{#10.htm_pgfId-1114577}If you examine your user namespace, you'll see
that UID `1`{.fm-code-in-text} in your user namespace is
`100000`{.fm-code-in-text}:

``` programlisting
$ podman run --rm ubi8 cat /proc/self/uid_map
     0   3267    1
     1   100000    65536
```

[]{#10.htm_pgfId-1114581}This means the first rootless user-namespace
container is running UID `0`{.fm-code-in-text} mapped to UID
`1`{.fm-code-in-text} in the rootless user namespace. UID
`1`{.fm-code-in-text} is the rootless UID `100000`{.fm-code-in-text} on
the host system. A couple of problems with rootless users of
`--userns=auto`{.fm-code-in-text} is that since the default user only
gets 65,536 UIDS, at max, you can launch 64 containers, and you cannot
run any containers that require more than 65,536
[]{#10.htm_marker-1114582}[]{#10.htm_marker-1114583}[]{#10.htm_marker-1114584}[]{#10.htm_marker-1114585}UIDs.

[]{#10.htm_pgfId-1114587}[Note]{.fm-callout-head} If you launch a
container without using the `--userns=auto`{.fm-code-in-text1}
flag[]{#10.htm_marker-1114586}, the UIDs mapped to the user namespace
can and probably do overlap with the UIDs in the user-namespaced
isolated containers. You need to be careful that none of the UIDs used
within such containers use those UIDs because those UIDs are vulnerable
to attack from a UID perspective. To avoid overlaps, I suggest using a
high range of UIDs.

### []{#10.htm_pgfId-1114589}10.3.4 User volumes with the - -userns=auto flag {#10.htm_heading_id_17 .fm-head1}

[]{#10.htm_pgfId-1114594}When
[]{#10.htm_marker-1114590}[]{#10.htm_marker-1114591}[]{#10.htm_marker-1114592}[]{#10.htm_marker-1114593}using
the user namespace, it is difficult to determine which user's UID needs
to own the volume you're mounting into a container to allow access. In
the following example, you first create a directory and then volume
mount it into the container and attempt to create a file in it.

[]{#10.htm_pgfId-1114595}Listing 10.6 Drawbacks of using volumes within
a user namespace

``` programlisting
# mkdir /mnt/test
# ls -ld /mnt/test
drwxr-xr-x. 2 root root 6 Feb 8 16:23 /mnt/test                           ❶
# podman run --rm -v /mnt/test:/mnt/test --userns=auto ubi8 ls -ld /mnt/test
drwxr-xr-x. 2 nobody nobody 6 Feb 8 21:23 /mnt/test                       ❷
# podman run --rm -v /mnt/test:/mnt/test:Z --userns=auto ubi8 touch /mnt/test
touch: setting times of '/mnt/test': 
➥ Permission denied                                                      ❸
```

[]{#10.htm_pgfId-1128036}[❶]{.fm-combinumeral} The directory is owned by
root on the host.

[]{#10.htm_pgfId-1128057}[❷]{.fm-combinumeral} The directory is listed
as the user nobody, since the root UID=0 is not mapped into the user
namespace. All files and directories owned by UIDs not mapped to the
container are treated as the nobody user. The :Z tells Podman to relabel
for SELinux.

[]{#10.htm_pgfId-1128081}[❸]{.fm-combinumeral} Even root is not allowed
to write into a directory of an unmapped user, unless the directory is
world writable.

[]{#10.htm_pgfId-1114608}Podman supports a special option on the
`--volume`{.fm-code-in-text} flag
`U`{.fm-code-in-text}[]{#10.htm_marker-1114607}`,`{.fm-code-in-text}
which tells Podman to `chown`{.fm-code-in-text} all files or directories
in the source directory to match the UID of the container's primary
process:

``` programlisting
# ls -ld /mnt/test
drwxr-xr-x. 2 root root 6 Feb 8 16:38 /mnt/test
# podman run --rm -v /mnt/test:/mnt/test:Z,U 
➥ --userns=auto ubi8 touch /mnt/test/test1       ❶
# ls -ld /mnt/test
drwxr-xr-x. 2 2147503960 2147503960 
➥ 19 Feb 8 16:38 /mnt/test                       ❷
```

[]{#10.htm_pgfId-1127904}[❶]{.fm-combinumeral} After adding the U
option, processes within the container can write to the volume.

[]{#10.htm_pgfId-1127925}[❷]{.fm-combinumeral} Podman chowned the source
volume to 2147503960 to match the root user mapping in the container.

[]{#10.htm_pgfId-1114618}A new, advanced feature of the Linux kernel is
called `idmapped`{.fm-code-in-text} `mounts`{.fm-code-in-text}. It
allows users to remap the UIDs inside a source volume to match the user
namespace without actually `chown`{.fm-code-in-text}ing the files on
disk. In the next example, you will recreate the /mnt/test directory
and, this time, mount it with the `idmap`{.fm-code-in-text}
option[]{#10.htm_marker-1114619}. When the ID-mapped volume shows up
inside the container, the files appear to be owned by the root of the
user namespace, and you are allowed to read and write the files based on
standard permissions. When you finish writing the files, they are mapped
back correctly into the user namespace, unlike the `U`{.fm-code-in-text}
option, which writes them back based on the real UID of the container
process:

``` programlisting
# chown -R root:root /mnt/test                         ❶
# podman run --rm -v /mnt/test:/mnt/test:idmap,Z 
➥ --userns=auto ubi8 ls -ld /mnt/test                 ❷
drwxr-xr-x. 2 root root 31 Feb 9 11:56 /mnt/test
# podman run --rm -v /mnt/test:/mnt/test:idmap,Z 
➥ --userns=auto ubi8 touch /mnt/test/test             ❸
# ls -l /mnt/test                                      ❹
total 0
-rw-r--r--. 1 root root 0 Feb 9 06:57 test
-rw-r--r--. 1 root root 0 Feb 8 17:02 test1
```

[]{#10.htm_pgfId-1127607}[❶]{.fm-combinumeral} Reset the source volume
to root ownership.

[]{#10.htm_pgfId-1127628}[❷]{.fm-combinumeral} Mount the source volume
/mnt/test into the container with the idmap option. Notice the path is
owned by root within the container.

[]{#10.htm_pgfId-1127655}[❸]{.fm-combinumeral} Create a file within the
source directory to prove the container can write to the directory.

[]{#10.htm_pgfId-1127672}[❹]{.fm-combinumeral} Notice on the host system
that the newly created file is owned by the real root.

[]{#10.htm_pgfId-1114635}[Note]{.fm-callout-head} The
`idmap`{.fm-code-in-text1} features[]{#10.htm_marker-1114634} are brand
new as of writing and are not available on all filesystems. It is only
supported in privileged mode at this time, but hopefully, this changes
soon. Currently, the OCI runtime that supports this feature is
`crun`{.fm-code-in-text1}.

[]{#10.htm_pgfId-1114636}Understanding the security benefits of running
containers with user namespaces is very important. Next, I'll show you
some security benefits in the
[]{#10.htm_marker-1114637}[]{#10.htm_marker-1114638}[]{#10.htm_marker-1114639}[]{#10.htm_marker-1114640}other
[]{#10.htm_marker-1114641}[]{#10.htm_marker-1114642}[]{#10.htm_marker-1114643}namespaces.

## []{#10.htm_pgfId-1114645}10.4 Process isolation: PID namespace {#10.htm_heading_id_18 .fm-head}

[]{#10.htm_pgfId-1114649}I
[]{#10.htm_marker-1114646}[]{#10.htm_marker-1114647}[]{#10.htm_marker-1114648}often
say that namespaces were not intended as a security mechanism, but in
reality, they do provide additional security via isolation and
information masking. The PID namespace hides the fact that there are
other processes running on a system. Being aware that a particular
application is running on a system can be valuable to someone hacking a
container. When you run a container within its own PID namespace, it is
only able to see the other processes running within the container. By
default, Podman runs containers within their own PID namespaces.

[]{#10.htm_pgfId-1114650}Some applications shipped as container images
require additional access to the system. If you have such an application
that needs to monitor the processes on the host, you'll need to turn off
the PID namespace to expose all the processes on the system. Turning off
the PID namespace with Podman is simple: just add the
`--pid=host`{.fm-code-in-text} flag[]{#10.htm_marker-1114651}. In the
next couple of examples, you see that with the PID namespace, you only
see the container process within the container. The second command
exposes all processes within the system to the
[]{#10.htm_marker-1114652}[]{#10.htm_marker-1114653}[]{#10.htm_marker-1114654}container.

[]{#10.htm_pgfId-1114655}Listing 10.7 The differences between using the
`pid`{.fm-code-in-text} namespace and disabling it

``` programlisting
$ podman run --rm ubi8 find /proc -maxdepth 1 
➥ -type d -regex ".*/[0-9]*"                     ❶
/proc/1
$ podman run --rm --pid=host ubi8 find 
➥ /proc -maxdepth 1 -type d -regex ".*/[0-9]*"   ❷
/proc/1
/proc/2
/proc/3
/proc/4
...
```

[]{#10.htm_pgfId-1127480}[❶]{.fm-combinumeral} Running the find command
looking for all processes within the container, you see only one
process.

[]{#10.htm_pgfId-1127501}[❷]{.fm-combinumeral} Running the find command
in a \--pid=host container, you see all of the processes on the system.

[]{#10.htm_pgfId-1114669}[Note]{.fm-callout-head} On an SELinux system,
exposing the host's processes via the `--pid=host`{.fm-code-in-text1}
option[]{#10.htm_marker-1114668} also has a side effect of disabling
SELinux separation. SELinux blocks access to the host's processes and
causes problems when processes within the container interact with these
processes. Other security mechanisms, like dropped capabilities and user
namespaces, are not dropped and can block access to the processes.

## []{#10.htm_pgfId-1114671}10.5 Network isolation: Network namespace {#10.htm_heading_id_19 .fm-head}

[]{#10.htm_pgfId-1114675}The
[]{#10.htm_marker-1114672}[]{#10.htm_marker-1114673}[]{#10.htm_marker-1114674}network
namespace sets up isolation from the host network. It allows Podman to
set up virtual private networks to control which containers can talk to
other containers. Podman has the ability to create multiple networks and
then assign containers within those networks. By default, all containers
run within the host network. But it is simple to set up additional
networks using the `podman`{.fm-code-in-text}
`network`{.fm-code-in-text} `create`{.fm-code-in-text}
command[]{#10.htm_marker-1114676}. In the next example, you will create
two networks---`net1`{.fm-code-in-text}[]{#10.htm_marker-1114677} and
`net2`{.fm-code-in-text}[]{#10.htm_marker-1114678}:

``` programlisting
$ podman network create net1
net1
$ podman network create net2
net2
```

[]{#10.htm_pgfId-1114683}When you create new containers, you can assign
them to a specific network with the `--network`{.fm-code-in-text}
`net1`{.fm-code-in-text} option[]{#10.htm_marker-1114684}:

``` programlisting
$ podman run -d --network net1 --name 
➥ cnet1 ubi8 sleep 1000                                 ❶
74ce5b2396f77fce8c499b121aeb8731f1e1b22e363a6a72d243487cf93a5897
$ podman run --network net1 alpine 
➥ ping -c 1 cnet1                                       ❷
PING cnet1 (10.89.0.4): 56 data bytes
64 bytes from 10.89.0.4: seq=0 ttl=42 time=0.077 ms
```

[]{#10.htm_pgfId-1127304}[❶]{.fm-combinumeral} Start a background
container in network net1.

[]{#10.htm_pgfId-1127325}[❷]{.fm-combinumeral} Make sure the container
is reachable from another container within the network.

[]{#10.htm_pgfId-1114694}If you attempt to ping the network from the
default network namespace via the container name, or even the IP
address, it fails:

``` programlisting
$ podman run --rm alpine ping -c 1 cnet1
ping: bad address 'cnet1'
$ podman run alpine ping -c 1 10.89.0.4         ❶
PING 10.89.0.4 (10.89.0.4): 56 data bytes
64 bytes from 10.89.0.4: seq=0 ttl=42 time=0.073 ms
```

[]{#10.htm_pgfId-1127243}[❶]{.fm-combinumeral} Make sure the cnet1
container is still available by the IP address.

[]{#10.htm_pgfId-1114701}Similarly, if you attempt to ping it from a
different network, `--network`{.fm-code-in-text}
`net2`{.fm-code-in-text}, it also fails:

``` programlisting
$ podman run --rm --network net2 alpine ping -c 1 cnet1
ping: bad address 'cnet1'
```

[]{#10.htm_pgfId-1114704}Creating private networks for your containers
allows you to isolate them from each other, even over the network, using
the network namespace.

[]{#10.htm_pgfId-1114705}[Note]{.fm-callout-head} For these examples, I
used the alpine image because it comes with the ping package installed,
while the ubi8 image does not include it. You can easily add the ping
executable to ubi8 via a Containerfile and `podman`{.fm-code-in-text1}
`build`{.fm-code-in-text1}.

[]{#10.htm_pgfId-1114706}You can expose your host network to the
container using the `--net=host`{.fm-code-in-text} option, allowing a
container to bind to ports on the host. In certain situations, you can
get better performance when you eliminate the network
[]{#10.htm_marker-1114707}[]{#10.htm_marker-1114708}[]{#10.htm_marker-1114709}namespace.

## []{#10.htm_pgfId-1114711}10.6 IPC isolation: IPC namespace {#10.htm_heading_id_20 .fm-head}

[]{#10.htm_pgfId-1114715}The
[]{#10.htm_marker-1123073}[]{#10.htm_marker-1123074}[]{#10.htm_marker-1123075}inter-process
communication (IPC) namespace isolates certain IPC resources, namely,
System V IPC objects and POSIX message queues. It also isolates the
/dev/shm tmpfs from the host and other containers. The IPC namespace
allows containers to create named IPCs with the same name as other
containers on the same system, without causing a conflict.

[]{#10.htm_pgfId-1114716}Thus, IPC isolation prevents one container from
attacking another via an IPC or /dev/shm. You can join two
IPC-namespaced containers together using the
`--ipc=container:NAME`{.fm-code-in-text} or run them within a pod. They
share the same IPC namespace. They can use IPC together but are still
isolated from the host.

[]{#10.htm_pgfId-1114717}Listing 10.8 IPC namespace keeping /dev/shm
private to each container

``` programlisting
$ podman run -d --rm --name ipc1 ubi8 bash 
➥ -c "touch /dev/shm/ipc1; sleep 1000"                              ❶
93df44264dd4b87d24f59dfffb92a6a0b6359bc5bcf94213d5e38499a10d3f3e
$ podman run --rm ubi8 ls /dev/shm                                   ❷
$ podman run --rm --ipc=container:ipc1 ubi8 ls /dev/shm              ❸
ipc1
```

[]{#10.htm_pgfId-1127009}[❶]{.fm-combinumeral} Create a container named
ipc1, touch /dev/shm/ipc1, and then go to sleep.

[]{#10.htm_pgfId-1127030}[❷]{.fm-combinumeral} Run a second container to
see that the /dev/shm/ipc does not exist because the container is
running in a separate IPC namespace.

[]{#10.htm_pgfId-1127047}[❸]{.fm-combinumeral} Run a container with a
shared IPC namespace, and you will see that the /dev/shm is shared and
the IPC file exists.

[]{#10.htm_pgfId-1114727}You can share the host's IPC namespace with
your container by executing the `--ipc=host`{.fm-code-in-text}
[]{#10.htm_marker-1114728}[]{#10.htm_marker-1114729}[]{#10.htm_marker-1114730}option.

[]{#10.htm_pgfId-1114731}[Note]{.fm-callout-head} On SELinux systems,
Podman modifies all containers that share the same IPC namespace to
share the same SELinux label. Otherwise, SELinux blocks the IPC
communications between containers when the labels do not match. Using
the `--ipc=host`{.fm-code-in-text1} option causes SELinux separation to
be disabled; otherwise, SELinux blocks access to the host's IPC.

## []{#10.htm_pgfId-1114733}10.7 Filesystem isolation: Mount namespace {#10.htm_heading_id_21 .fm-head}

[]{#10.htm_pgfId-1114738}The
[]{#10.htm_marker-1114734}[]{#10.htm_marker-1114735}[]{#10.htm_marker-1114736}[]{#10.htm_marker-1114737}next,
and perhaps most important, namespace isolation is the mount namespace.
The mount namespace hides the entire host filesystem from the container
processes. The container processes only see the filesystem content
defined to be in the mount namespace. Podman creates the filesystem
mount point `rootfs`{.fm-code-in-text}[]{#10.htm_marker-1114739} and
bind mounts all volumes onto it. Podman then executes the OCI runtime,
which then executes the `pivot_root`{.fm-code-in-text}
syscall[]{#10.htm_marker-1114740}, which in turn changes the root mount
in the mount namespace of the calling process. It moves the root mount
to the rootfs directory. Thus, all of the content of the host operating
system disappears, and the container processes only see the provided
content. By dropping the `CAP_SYS_ADMIN`{.fm-code-in-text}
capability[]{#10.htm_marker-1114741}, the processes inside the container
have no ability to affect the mounts of the rootfs to expose the
underlying filesystems.

[]{#10.htm_pgfId-1114743}[Note]{.fm-callout-head} Read the
`pivot_root(2)`{.fm-code-in-text1} man page[]{#10.htm_marker-1114742} to
find out more about the `pivot_ root`{.fm-code-in-text1} system call:
`man`{.fm-code-in-text1} `2`{.fm-code-in-text1}
`pivot_root`{.fm-code-in-text1}.

[]{#10.htm_pgfId-1114744}While the mount namespace and the lack of
`CAP_SYS_ADMIN`{.fm-code-in-text} provide excellent isolation, there
have been some container escapes to the underlying filesystem, which is
where SELinux steps in. One example of this was a flaw in the OCI
runtime `runc`{.fm-code-in-text}[]{#10.htm_marker-1114745}
(CVE-2019-5736), which allowed container processes to overwrite the
`runc`{.fm-code-in-text} executable[]{#10.htm_marker-1114746} in rootful
containers. This exploit allowed containers to escape their containment
and take over users' systems. This exploit affected all container
engines, including Podman, Docker, CRI-O, and containerd. The good news
is that well-configured SELinux can stop it. Podman is mainly run in
rootless mode, and rootless Podman is protected in two ways: SELinux and
not running as root. I wrote about this exploit in this "Latest
container exploit (runc) can be blocked by SELinux" blog post, available
on Red Hat's website
[]{#10.htm_marker-1114747}[]{#10.htm_marker-1114748}[]{#10.htm_marker-1114749}[]{#10.htm_marker-1114750}([http://mng.bz/Qn6j](http://mng.bz/Qn6j){.url}).

## []{#10.htm_pgfId-1114752}10.8 Filesystem isolation: SELinux {#10.htm_heading_id_22 .fm-head}

[]{#10.htm_pgfId-1114757}SELinux
[]{#10.htm_marker-1114753}[]{#10.htm_marker-1114754}[]{#10.htm_marker-1114755}[]{#10.htm_marker-1114756}is
a labeling system, where every process and filesystem object gets
labeled. Then rules are written to the kernel about how the process
labels interact with the filesystem labels as well as other process
labels. SELinux supports multiple different security mechanisms;
containers take advantage of two of these. The first is called *type
enforcement*, with which SELinux controls what processes can do based on
their type. The second is called *MCS enforcement*, and it additionally
uses categories assigned to processes.

[]{#10.htm_pgfId-1114758}SELinux is not supported on all distributions.
Fedora, RHEL, and other Red Hat distributions support SELinux, while
Debian-based distributions, like Ubuntu, often do not. If your Linux
distribution does not support SELinux, you might want to skip this
section.

### []{#10.htm_pgfId-1114760}10.8.1 SELinux type enforcement {#10.htm_heading_id_23 .fm-head1}

[]{#10.htm_pgfId-1114766}The
[]{#10.htm_marker-1120087}[]{#10.htm_marker-1120088}[]{#10.htm_marker-1120089}[]{#10.htm_marker-1120090}[]{#10.htm_marker-1120091}SELinux
labels have four components: the SELinux user, role, type, and MCS level
(see table 10.5).[]{#10.htm_id_hi509vooki1y}

[]{#10.htm_pgfId-1119978}Table 10.5 SELinux label type examples

+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1119988}Object      | []{#10.htm_pgfId-1119990}User                              | []{#10.htm_pgfId-1119992}Role                              | []{#10.htm_pgfId-1119994}Type                                  | []{#10.htm_pgfId-1119996}MCS level                           |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1119998}Container   | []{#10.htm_pgfId-1120000}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120002}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120004}`container_t`{.fm-code-in-text1}      | []{#10.htm_pgfId-1120006}`s0:c1,c2`{.fm-code-in-text1}       |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120008}Container   | []{#10.htm_pgfId-1120010}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120012}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120014}`container_t`{.fm-code-in-text1}      | []{#10.htm_pgfId-1120016}`s0:c361,c871`{.fm-code-in-text1}   |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120018}Container   | []{#10.htm_pgfId-1120020}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120022}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120024}`container_file_t`{.fm-code-in-text1} | []{#10.htm_pgfId-1120026}`s0:c1,c2`{.fm-code-in-text1}       |
| file                                 |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120028}Container   | []{#10.htm_pgfId-1120030}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120032}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120034}`container_file_t`{.fm-code-in-text1} | []{#10.htm_pgfId-1120036}`s0:s361,c871`{.fm-code-in-text1}   |
| file                                 |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120038}/etc/shadow | []{#10.htm_pgfId-1120040}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120042}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120044}`shadow_t`{.fm-code-in-text1}         | []{#10.htm_pgfId-1120046}`s0`{.fm-code-in-text1}             |
| label                                |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120048}Container   | []{#10.htm_pgfId-1120050}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120052}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120054}`spc_t`{.fm-code-in-text1}            | []{#10.htm_pgfId-1120056}`s0`{.fm-code-in-text1}             |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120058}User        | []{#10.htm_pgfId-1120060}`unconfined_u`{.fm-code-in-text1} | []{#10.htm_pgfId-1120062}`unconfined_r`{.fm-code-in-text1} | []{#10.htm_pgfId-1120064}`unconfined_t`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120066}`s0-s0:c0.c1023`{.fm-code-in-text1} |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+

[]{#10.htm_marker-1125639}[]{#10.htm_pgfId-1114852}In this section, you
will concentrate on the SELinux type. I wrote *The SELinux Coloring
Book* to explain the labeling, using the analogy of cats and dogs
(figure 10.3).

::: figure
![](images/10-03.png){.calibre18}

[]{#10.htm_pgfId-1130140}Figure 10.3 *The SELinux Coloring
Book*[]{#10.htm_id_1vp0m2w67vu8}[]{#10.htm_marker-1130141}
([http://mng.bz/Xay6](http://mng.bz/Xay6){.url})
:::

[]{#10.htm_pgfId-1114859}As the coloring book explains, imagine you have
a group of processes labeled as `cat`{.fm-code-in-text} types and
another group of processes labeled as `dog`{.fm-code-in-text} types.
Imagine you also have objects on the filesystem labeled as
`dog`{.fm-code-in-text} `food`{.fm-code-in-text} type and
`cat`{.fm-code-in-text} `food`{.fm-code-in-text} type. Finally, imagine
you write rules to the kernel saying that `cat`{.fm-code-in-text} types
are allowed to eat `cat`{.fm-code-in-text} `food`{.fm-code-in-text}
types, and `dog`{.fm-code-in-text} types can eat `dog`{.fm-code-in-text}
`food`{.fm-code-in-text} types. With SELinux, anything that is not
explicitly allowed is denied. The `cat`{.fm-code-in-text} processes can
eat the `cat`{.fm-code-in-text} `food`{.fm-code-in-text}, and the
`dog`{.fm-code-in-text} processes can eat the `dog`{.fm-code-in-text}
`food`{.fm-code-in-text}, but if a `dog`{.fm-code-in-text} type attempts
to eat `cat`{.fm-code-in-text} `food`{.fm-code-in-text}, the Linux
kernel steps in and blocks the access.

[]{#10.htm_pgfId-1114860}Containers work the same way. Podman labels
each container process with the `container_t`{.fm-code-in-text}
type[]{#10.htm_marker-1114861}. All the files within the container are
labeled as a `container_file_t`{.fm-code-in-text}
type[]{#10.htm_marker-1114862}. Rules are written into the kernel,
saying the `container_t`{.fm-code-in-text} processes are allowed to
read, write, and execute files labeled with the
`container_file_t`{.fm-code-in-text} type[]{#10.htm_marker-1114863}.

[]{#10.htm_pgfId-1114864}[Note]{.fm-callout-head} SELinux does not care
about ownerships and permissions, so you can, for example, define a
process type that has access to all filesystem types and is not confined
by SELinux, often called an *unconfined type*. You can see a couple of
unconfined types running on your Linux system. The
`id`{.fm-code-in-text1} `-Z`{.fm-code-in-text1} command shows your user
processes are running with the `unconfined_t`{.fm-code-in-text1}
type[]{#10.htm_marker-1114865} and a privileged container runs with the
`spc_t`{.fm-code-in-text1} type.

[]{#10.htm_pgfId-1114866}When Podman constructs the rootfs for the
container, it labels all of the files in the rootfs as
`container_file_t`{.fm-code-in-text}. This means the container process
can read, write, and execute all of the files within the container's
rootfs, but if they escape to the host filesystem, the SELinux kernel
blocks access to the host filesystem objects. In the next few examples,
you can examine what is happening in containers with SELinux. In this
first example, you can see the label of the containerized process;
notice the type is
`container_t`{.fm-code-in-text}[]{#10.htm_marker-1114867}. But when you
run with the `--privileged`{.fm-code-in-text}
flag[]{#10.htm_marker-1114868}, Podman changes the label to
`spc_t`{.fm-code-in-text}, an unconfined domain:

``` programlisting
$ podman run --rm ubi8 cat /proc/self/attr/current
system_u:system_r:container_t:s0:c694,c944
$ podman run --rm --privileged ubi8 cat /proc/self/attr/current
unconfined_u:system_r:spc_t:s0
```

[]{#10.htm_pgfId-1114874}Examine the files within the container, using
the `ls`{.fm-code-in-text} `-Z`{.fm-code-in-text}
command[]{#10.htm_marker-1114873}. You see the files are all labeled as
`container_file_t`{.fm-code-in-text}:

``` programlisting
$ podman run --rm ubi8 ls -Z /
system_u:object_r:container_file_t:s0:c88,c191 bin
system_u:object_r:container_file_t:s0:c88,c191 boot
system_u:object_r:container_file_t:s0:c88,c191 dev
system_u:object_r:container_file_t:s0:c88,c191 etc
system_u:object_r:container_file_t:s0:c88,c191 home
system_u:object_r:container_file_t:s0:c88,c191 lib
...
```

[]{#10.htm_pgfId-1114883}Because Podman configured the SELinux
environment properly, container processes have full access to all of the
objects within the container's rootfs, and SELinux pretty much stays out
of the way, unless something else breaks down and somehow the container
process escapes out of the rootfs into the host operating system. At
that point, SELinux starts blocking access. Imagine the container
process you are running on your system broke out of the container and
attempted to read the SSH keys in your home directory. Let's look at the
labels on those files. You see that those files are labeled with the
`ssh_home_t`{.fm-code-in-text} type[]{#10.htm_marker-1114884}:

``` programlisting
$ ls -1Z $HOME/.ssh/
unconfined_u:object_r:ssh_home_t:s0 authorized_keys
unconfined_u:object_r:ssh_home_t:s0 authorized_keys2
unconfined_u:object_r:ssh_home_t:s0 config
...
```

[]{#10.htm_pgfId-1114891}Because there is no rule in SELinux policy
allowing a `container_t`{.fm-code-in-text}
process[]{#10.htm_marker-1114890} to read an
`ssh_home_t`{.fm-code-in-text} file, the SELinux kernel blocks access.
You can demonstrate this by volume mounting the .ssh directory into a
container. When you attempt to list the directory, the container process
gets `Permission`{.fm-code-in-text} `denied`{.fm-code-in-text}:

``` programlisting
$ podman run -v $HOME/.ssh:/.ssh ubi8 ls /.ssh
ls: cannot open directory '/.ssh': Permission denied
```

[]{#10.htm_pgfId-1114894}As you learned in section 3.1.2, Podman has
SELinux volume options `z`{.fm-code-in-text} and `Z`{.fm-code-in-text},
which tell SELinux to relabel the content of the source volume to make
it usable inside of the container. This is not a good idea to do with
the .ssh directory.

[]{#10.htm_pgfId-1114895}Instead, let's create a temporary file and show
the SELinux labels in action. First, create a temporary file in your
home directory named foo. Label it `user_home_t`{.fm-code-in-text}.
Volume mount it into the container, and see that the container process
is denied access.

[]{#10.htm_pgfId-1114896}Listing 10.9 How SELinux works with volumes
inside Podman containers

``` programlisting
$ mkdir foo
$ ls -Zd foo                                          ❶
unconfined_u:object_r:user_home_t:s0 foo
$ podman run -v ./foo:/foo ubi8 touch /foo/bar        ❷
touch: cannot touch '/foo/bar': Permission denied
$ podman run --privileged -v ./foo:/foo ubi8 touch 
➥ /foo/bar                                           ❸
$ ls -Z foo                                           ❹
unconfined_u:object_r:user_home_t:s0 bar
$ rm foo/bar
$ podman run -v ./foo:/foo:Z ubi8 touch /foo/bar      ❺
$ ls -Z ./foo                                         ❻
system_u:object_r:container_file_t:s0:c454,c510 bar
```

[]{#10.htm_pgfId-1126543}[❶]{.fm-combinumeral} Files created in your
home directory default to the user_home_t type.

[]{#10.htm_pgfId-1126567}[❷]{.fm-combinumeral} By default, container
processes are not allowed to write to content in the user\'s home
directory. Podman does not change the labels on volumes by default.

[]{#10.htm_pgfId-1126584}[❸]{.fm-combinumeral} The \--privileged flag
causes SELinux separation to be disabled, running the container with an
unconfined type (spc_t). The command simulates a container escape,
showing that without SELinux, an escaped container is allowed to write
to the filesystem.

[]{#10.htm_pgfId-1126601}[❹]{.fm-combinumeral} The file created by the
privileged container has the label of the user home directory
(user_home_t).

[]{#10.htm_pgfId-1126618}[❺]{.fm-combinumeral} The :Z option on the
volume mount tells Podman to relabel the content of the directory to
match the labels of files within the rootfs (container_file_t).

[]{#10.htm_pgfId-1126635}[❻]{.fm-combinumeral} The labels of the newly
created file match the label within the container.

[]{#10.htm_pgfId-1114916}SELinux type enforcement has shown itself to be
invaluable in blocking container escape when no other mechanism was
available. Table 10.6 shows a list of container escapes that have been
blocked by SELinux.[]{#10.htm_id_k8ptbkj4chg7}

[]{#10.htm_pgfId-1114946}SELinux type enforcement does a great job
protecting the host operating system from container processes. The
problem is that `type`{.fm-code-in-text} `enforcement`{.fm-code-in-text}
does not protect you from one container attacking
[]{#10.htm_marker-1114947}[]{#10.htm_marker-1114948}[]{#10.htm_marker-1114949}[]{#10.htm_marker-1114950}[]{#10.htm_marker-1114951}another.

[]{#10.htm_pgfId-1120491}Table 10.6 Major container exploits blocked by
SELinux

+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120495}Common        | []{#10.htm_pgfId-1120497}Description                |
| vulnerabilities and exposures          |                                                     |
+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120499}CVE-2019-5736 | []{#10.htm_pgfId-1120501}Execution of malicious     |
|                                        | containers allows for container escape and access   |
|                                        | to the host filesystem.                             |
+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120503}CVE-2015-3627 | []{#10.htm_pgfId-1120505}Insecure opening of        |
|                                        | file-descriptor 1, leading to privilege escalation  |
+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120507}CVE-2015-3630 | []{#10.htm_pgfId-1120509}Read/write proc paths      |
|                                        | allow host modification and information disclosure. |
+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120511}CVE-2015-3631 | []{#10.htm_pgfId-1120513}Volume mounts allow Linux  |
|                                        | Security Modules (LSM) profile escalation.          |
+----------------------------------------+-----------------------------------------------------+
| []{#10.htm_pgfId-1120515}CVE-2016-9962 | []{#10.htm_pgfId-1120517}`runc`{.fm-code-in-text1}  |
|                                        | exec vulnerability                                  |
+----------------------------------------+-----------------------------------------------------+

### []{#10.htm_pgfId-1114953}10.8.2 SELinux Multi-Category Security separation {#10.htm_heading_id_24 .fm-head1}

[]{#10.htm_pgfId-1114960}SELinux[]{#10.htm_marker-1114954}
[]{#10.htm_marker-1114955}[]{#10.htm_marker-1114956}[]{#10.htm_marker-1114957}[]{#10.htm_marker-1114958}[]{#10.htm_marker-1114959}does
not block processes of one type from attacking other processes of the
same type. One way to think about this is going back to the cats and
dogs analogy. Type enforcement prevents the `dog`{.fm-code-in-text} from
eating the `cat`{.fm-code-in-text} `food`{.fm-code-in-text}, but it does
not prevent `cat-A`{.fm-code-in-text} from eating
`cat-B`{.fm-code-in-text}'s `cat`{.fm-code-in-text}
`food`{.fm-code-in-text}.

[]{#10.htm_pgfId-1114961}Recall when I introduced this section, I said
there were two types of SELinux security Podman takes advantage of.
SELinux has a mechanism to enforce process separation based on the
Multi-Category Security (MCS) level field. SELinux defines 1,024
categories, which can be combined together to give a level to each
container. Podman allocates two categories for each container and then
makes sure the process label level matches the filesystem label levels.
Then the SELinux kernel enforces the MCS levels matching, or the access
is denied.

[]{#10.htm_pgfId-1114962}[Note]{.fm-callout-head} MCS Separation is
actually about dominance. Each category must dominate the MCS level. A
level of `S0:C1,C2`{.fm-code-in-text1} can write to levels
`S0:C1,C2`{.fm-code-in-text1}, `S0:C1`{.fm-code-in-text1},
`S0:C2`{.fm-code-in-text1}, and `S0`{.fm-code-in-text1}. But the
`S0:C1,C2`{.fm-code-in-text1} is not allowed to write to
`S0:C1,C3`{.fm-code-in-text1}, since the original label does not include
the `C3`{.fm-code-in-text1}. In practice, Podman only uses two
categories or no categories. When you use the `:z`{.fm-code-in-text1}
option on a volume, Podman relabels the source directory with the level
`s0`{.fm-code-in-text1}---no categories. The `s0`{.fm-code-in-text1}
allows processes from any container to read and write filesystem objects
with this level, from an SELinux perspective.

[]{#10.htm_pgfId-1114963}Revisit table 10.4, but this time concentrate
on the MCS level field (table 10.7).[]{#10.htm_id_vyh8g5fd3gfv}

[]{#10.htm_pgfId-1120627}Table 10.7 Container process labels, with MCS
level highlighted

+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120637}Object      | []{#10.htm_pgfId-1120639}User                              | []{#10.htm_pgfId-1120641}Role                              | []{#10.htm_pgfId-1120643}Type                                  | []{#10.htm_pgfId-1120645}MCS level                           |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120647}Container   | []{#10.htm_pgfId-1120649}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120651}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120653}`container_t`{.fm-code-in-text1}      | []{#10.htm_pgfId-1120655}`s0:c1,c2`{.fm-code-in-text1}       |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120657}Container   | []{#10.htm_pgfId-1120659}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120661}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120663}`container_t`{.fm-code-in-text1}      | []{#10.htm_pgfId-1120665}`s0:c361,c871`{.fm-code-in-text1}   |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120667}Container   | []{#10.htm_pgfId-1120669}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120671}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120673}`container_file_t`{.fm-code-in-text1} | []{#10.htm_pgfId-1120675}`s0:c1,c2`{.fm-code-in-text1}       |
| file                                 |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120677}Container   | []{#10.htm_pgfId-1120679}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120681}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120683}`container_file_t`{.fm-code-in-text1} | []{#10.htm_pgfId-1120685}`s0:s361,c871`{.fm-code-in-text1}   |
| file                                 |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120687}/etc/shadow | []{#10.htm_pgfId-1120689}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120691}`object_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120693}`shadow_t`{.fm-code-in-text1}         | []{#10.htm_pgfId-1120695}`s0`{.fm-code-in-text1}             |
| label                                |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120697}Container   | []{#10.htm_pgfId-1120699}`system_u`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120701}`system_r`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120703}`spc_t`{.fm-code-in-text1}            | []{#10.htm_pgfId-1120705}`s0`{.fm-code-in-text1}             |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+
| []{#10.htm_pgfId-1120707}User        | []{#10.htm_pgfId-1120709}`unconfined_u`{.fm-code-in-text1} | []{#10.htm_pgfId-1120711}`unconfined_r`{.fm-code-in-text1} | []{#10.htm_pgfId-1120713}`unconfined_t`{.fm-code-in-text1}     | []{#10.htm_pgfId-1120715}`s0-s0:c0.c1023`{.fm-code-in-text1} |
| process                              |                                                            |                                                            |                                                                |                                                              |
+--------------------------------------+------------------------------------------------------------+------------------------------------------------------------+----------------------------------------------------------------+--------------------------------------------------------------+

[]{#10.htm_pgfId-1115049}Now look at how MCS leveling works with Podman.
If you run containers back to back and examine the SELinux label, you
notice that each container's MCS level is unique:

``` programlisting
$ podman run --rm ubi8 cat /proc/self/attr/current
System_u:system_r:container_t:s0:c648,c1009
$ podman run --rm ubi8 cat /proc/self/attr/current
system_u:system_r:container_t:s0:c393,c834
```

[]{#10.htm_pgfId-1115054}This MCS level prevents the processes from
attacking each other. Recall that in section 10.2.8, you created the
foo/bar file with a container private label. If you volume mount this
file into another container and then try to write to the file, you get
permission denied.

[]{#10.htm_pgfId-1115055}Listing 10.10 SELinux preventing different
containers from sharing a volume

``` programlisting
$ ls -Z ./foo                                            ❶
system_u:object_r:container_file_t:s0:c454,c510 bar
$ podman run -v ./foo:/foo ubi8 touch /foo/bar           ❷
touch: cannot touch '/foo/bar': Permission denied
$ podman run --security-opt label=level:s0:c454,c510 
➥ -v ./foo:/foo ubi8 touch /foo/bar                     ❸
```

[]{#10.htm_pgfId-1126309}[❶]{.fm-combinumeral} The file foo/bar has a
private MCS level, which Podman does not give to another container.

[]{#10.htm_pgfId-1126330}[❷]{.fm-combinumeral} Other containers are not
allowed to access the foo/bar file based on having a different MCS
level.

[]{#10.htm_pgfId-1126347}[❸]{.fm-combinumeral} If you force the
container MCS level to match the previous container's label, SELinux
allows the access.

[]{#10.htm_pgfId-1115065}Recall that the `Z`{.fm-code-in-text} volume
option tells Podman to label the container private to the container,
while the `z`{.fm-code-in-text} volume option tells Podman to label the
container shared for all containers. You can use this option if you have
a directory you want to allow multiple containers to use.

[]{#10.htm_pgfId-1115066}Listing 10.11 Volume option
`z`{.fm-code-in-text} causing Podman to relabel volumes with a shared
label

``` programlisting
$ podman run -v ./foo:/foo:z ubi8 touch /foo/bar       ❶
$ ls -Z foo/                                           ❷
system_u:object_r:container_file_t:s0 bar
$ podman run --rm -v ./foo:/foo ubi8 touch /foo/bar    ❸
```

[]{#10.htm_pgfId-1126108}[❶]{.fm-combinumeral} The -v ./foo:/foo:z tells
Podman to label the volume as shared.

[]{#10.htm_pgfId-1126129}[❷]{.fm-combinumeral} Podman uses the :s0 MCS
level because all containers are allowed to write to it.

[]{#10.htm_pgfId-1126146}[❸]{.fm-combinumeral} Other containers with
different MCS levels can successfully modify the content.

[]{#10.htm_pgfId-1115074}[Note]{.fm-callout-head} SELinux has 1,024
categories, and Podman chooses two categories for each container. Level
`s0:c1,c1`{.fm-code-in-text1} is not allowed. These categories must not
match, and the order is not important. Level
`s0:c1,c2`{.fm-code-in-text1} is the same as
`s0:c2,c1`{.fm-code-in-text1}. There are 1024 x 1024 ÷ 2 -- 1024 =
\~500,000 unique combinations available, meaning you can create half a
million unique containers on your system.

[]{#10.htm_pgfId-1115075}Sometimes it is necessary to disable SELinux
container separation for your container. For example, you might want to
share your home directory within a container. It is a bad idea to
relabel your home directory with the `Z`{.fm-code-in-text} or
`z`{.fm-code-in-text} options. Recall that when relabeling volumes, they
need to be private to the container. Relabeling the home directory can
cause other SELinux problems with other confined domains. You can run
the container with the `--privileged`{.fm-code-in-text} flag, but you
probably want the other security mechanisms to still be enforced. To
achieve this, you can use the `--security-opt`{.fm-code-in-text}
`label:disable`{.fm-code-in-text} flag[]{#10.htm_marker-1115076}:

``` programlisting
$ podman run --rm --security-opt label=disable ubi8 cat 
➥ /proc/self/attr/current
unconfined_u:system_r:spc_t:s0
$ podman run --rm -v $HOME/.ssh:/ssh --security-opt label=disable ubi8 ls /ssh
authorized_keys
authorized_keys2
config
fedora_rsa
fedora_rsa.pub
...
```

[]{#10.htm_pgfId-1115087}[Note]{.fm-callout-head} The udica project's
([https://github.com/containers/udica](https://github.com/containers/udica){.url})
goal is to generate SELinux policies for containers. Basically, Udica
examines a container you have created via `podman`{.fm-code-in-text1}
`inspect`{.fm-code-in-text1} and then writes a policy type that allows
access to the volumes you want to mount into the container.

[]{#10.htm_pgfId-1115088}SELinux is a very powerful tool for protecting
the host operating system from the containers. It is easy to deal with
for containers as long as you understand how to handle volumes.
Understanding how to protect the filesystem, it is time now to look at
protecting the Linux kernel from potentially
vulnerable[]{#10.htm_marker-1115089}
[]{#10.htm_marker-1115090}[]{#10.htm_marker-1115091}[]{#10.htm_marker-1115092}[]{#10.htm_marker-1115093}[]{#10.htm_marker-1115094}system
[]{#10.htm_marker-1115095}[]{#10.htm_marker-1115096}[]{#10.htm_marker-1115097}[]{#10.htm_marker-1115098}calls.

## []{#10.htm_pgfId-1115100}10.9. System call isolation seccomp {#10.htm_heading_id_25 .fm-head}

[]{#10.htm_pgfId-1115107}A
[]{#10.htm_marker-1115101}[]{#10.htm_marker-1115103}[]{#10.htm_marker-1115104}[]{#10.htm_marker-1115105}*system
call*, often called a *syscall*[]{#10.htm_marker-1115106}, is how a
computer program requests a service from the kernel of the operating
system on which it is executed. Common syscalls are
`open`{.fm-code-in-text}[]{#10.htm_marker-1115108},
`read`{.fm-code-in-text}[]{#10.htm_marker-1115109},
`write`{.fm-code-in-text}[]{#10.htm_marker-1115110},
`fork`{.fm-code-in-text}[]{#10.htm_marker-1115111}, and
`exec`{.fm-code-in-text}[]{#10.htm_marker-1115112}. In Linux, there are
over 700 system calls.

[]{#10.htm_pgfId-1115113}Recall from the beginning of this chapter that
the Linux kernel is the single point of failure hostile containers can
attack to escape confinement. If a bug exists in the Linux kernel that
can be attacked via a system call, the container processes might escape.
The Linux kernel feature seccomp[]{#10.htm_marker-1115114} allows
processes to voluntarily limit the number of system calls they and their
children can make. Podman, by default, eliminates hundreds of the system
calls using this feature. Suppose the Linux kernel has a flaw in one of
its system calls, which a container process can use to escape, but
Podman eliminated it from the table of system calls available to the
container. In that case, the container is blocked from using it.

[]{#10.htm_pgfId-1115116}Podman's seccomp
filters[]{#10.htm_marker-1115115} are stored as a JSON file in the
/usr/share/containers/seccomp.json file. Podman also modifies the list
of seccomp filters[]{#10.htm_marker-1115117} based on the capabilities
you allow to the container. When you add a capability, Podman adds the
system calls required for that capability. Capabilities and seccomp are
both enforced separately; Podman just tries to make it easier for the
user. If the user provides their own seccomp JSON file, it needs to be
similar to the default one for the capability modifications to work.

[]{#10.htm_pgfId-1115118}You can modify the seccomp filter by editing
this file. In the following example, you remove the
`mkdir`{.fm-code-in-text} syscall[]{#10.htm_marker-1115119} from
seccomp.json, and then run a container in which you try to make a
directory. The seccomp filter blocks the syscall, and your container
fails.

[]{#10.htm_pgfId-1115121}Listing 10.12 How seccomp filters can block
syscalls within a Podman container

``` programlisting
$ sed '/mkdir/d' /usr/share/containers
➥ /seccomp.json > /tmp/seccomp.json                    ❶
$ diff /usr/share/containers/seccomp.json/ 
➥ tmp/seccomp.json                                     ❷
249,250d248
<        "mkdir",
<        "mkdirat",
$ podman run --rm --security-opt seccomp=/
➥ tmp/seccomp.json ubi8 mkdir /foo                     ❸
mkdir: cannot create directory '/foo': Function not implemented
$ podman run --rm ubi8 mkdir /foo                       ❹
```

[]{#10.htm_pgfId-1125832}[❶]{.fm-combinumeral} Use the sed command to
delete all entries that make mkdir and create /tmp/seccomp.json.

[]{#10.htm_pgfId-1125868}[❷]{.fm-combinumeral} Use the diff command to
show the removed mkdir entries.

[]{#10.htm_pgfId-1125885}[❸]{.fm-combinumeral} Use the \--security-opt
seccomp=/tmp/seccomp.json flag to use an alternative seccomp filter; the
mkdir command fails because the mkdir system call is not available.

[]{#10.htm_pgfId-1125833}[❹]{.fm-combinumeral} Run the same command
again with a default filter to show the mkdir succeeds.

[]{#10.htm_pgfId-1115137}[Note]{.fm-callout-head} Not many people modify
the seccomp filters because it is difficult to figure out the number of
system calls required by a container. There are tools to generate this
list of system calls using the Berkeley Packet Filter
(BPF[]{#10.htm_marker-1115138}). The package at the following webpage is
a hook that monitors a container and automatically generates a
seccomp.json file to use later to lock down the container:
[https://github.com/containers/oci-seccomp-bpf-hook/](https://github.com/containers/oci-seccomp-bpf-hook/){.url}.

[]{#10.htm_pgfId-1115139}Sometimes the default container seccomp.json
file is too tight. Your container might not work because it needs a
system call that is not available. In this case, you can disable seccomp
filtering by using the `--security-opt`{.fm-code-in-text}
`seccomp=unconfined`{.fm-code-in-text} flag[]{#10.htm_marker-1115140}.

[]{#10.htm_pgfId-1115141}As you see, system call filtering is powerful
and can really limit the container processes' access to the host kernel.
The next level is to use KVM
[]{#10.htm_marker-1115142}[]{#10.htm_marker-1115144}[]{#10.htm_marker-1115145}[]{#10.htm_marker-1115146}isolation.

## []{#10.htm_pgfId-1115148}10.10 Virtual machine isolation {#10.htm_heading_id_26 .fm-head}

[]{#10.htm_pgfId-1115151}At
[]{#10.htm_marker-1115149}[]{#10.htm_marker-1115150}the beginning of
this chapter, I compared process isolation based on where the three pigs
chose to live. They could live in separate houses, a duplex, or a
condominium. Each one was getting slightly less secure. Container
security, by default, is living in a condo. But you can use VM
isolation, which basically puts your container into a VM, to get better
isolation.

[]{#10.htm_pgfId-1115152}In appendix B, I cover how different OCI
runtimes, Kata and libkrun, take advantage of Kernel-based Virtual
Machine (KVM[]{#10.htm_marker-1115153}) to run their containers within a
lightweight virtual machine. These virtual machines run their own kernel
and initialization tools to launch the container. By doing this, almost
all of the host kernels' system calls are eliminated, making it much
more difficult to escape confinement.

[]{#10.htm_pgfId-1115154}The problem with this isolation is that it
comes at a cost. As with a duplex, you end up sharing fewer services
between your containers. Memory management, CPU, and other resources are
harder to share. Sharing volumes into a container is also going to
perform worse.

[]{#10.htm_pgfId-1115155}Now you've finished examining Podman security
features used for container isolation. Next let's look at other security
[]{#10.htm_marker-1115156}[]{#10.htm_marker-1115157}features.

## []{#10.htm_pgfId-1115159}Summary {#10.htm_heading_id_27 .fm-head}

- []{#10.htm_pgfId-1115160 .calibre17}Container security is all about
  protecting the Linux kernel and host filesystem from hostile container
  processes.

- []{#10.htm_pgfId-1115161 .calibre17}Defense in depth means your
  container tooling takes advantage of as many security mechanisms as
  possible. If one security mechanism fails, others might still protect
  your []{#10.htm_marker-1115162 .calibre17}system.

[]{#11.htm}

# []{#11.htm_pgfId-1121651}[]{#11.htm_pgfId-1121652}11 Additional security considerations {#11.htm_heading_id_2 .tochead}

[]{#11.htm_pgfId-1121654}This chapter []{#11.htm_marker-1124735}covers

- []{#11.htm_pgfId-1121655 .calibre17}Securing running applications on
  different standalone servers, inside different VMs and containers
- []{#11.htm_pgfId-1121656 .calibre17}Running a container via a service
  versus as a child of the container engine via fork and exec
- []{#11.htm_pgfId-1121657 .calibre17}Linux security features used to
  keep containers isolated from each other
- []{#11.htm_pgfId-1121658 .calibre17}Setting up container image trust
- []{#11.htm_pgfId-1121659 .calibre17}Signing images and trusting them

[]{#11.htm_pgfId-1121660}In this chapter, I review and demonstrate some
additional security considerations when using Podman to run containers.
Some of the content was covered in other chapters, but I think it is
useful to concentrate on these features from a security perspective.

[]{#11.htm_pgfId-1121661}One of the most frequent problems I see with
people running containers is that when the container process is denied
some access, the user's first reaction is to run the container in
`--privileged`{.fm-code-in-text} mode, which turns off all security
separation for your container. Understanding how to deal with the
security features discussed in this chapter helps you avoid this.

## []{#11.htm_pgfId-1121663}11.1 Daemon versus the fork/exec model {#11.htm_heading_id_3 .fm-head}

[]{#11.htm_pgfId-1121667}Throughout
[]{#11.htm_marker-1121664}[]{#11.htm_marker-1121665}[]{#11.htm_marker-1121666}the
previous chapters, you have learned quite a bit about the problems of a
daemon like Docker versus the fork/exec model employed by Podman.

### []{#11.htm_pgfId-1121669}11.1.1 Access to the docker.sock {#11.htm_heading_id_4 .fm-head1}

[]{#11.htm_pgfId-1121674}Recall
[]{#11.htm_marker-1121670}[]{#11.htm_marker-1121671}[]{#11.htm_marker-1121672}[]{#11.htm_marker-1121673}that
Docker, by default, runs a daemon owned by the root user. This means any
user who has access to the daemon can launch processes with full root
access on the system. Docker recommends some users put their accounts
into the docker group in the /etc/group. On some distributions, this
allows you to access the /run/docker.sock without being root:

``` programlisting
# ls -l /run/docker.sock
srw-rw----. 1 root docker 0 Jun 13 14:54 /run/docker.sock
```

[]{#11.htm_pgfId-1121677}You can run a Docker container similarly to how
you have been running a Podman container:

``` programlisting
$ docker run registry.access.redhat.com/ubi8-micro echo hi
Unable to find image 'registry.access.redhat.com/ubi8-micro:latest' locally|
latest: Pulling from ubi8-micro
4f4fb700ef54: Pull complete
b6d5e0581b2f: Pull complete
Digest: sha256:a519ab06c0287085c352af0d2b84f2a2b257d2afb2e554b8d38a076cd6205b48
Status: Downloaded newer image for registry.access.redhat.com/
ubi8-micro:latest
hi
```

[]{#11.htm_pgfId-1121688}This excites a lot of users, until they
understand they can also launch a root shell on their system with a
simple Docker command:

``` programlisting
$ docker run -ti --name hack -v /:/host --privileged 
➥ registry.access.redhat.com/ubi8-micro chroot /host
# cat /etc/shadow
...
```

[]{#11.htm_pgfId-1121693}At this point, you have a fully privileged root
shell on the host system, in which you can hack the machine all you
want. Not only that, but Docker defaults all logging to being file
based. When you are done hacking the system, you can remove the log
files and all records of your activity:

``` programlisting
$ docker rm hack
hack
```

[]{#11.htm_pgfId-1121697}Using rootless Podman, you cannot do this,
since when you run the container, the container processes are run as
your user UID and only have access to the same files as any process in
your account. One way administrators figure out if they have been hacked
is by examining the logging system, including the audit
[]{#11.htm_marker-1121698}[]{#11.htm_marker-1121699}[]{#11.htm_marker-1121700}[]{#11.htm_marker-1121701}logs.

### []{#11.htm_pgfId-1121703}11.1.2 Auditing and logging {#11.htm_heading_id_5 .fm-head1}

[]{#11.htm_pgfId-1121710}One
[]{#11.htm_marker-1121704}[]{#11.htm_marker-1121705}[]{#11.htm_marker-1121706}[]{#11.htm_marker-1121707}[]{#11.htm_marker-1121708}key
feature of a Linux system is tracking what processes do when they are
running on a system. When you log in to a Linux system, your UID is
recorded by the kernel into the process data in /proc/self/loginuid. You
can see this data by executing the following command:

``` programlisting
$ cat /proc/self/loginuid
3267
```

[]{#11.htm_pgfId-1121713}All processes created by this first process
after login maintain this field. Even if you use a
`setuid`{.fm-code-in-text} program, like `su`{.fm-code-in-text} or
`sudo`{.fm-code-in-text}, your `loginuid`{.fm-code-in-text} stays the
same:

``` programlisting
$ sudo cat /proc/self/loginuid
3267
```

[]{#11.htm_pgfId-1121716}Even when you launch a container, the
`loginuid`{.fm-code-in-text} stays the same. In this next example, you
run a simple container in daemon mode that sleeps, then use
`podman`{.fm-code-in-text} `inspect`{.fm-code-in-text} to get the PID of
the sleep processes, and finally examine the
`loginuid`{.fm-code-in-text} of the containerized process:

``` programlisting
$ podman run -d ubi8-micro sleep 20
1c55b9cfa0cd20c36da4b606415e190a6c20cc868d3486981c7713d41ee9ea6a
$ podman inspect -l --format '{{ .State.Pid }}'
119394
$ cat /proc/119394/loginuid
3267
```

[]{#11.htm_pgfId-1121723}Notice the containerized process is still
running with your `loginuid`{.fm-code-in-text}. This shows that the
kernel can track which user launched a container process on the system
via this field, as long as the container engine uses the fork/exec
model. If you run this same test with Docker, you get very different
results:

``` programlisting
$ docker run -d registry.access.redhat.com/ubi8-micro sleep 20
df2302cf8c6385df2b86ccd3429166e0d8dd0c9f0d0139e98e6354809a04080e
$ docker inspect df2302cf8c6 --format '{{ .State.Pid }}'
120022
$ cat /proc/120022/loginuid
4294967295
```

[]{#11.htm_pgfId-1121730}Instead of showing your
`loginuid`{.fm-code-in-text}, you see `4294967295`{.fm-code-in-text},
which is 2^32^ -- 1. This is how the Linux kernel represents
`-1`{.fm-code-in-text}, the default `loginuid`{.fm-code-in-text} for all
processes started by the system, not by users who logged into the
system. The reason for this is that Docker uses a client-server model,
and the container process is a child of the Docker daemon as opposed to
the Docker client. Since the Docker daemon was launched by systemd when
the system booted up, all of its children processes have the
`-1`{.fm-code-in-text} `loginuid`{.fm-code-in-text}.

[]{#11.htm_pgfId-1121731}The kernel's audit subsystem records the
`loginuid`{.fm-code-in-text} of every process on the system when it
completes an auditable event. For example, when a user logs in and out
of a system, these events are logged. Modifying /etc/passwd and
/etc/shadow are also loggable events.

[]{#11.htm_pgfId-1121733}Following is the `USER_START`{.fm-code-in-text}
audit log entry[]{#11.htm_marker-1121732} for when I logged into my
system today. My UID `3267`{.fm-code-in-text} is recorded along with my
username:

``` programlisting
# ausearch -m USER_START
type=USER_START msg=audit(1651064687.963:315): pid=2579 uid=0 auid=3267 
➥ ses=3 subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 msg='op=PAM:session_open 
➥ grantors=pam_selinux,pam_loginuid,pam_selinux,pam_keyinit,pam_namespace,
➥ pam_keyinit,pam_limits,pam_systemd,pam_unix,pam_gnome_keyring,pam_umask acct=
➥ "dwalsh" exe="/usr/libexec/gdm-session-worker" hostname=fedora addr=? 
➥ terminal=/dev/tty2 res=success'UID="root" AUID="dwalsh"
```

[]{#11.htm_pgfId-1121741}If you launched the container by using a Podman
command, then the audit subsystem records your UID in the audit logs. If
the container was launched via Docker, it records `-1`{.fm-code-in-text}
as the `loginuid`{.fm-code-in-text}. Imagine your system was hacked via
a container. You need to go back and examine which user launched the
container that hacked your system via the audit.log.

[]{#11.htm_pgfId-1121742}Let's show an example of this. First, become
root, and set up a watch on the /etc/passwd file using
`auditctl`{.fm-code-in-text}:

``` programlisting
# auditctl -w /etc/passwd -p wa -k passwd
```

[]{#11.htm_pgfId-1121745}Now run a `--privileged`{.fm-code-in-text}
container[]{#11.htm_marker-1121744} using Docker, which touches the
host's /etc/ passwd file:

``` programlisting
# docker run --privileged -v /:/host registry.access.redhat.com/ubi8-
➥ micro:latest touch /host/etc/passwd
```

[]{#11.htm_pgfId-1121748}This simulated what would happen if a Docker
container escaped confinement and was able to modify the host's
/etc/passwd file. Now examine the audit.log, where there should be a
record of the /etc/passwd modification. Notice that the audit log shows
`auid=unset`{.fm-code-in-text}. This is how the audit log represents the
`loginuid`{.fm-code-in-text} of the user that modified the /etc/passwd
file. As you can see, because no user launched the Docker daemon
directly, the audit log has no record of the user who launched the
container:

``` programlisting
# ausearch -k passwd -i
...
type=SYSCALL msg=audit(05/03/2022 08:24:52.885:464) : arch=x86_64 
➥ syscall=openat success=yes exit=3 a0=AT_FDCWD a1=0x7ffef7a9ef75 
➥ a2=O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK a3=0x1b6 items=2 ppid=6723 
➥ pid=6743 auid=unset uid=root gid=root euid=root suid=root fsuid=root 
➥ egid=root sgid=root fsgid=root tty=(none) ses=unset comm=touch 
➥ exe=/usr/bin/coreutils 
```

[]{#11.htm_pgfId-1121757}Now run the same command with Podman:

``` programlisting
# podman run --privileged -v /:/host registry.access.redhat.com/
➥ ubi8-micro:latest touch /host/etc/passwd
```

[]{#11.htm_pgfId-1121760}Examine the audit.log for the Podman container
that modifies the /etc/passwd file, and you see that
`auid=dwalsh`{.fm-code-in-text}. Because Podman follows the fork/exec
model and was launched by a user who logged into the system and had a
record in the `loginuid`{.fm-code-in-text}, the audit.log can record
which user launched a container that hacked the system:

``` programlisting
# ausearch -k passwd -i
...
type=SYSCALL msg=audit(05/03/2022 08:25:42.466:480) : arch=x86_64 
➥ syscall=openat success=no exit=EACCES(Permission denied) a0=AT_FDCWD 
➥ a1=0x7fff3d5aef59 a2=O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK a3=0x1b6 
➥ items=2 ppid=6978 pid=6986 auid=dwalsh uid=root gid=root euid=root 
➥ suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=1 
➥ comm=touch exe=/usr/bin/coreutils 
➥ subj=system_u:system_r:container_t:s0:c484,c845 key=passwd
```

[]{#11.htm_pgfId-1121770}[Note]{.fm-callout-head} On current Fedora, the
audit subsystem is disabled. You can enable it by removing
`/etc/audit/rules.d/audit.rules`{.fm-code-in-text1} and regenerating the
audit rules with the `augenrules`{.fm-code-in-text1}
`--load`{.fm-code-in-text1} command[]{#11.htm_marker-1121771}.

[]{#11.htm_pgfId-1121772}This is one reason, back in 2014, I said access
to the docker.sock via non-root processes is more dangerous than giving
out the root process or sudo access, since both of those record the
`loginuid`{.fm-code-in-text}, meaning you can track what the user is
doing on your system. When you give access to the root running
docker.sock, you have no tracking data. Let's look into how you can
protect the kernel and the filesystem from processes running within a
container in the
[]{#11.htm_marker-1121773}[]{#11.htm_marker-1121774}[]{#11.htm_marker-1121775}[]{#11.htm_marker-1121776}[]{#11.htm_marker-1121777}next
[]{#11.htm_marker-1121778}[]{#11.htm_marker-1121779}[]{#11.htm_marker-1121780}section.

## []{#11.htm_pgfId-1121782}11.2 Podman secret handling {#11.htm_heading_id_6 .fm-head}

[]{#11.htm_pgfId-1121785}Often,
[]{#11.htm_marker-1121783}[]{#11.htm_marker-1121784}when running a
container, you need to provide a secret to the service running within
the container. An example of this is a database tool that requires an
administrator and password to control access. Another example is a
service that requires a password to reach another service.

[]{#11.htm_pgfId-1121786}Developers of these applications do not want to
hardcode the secret information into the image. The user of the
container application must provide the secret. You can just provide the
secret to the application via environment variables, but this means if
you commit the image, the secret gets committed to the image.

[]{#11.htm_pgfId-1121788}Podman provides a secret mechanism,
`podman`{.fm-code-in-text}
`secret`{.fm-code-in-text}[]{#11.htm_marker-1121787}, which allows you
to either add files or environment variables to a container without
these secrets getting saved when you commit the container to an image.
First, let's look at creating a secret.

[]{#11.htm_pgfId-1121789}Listing 11.1 Using secrets within a Podman
container

``` programlisting
$ echo "This is my secret" > /tmp/secret               ❶
$ podman secret create my_secret /tmp/secret           ❷
b5f27b90e9b3486fb5a78d1eb
$ podman run --rm --secret my_secret ubi8 cat 
/run/secrets/my_secret                                 ❸
This is my secret
```

[]{#11.htm_pgfId-1129575}[❶]{.fm-combinumeral} Add your secret data to a
file.

[]{#11.htm_pgfId-1129596}[❷]{.fm-combinumeral} Use podman secret create
to name a secret based on the file.

[]{#11.htm_pgfId-1129613}[❸]{.fm-combinumeral} Use the \--secret option
to leak the secret into the container.

[]{#11.htm_pgfId-1121799}You can also leak the secret into the container
as an environment variable by adding the `--secret`{.fm-code-in-text}
`my_secret,type=env`{.fm-code-in-text} flag[]{#11.htm_marker-1121800}:

``` programlisting
$ podman run --secret my_secret,type=env --name secret_ctr ubi8 bash 
➥ -c 'echo $my_secret'
This is my secret
```

[]{#11.htm_pgfId-1121804}If you were to commit this container to an
image, the secret would not be saved inside the image.

[]{#11.htm_pgfId-1121805}Listing 11.2 The secret is not saved when the
container is committed to the image.

``` programlisting
$ podman commit secret_ctr secret_img                       ❶
Getting image source signatures
Copying blob a9820c2af00a skipped: already exists 
Copying blob 3d5ecee9360e skipped: already exists 
Copying blob dc409efbefc4 done 
Copying config 501812299f done 
Writing manifest to image destination
Storing signatures
501812299f0c0cfbb032d144e6d2c2a41c5eadf229e7b76f6264ab74d9f6c069
$ podman image inspect secret_img --format 
➥ '{{ .Config.Env }}'                                      ❷
[TERM=xterm container=oci PATH=/usr/local/sbin:/usr/local/
➥ bin:/usr/sbin:/usr/bin:/sbin:/bin]
```

[]{#11.htm_pgfId-1129413}[❶]{.fm-combinumeral} Commit the secret_ctr
into the secret_img image.

[]{#11.htm_pgfId-1129434}[❷]{.fm-combinumeral} Inspect the image to view
the committed environment variables, and notice the my_secret
environment is not committed.

[]{#11.htm_pgfId-1121823}Table 11.1 lists all of the
`podman`{.fm-code-in-text} `secret`{.fm-code-in-text}
[]{#11.htm_marker-1121821}[]{#11.htm_marker-1121822}commands.

[]{#11.htm_pgfId-1125698}Table 11.1 `podman`{.fm-code-in-text}
`secret`{.fm-code-in-text} commands

+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#11.htm_pgfId-1125704}Command                                                | []{#11.htm_pgfId-1125706}Man page                                      | []{#11.htm_pgfId-1125708}Description |
+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#11.htm_pgfId-1125710}`create`{.fm-code-in-text1}[]{#11.htm_marker-1125733}  | []{#11.htm_pgfId-1125712}`podman-secret-create(1)`{.fm-code-in-text1}  | []{#11.htm_pgfId-1125714}Create a    |
|                                                                                 |                                                                        | new secret.                          |
+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#11.htm_pgfId-1125716}`inspect`{.fm-code-in-text1}[]{#11.htm_marker-1125734} | []{#11.htm_pgfId-1125718}`podman-secret-inspect(1)`{.fm-code-in-text1} | []{#11.htm_pgfId-1125720}Display     |
|                                                                                 |                                                                        | detailed information on one or more  |
|                                                                                 |                                                                        | secrets.                             |
+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#11.htm_pgfId-1125722}`ls`{.fm-code-in-text1}[]{#11.htm_marker-1125735}      | []{#11.htm_pgfId-1125724}`podman-secret-ls(1)`{.fm-code-in-text1}      | []{#11.htm_pgfId-1125726}List all    |
|                                                                                 |                                                                        | available secrets.                   |
+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+
| []{#11.htm_pgfId-1125728}`rm`{.fm-code-in-text1}[]{#11.htm_marker-1125736}      | []{#11.htm_pgfId-1125730}`podman-secret-rm(1)`{.fm-code-in-text1}      | []{#11.htm_pgfId-1125732}Remove one  |
|                                                                                 |                                                                        | or more secrets.                     |
+---------------------------------------------------------------------------------+------------------------------------------------------------------------+--------------------------------------+

## []{#11.htm_pgfId-1121863}11.3 Podman image trust {#11.htm_heading_id_7 .fm-head}

[]{#11.htm_pgfId-1121866}In
[]{#11.htm_marker-1121864}[]{#11.htm_marker-1121865}many situations,
users of container images want to specify which container image
registries and images they trust. The `podman`{.fm-code-in-text}
`image`{.fm-code-in-text} `trust`{.fm-code-in-text}
command[]{#11.htm_marker-1121867} allows you to specify which registries
you trust. It also allows you to specify registries to block.

[]{#11.htm_pgfId-1121868}The location of the trusted registry is
determined by the transport and the registry host of the image. Using
this container image---docker://quay.io/podman/stable---as an example,
Docker is the transport, and quay.io is the registry host.

[]{#11.htm_pgfId-1121869}[Note]{.fm-callout-head} Podman image trust is
not available in remote mode, for example, on a Mac or Windows box. You
have to execute the commands documented here on a Linux box. If you are
using the Podman machine, use the `podman`{.fm-code-in-text1}
`machine`{.fm-code-in-text1} `ssh`{.fm-code-in-text1}
command[]{#11.htm_marker-1121870} to enter the VM. See appendixes E and
F for more information.

[]{#11.htm_pgfId-1121871}The trust policy is defined in
/etc/containers/policy.json, which describes a registry scope (registry
and/or repository) for the trust. The trust policy can use public keys
for signed images. The `podman`{.fm-code-in-text}
`image`{.fm-code-in-text} `trust`{.fm-code-in-text}
command[]{#11.htm_marker-1121872} must be run as root.

[]{#11.htm_pgfId-1121873}The scope of the trust is evaluated from the
most specific to the least specific. In other words, a policy may be
defined for an entire registry. Or it can be defined for a particular
repository in that registry or defined down to a specific signed image
inside the registry. In the following example, you reject pulls from
docker.io and then later specify only docker.io/library images are
allowed for pulling.

[]{#11.htm_pgfId-1121874}The following list includes valid scope values
that can be used in policy.json from most specific to the least
specific:

``` programlisting
docker.io/library/busybox:notlatest
docker.io/library/busybox
docker.io/library
docker.io
```

[]{#11.htm_pgfId-1121879}If no configuration is found for any of these
scopes, the default value (specified by using
`default`{.fm-code-in-text} instead of
`REGISTRY[/REPOSITORY]`{.fm-code-in-text}) is used, as shown in the
following listing. Table 11.2 describes the valid trust values used for
registries.

[]{#11.htm_pgfId-1121880}Listing 11.3 Telling Podman to not pull images
from a specific container registry

``` programlisting
$ sudo podman image trust set -t reject docker.io                     ❶
$ podman pull alpine                                                  ❷
Trying to pull docker.io/library/alpine:latest...
Error: Source image rejected: Running image docker://alpine:latest 
➥ is rejected by policy.
$ sudo podman image trust set -t accept 
➥ docker.io/library                                                  ❸
$ podman pull alpine                                                  ❹
Trying to pull docker.io/library/alpine:latest...
Getting image source signatures
Copying blob 59bf1c3509f3 skipped: already exists 
Copying config c059bfaa84 done 
Writing manifest to image destination
Storing signatures
C059bfaa849c4d8e4aecaeb3a10c2d9b3d85f5165c66ad3a4d937758128c4d18
$ podman pull bitnami/nginx                                           ❺
Resolving "bitnami/nginx" using unqualified-search registries 
➥ (/etc/containers/registries.conf.d/999-podman-machine.conf)
Trying to pull docker.io/bitnami/nginx:latest...
Error: Source image rejected: Running image docker://bitnami/nginx:latest 
➥ is rejected by policy.
```

[]{#11.htm_pgfId-1128975}[❶]{.fm-combinumeral} Use podman image trust to
reject all images from the docker.io container registry.

[]{#11.htm_pgfId-1129011}[❷]{.fm-combinumeral} Attempt to pull the
alpine image from the container registry, and see that Podman rejects
the image.

[]{#11.htm_pgfId-1129028}[❸]{.fm-combinumeral} Use Podman image trust to
set a more specific registry/repository for docker.io/library.

[]{#11.htm_pgfId-1129045}[❹]{.fm-combinumeral} Podman can pull the
docker.io/library/alpine image.

[]{#11.htm_pgfId-1128976}[❺]{.fm-combinumeral} Images pulled from the
rest of docker.io are rejected.

[]{#11.htm_pgfId-1125964}Table 11.2 The trust type tells container
engines like Podman which registries to trust.

+------------------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1125968}Types                       | []{#11.htm_pgfId-1125970}Description                |
+------------------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1125972}`accept`{.fm-code-in-text1} | []{#11.htm_pgfId-1125974}Images from the specified  |
|                                                      | registry are allowed to be pulled.                  |
+------------------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1125976}`reject`{.fm-code-in-text1} | []{#11.htm_pgfId-1125978}Images from the specified  |
|                                                      | registries are not allowed to be pulled.            |
+------------------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1125980}`signBy`{.fm-code-in-text1} | []{#11.htm_pgfId-1125982}Images from the specified  |
|                                                      | registries must be signed by the specified name.    |
+------------------------------------------------------+-----------------------------------------------------+

[]{#11.htm_pgfId-1121928}If you examine the policy.json file, you see
the entries added by the `podman`{.fm-code-in-text}
`image`{.fm-code-in-text} `trust`{.fm-code-in-text} command:

``` programlisting
$ cat /etc/containers/policy.json
{
    "default": [
        {
            "type": "insecureAcceptAnything"
        }
    ],
    "transports": {
        "docker": {
            "docker.io": [
                {
                    "type": "reject"
                }
            ],
            "docker.io/library": [
                {
                    "type": "insecureAcceptAnything"
                }
            ]
 
...   
```

[]{#11.htm_pgfId-1121951}You can use the `podman`{.fm-code-in-text}
`image`{.fm-code-in-text} `trust`{.fm-code-in-text}
`show`{.fm-code-in-text} command[]{#11.htm_marker-1121950} to show the
current settings in an easier-to-view form:

``` programlisting
$ podman image trust show
all          default                     accept                         
repository   docker.io                   reject                         
repository   docker.io/library           accept                      
   
repository   registry.access.redhat.com  signed    security@redhat.com 
https://access.redhat.com/webassets/docker/content/sigstore
repository   registry.redhat.io          signed    
➥ security@redhat.com  https://registry.redhat.io/containers/sigstore
docker-daemon                            accept   
```

[]{#11.htm_pgfId-1121964}Through the
`accep`{.fm-code-in-text}t[]{#11.htm_marker-1121962} and
`reject`{.fm-code-in-text} flags,[]{#11.htm_marker-1121963} you can set
up which registries you trust and which you reject. If you want to lock
down where images on your production system come from, you can change
the `default`{.fm-code-in-text} policy[]{#11.htm_marker-1121965} for
your system to `reject`{.fm-code-in-text} images from any registry. All
images you want to allow need to come from a specific registry:

``` programlisting
$ sudo podman image trust set --type=reject default
$ podman image trust show
all          default                     reject                      
   
repository   docker.io                   reject                      
   
repository   docker.io/library           accept                      
   
repository   registry.access.redhat.com  signed    security@redhat.com 
https://access.redhat.com/webassets/docker/content/sigstore
repository   registry.redhat.io          signed    
➥ security@redhat.com  https://registry.redhat.io/containers/sigstore
docker-daemon                            accept   
```

[]{#11.htm_pgfId-1121979}With these settings on your system, Podman
accepts images from docker.io/library and signed images from
registry.redhat.io. All images from other registries are rejected.
Podman allows pulling of images directly from the
`docker-daemon`{.fm-code-in-text} as well.

[]{#11.htm_pgfId-1121980}Don't forget to restore the default
policy.json:

``` programlisting
$ sudo cp /tmp/policy.json /etc/containers/policy.json 
```

[]{#11.htm_pgfId-1121982}Podman supports using signed images from
container registries. Red Hat signs and ships its images. Let's look at
how you, too, can sign images.

### []{#11.htm_pgfId-1121984}11.3.1 Podman image signing {#11.htm_heading_id_8 .fm-head1}

[]{#11.htm_pgfId-1121986}One []{#11.htm_marker-1121985}way of signing
images is utilizing a GNU Privacy Guard
([https://gnupg.org](https://gnupg.org){.url}) key. Podman can sign
images before pushing them to remote registries, referred to as *simple
signing*. You can configure Podman and other container engines to
require images to be signed with a particular signature. All unsigned
images are rejected.

[]{#11.htm_pgfId-1121987}First, you need to create a GPG key pair or
select a premade pair. You can generate new GPG keys by running
`gpg`{.fm-code-in-text} `--full-gen-key`{.fm-code-in-text} and following
the interactive dialog. Refer to the following web page for a
description of creating keys:
[http://mng.bz/JV9V](http://mng.bz/JV9V){.url}.

[]{#11.htm_pgfId-1121988}Following is an example of creating a simple
key with default params. Make sure to use your own email address:

``` programlisting
$ gpg --batch --passphrase '' --quick-gen-key dwalsh@redhat.com default 
➥ default
```

[]{#11.htm_pgfId-1121991}Most container registries do not understand
image signing; they just provide the remote storage for the container
images. If you want to sign an image, you need to distribute the
signatures yourself, usually using a web server. You can configure
Podman and other container engines to retrieve signatures from this web
service.

[]{#11.htm_pgfId-1121992}In the following examples, you will create a
web service running on your local machine to demonstrate image signing.
Podman is able to push and sign the image in a single command. Podman
reads signature locations in the registries configuration file
/etc/containers/registries.d/default.yaml.

[]{#11.htm_pgfId-1121994}Examine the default.yaml file to find the
`sigstore-staging`{.fm-code-in-text} flag[]{#11.htm_marker-1121993} and
see the default location where Podman stores signatures:

``` programlisting
sigstore-staging: file:///var/lib/containers/sigstore
```

[]{#11.htm_pgfId-1121997}The `sigstore-staging`{.fm-code-in-text}
flag[]{#11.htm_marker-1121996} tells Podman to store signatures in the
/var/lib/containers/sigstore directory. When you want other users to use
these signatures to verify your images, you need to put these images
onto a web server. Now you are ready to test out simple signing, first
signing the ubi8 image and then setting up Podman to pull the image
using the signature to verify it.

[]{#11.htm_pgfId-1121999}Signing and pushing the image

[]{#11.htm_pgfId-1122003}Before
[]{#11.htm_marker-1122000}[]{#11.htm_marker-1122001}[]{#11.htm_marker-1122002}starting
this section, you should back up a couple of security files, so you can
restore them later:

``` programlisting
$ sudo cp /etc/containers/registries.d/default.yaml 
➥ /etc/containers/policy.json /tmp 
```

[]{#11.htm_pgfId-1122006}Let's pull an image from a registry and add a
signature, then push it back to the registry. Make sure to use your own
registry account, image, and previously created GPG key:

``` programlisting
$ sudo podman pull quay.io/rhatdan/myimage
Trying to pull quay.io/rhatdan/myimage:latest...
...
2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae
$ podman login quay.io/rhatdan
Username: rhatdan
Password:
Login Succeeded!
$ sudo -E GNUPGHOME=$HOME/.gnupg \
    podman push --tls-verify=false --sign-by dwalsh@redhat.com 
➥ quay.io/rhatdan/myimage
...
Storing signatures
```

[]{#11.htm_pgfId-1122020}Look in the sigstore-staging directory
/var/lib/containers/sigstore for the repository name rhatdan. You will
see that there is a new signature available, created by the
`podman`{.fm-code-in-text} `push`{.fm-code-in-text}
command[]{#11.htm_marker-1122021}. Make sure to use your own registry
account name:

``` programlisting
$ sudo ls /var/lib/containers/sigstore/rhatdan/
'myimage@sha256=0460a9d13a806e124639b23e9d6ffa1e5773f7bef91469bee6ac88
➥ a4be213427'
```

[]{#11.htm_pgfId-1122025}Now that you have signed the image, you need to
set up a web server to provide the signature and configure Podman and
other container engines to use the signatures and signed
[]{#11.htm_marker-1122026}[]{#11.htm_marker-1122027}[]{#11.htm_marker-1122028}images.

[]{#11.htm_pgfId-1122030}Configuring Podman to pull signed images

[]{#11.htm_pgfId-1122033}When
[]{#11.htm_marker-1122031}[]{#11.htm_marker-1122032}configuring Podman
to use signatures to verify images, you need to configure the system to
retrieve the signatures. Usually, you share signatures on a web service.
You can do this by configuring the `sigstore`{.fm-code-in-text}
flag[]{#11.htm_marker-1122034} in the
/etc/containers/registries.d/default.yaml file to identify the website
that stores signatures. Podman downloads these signatures from this
website.

[]{#11.htm_pgfId-1122035}For this example, you will create a web service
running on localhost at port `8000`{.fm-code-in-text}. Add the
`sigstore:`{.fm-code-in-text} `http://localhost:8000`{.fm-code-in-text}
web server to the default.yaml file. This will tell Podman to retrieve
signatures from this web server when pulling images. Podman looks for a
signature based on the name of the image along with its digest:

``` programlisting
$ echo "  sigstore: http://localhost:8000" | sudo tee --append 
➥ /etc/containers/registries.d/default.yaml
```

[]{#11.htm_pgfId-1122038}For this example, start a new server using
`python3`{.fm-code-in-text} inside the local staging signature store
/var/lib/containers/sigstore:

``` programlisting
$ cd /var/lib/containers/sigstore && python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

[]{#11.htm_pgfId-1122041}In another window, remove
quay.io/rhatdan/myimage from local storage, since you want to pull with
the signatures:

``` programlisting
$ podman rmi quay.io/rhatdan/myimage
Untagged: quay.io/rhatdan/myimage:latest
Deleted: 2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae
```

[]{#11.htm_pgfId-1122045}You need to set up image trust for the
quay.io/rhatdan repository and assign the publickey.gpg public key to
use when verifying images signed by dwalsh@redhat.com:

``` programlisting
$ sudo podman image trust set -f /tmp/publickey.gpg quay.io/rhatdan
```

[]{#11.htm_pgfId-1122047}The previous Podman command adds the following
stanza to the /etc/containers/ policy.json file:

``` programlisting
...
"transports": {
    "docker": {
        "quay.io/rhatdan": [
            {
                  "type": "signedBy",
                  "keyType": "GPGKeys",
                  "keyPath": "/tmp/publickey.gpg"
            }
        ],
...
```

[]{#11.htm_pgfId-1122059}You have not created the
`keyPath`{.fm-code-in-text} file /tmp/publickey.gpg yet. Create it using
the following GPG command:

``` programlisting
$ gpg --output /tmp/publickey.gpg --armor --export dwalsh@redhat.com
```

[]{#11.htm_pgfId-1122061}Now you can pull the signed image:

``` programlisting
$ podman pull quay.io/rhatdan/myimage
Trying to pull quay.io/rhatdan/myimage:latest...
...
Writing manifest to image destination
Storing signatures
2c7e43d880382561ebae3fa06c7a1442d0da2912786d09ea9baaef87f73c29ae
```

[]{#11.htm_pgfId-1122068}It worked! Still, you are not really sure if it
used signatures. Prove it to yourself by attempting to pull another
image from the repository, which you don't have signatures for, and it
will fail:

``` programlisting
$ podman pull quay.io/rhatdan/podman
Trying to pull quay.io/rhatdan/podman:latest...
Error: Source image rejected: A signature was required, 
➥ but no signature exists
```

[]{#11.htm_pgfId-1122073}Make sure to restore all settings back to
default:

``` programlisting
$ sudo cp /tmp/default.yaml /etc/containers/registries.d/default.yaml
$ sudo cp /tmp/policy.json /etc/containers/policy.json
```

[]{#11.htm_pgfId-1122076}Also, stop the localhost web server started in
another terminal. Table 11.3 describes the infrastructure you need to
set up to allow simple signing to be used within your
environment.[]{#11.htm_id_rersmg5h3akf}

[]{#11.htm_pgfId-1126058}Table 11.3 Infrastructure required for simple
signing

+---------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126062}Requirements | []{#11.htm_pgfId-1126064}Description                |
+---------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126066}GPG private  | []{#11.htm_pgfId-1126068}You need a GPG key pair,   |
| key                                   | where the private key is used on the service that   |
|                                       | signs the images.                                   |
+---------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126070}Signature    | []{#11.htm_pgfId-1126072}A web server has to run    |
| web server                            | somewhere that has access to the signature storage. |
+---------------------------------------+-----------------------------------------------------+

[]{#11.htm_pgfId-1122094}Once you have the infrastructure set up to use
simple signing, you will need to know the requirements of each client
that uses and verifies the signatures. Table 11.4 lists each
[]{#11.htm_marker-1126246}[]{#11.htm_marker-1126247}of[]{#11.htm_marker-1126248}
these
[]{#11.htm_marker-1126249}[]{#11.htm_marker-1126250}requirements.[]{#11.htm_id_gp7r9gjpnuax}

[]{#11.htm_pgfId-1126341}Table 11.4 Client configuration required for
simple signing

+-----------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126345}Requirements         | []{#11.htm_pgfId-1126347}Description                |
+-----------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126349}GPG public key       | []{#11.htm_pgfId-1126351}The public GPG key used    |
|                                               | for signing must be present on any machine that     |
| []{#11.htm_pgfId-1126387}(/tmp/publickey.gpg) | pulls the signed images.                            |
+-----------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126353}Client's sigstore    | []{#11.htm_pgfId-1126355}The signature web server   |
| configured                                    | has to be configured as a sigstore in a             |
|                                               | /etc/containers/registries.d/\*.yaml file on all    |
|                                               | systems, which need to pull the signed images.      |
+-----------------------------------------------+-----------------------------------------------------+
| []{#11.htm_pgfId-1126357}Client's image trust | []{#11.htm_pgfId-1126359}Image trust has to be      |
| configured                                    | configured on every container engine system that    |
|                                               | uses the images.                                    |
+-----------------------------------------------+-----------------------------------------------------+

## []{#11.htm_pgfId-1122123}11.4 Podman image scanning {#11.htm_heading_id_9 .fm-head}

[]{#11.htm_pgfId-1122126}Podman
[]{#11.htm_marker-1122124}[]{#11.htm_marker-1122125}is not an image
scanner; it leaves this to other tools. But Podman does have a nice
feature that makes it easier for a scanner to scan an image. Podman can
directly mount an image that can be scanned. Scanners look at the
mounted content of an image without having to execute any of the code in
the image. Recall that you cannot mount containers or images in rootless
mode, without first entering the user namespaces. Execute the
`podman`{.fm-code-in-text} `image`{.fm-code-in-text}
`mount`{.fm-code-in-text} command[]{#11.htm_marker-1122127} to show the
error:

``` programlisting
$ podman image mount ubi8
Error: cannot run command "podman image mount" in rootless mode, must 
➥ execute `podman unshare` first
```

[]{#11.htm_pgfId-1122131}In this next example, you first use
`podman`{.fm-code-in-text} `unshare`{.fm-code-in-text} to enter the user
namespace, and then you mount the ubi8 image. Finally, change the
directory to the mount directory, and run a `find`{.fm-code-in-text}
command[]{#11.htm_marker-1122132} to locate all of the
`setuid`{.fm-code-in-text} binaries in the image. Notice that you use
tools from the host operating system to scan the image:

``` programlisting
$ podman unshare
# podman image mount
# mnt=$(podman image mount ubi8)
# echo $mnt
/home/dwalsh/.local/share/containers/storage/overlay/05ddfb76c5eb2146646c70
➥ e20db21a35dfec2215f130ce8bd04fce530142cfbd/merged
# cd $mnt
# /usr/bin/find . -user root -perm -4000
./usr/libexec/dbus-1/dbus-daemon-launch-helper
./usr/bin/chage
./usr/bin/mount
./usr/bin/umount
./usr/bin/newgrp
./usr/bin/gpasswd
./usr/bin/passwd
./usr/bin/su
./usr/sbin/userhelper
./usr/sbin/unix_chkpwd
./usr/sbin/pam_timestamp_check
```

[]{#11.htm_pgfId-1122152}Scanning an image with tools within the image
is not safe, since a hacker of the image can modify the scanning tools.
Podman makes it easy for scanners to do their jobs.

### []{#11.htm_pgfId-1122154}11.5.1 Read-only containers {#11.htm_heading_id_10 .fm-head1}

[]{#11.htm_pgfId-1122156}I []{#11.htm_marker-1122155}often talk about
containers in production versus containers in development. When a
containerized application is in development, it is useful to be able to
write to the container image and potentially commit that image later.
Although this is somewhat common, most people switch to using
Containerfiles when it comes to actually building images. The bottom
line is once developers hand off their software to quality engineering,
they expect content to be treated as read only.

[]{#11.htm_pgfId-1122157}When running a container in production, I
believe it makes sense to run the image in read-only mode. Imagine you
are running an application that gets hacked. The first thing the hacker
wants to do is to write the backdoor into the application; then, the
next time the container or application starts, the container has the
exploit in place. If the image was read only, the hacker is prevented
from leaving a backdoor in place and is forced to start the cycle from
the beginning.

[]{#11.htm_pgfId-1122159}The `--read-only`{.fm-code-in-text}
option[]{#11.htm_marker-1122158} prevents applications from writing
content to the image and forces applications to only write content to
either tmpfs filesystems or volumes added to the container. Sometimes
you might want to block the container from writing anywhere on your
system and only read or execute code within the container. Another
benefit of running containers in read-only mode is that you catch errors
where you did not know the container was writing to the image. Finally,
writing on top of a copy-on-write filesystem, like overlayfs, is almost
always slower than writing to a volume or a tmpfs:

``` programlisting
$ podman run --read-only ubi8 touch /foo
touch: cannot touch '/foo': Read-only file system
```

[]{#11.htm_pgfId-1122162}One problem with running in rootless mode is
that applications often expect to write to /run, /tmp, and /var/tmp.
Podman manages this by automatically mounting tmpfs filesystems at those
locations:

``` programlisting
$ podman run --read-only ubi8 touch /run/foo
```

[]{#11.htm_pgfId-1122164}Because some users believe allowing any places
for a containerized application to write, even on tmpfs mounts, is too
insecure, Podman added a `--read-only-tmpfs`{.fm-code-in-text}
option[]{#11.htm_marker-1122165}. The
`--read-only-tmpfs`{.fm-code-in-text} option[]{#11.htm_marker-1122166}
adds the /run, /tmp, and /var/tmp tmpfs when run in
`--read-only`{.fm-code-in-text} mode[]{#11.htm_marker-1122167}. If you
want to disable this, you can use the
[]{#11.htm_marker-1122168}`–-read-only-tmpfs=false`{.fm-code-in-text}[]{#11.htm_marker-1122169}[]{#11.htm_marker-1122170}
flag[]{#11.htm_marker-1122171}:

``` programlisting
$ podman run --read-only-tmpfs=false --read-only ubi8 touch /run/foo
touch: cannot touch '/run/foo': Read-only file system
```

## []{#11.htm_pgfId-1122175}11.5 Security in depth {#11.htm_heading_id_11 .fm-head}

[]{#11.htm_pgfId-1122178}In
[]{#11.htm_marker-1122176}[]{#11.htm_marker-1122177}the security field,
there is a common idea of *security in depth*. According to this notion,
multiple layers or tools should be used to safeguard assets. The classic
analogy for this is the security of an ancient castle, which would
usually be built high on a hill, have multiple walls, have moats, and
have even more security features. An attacker would need to break
through all of these layers to get to the ruler.

[]{#11.htm_pgfId-1122179}Container security works in much the same way.
Podman uses all of the security mechanisms provided by Linux, giving you
security in depth.

### []{#11.htm_pgfId-1122181}11.5.1 Podman uses all security mechanisms simultaneously {#11.htm_heading_id_12 .fm-head1}

[]{#11.htm_pgfId-1122184}Podman
[]{#11.htm_marker-1122182}[]{#11.htm_marker-1122183}containers can run
with all of the security mechanisms mentioned in this chapter. This
means a hacked container needs to find a way to escape read-only
filesystems, namespaces, dropped capabilities, SELinux, seccomp, and so
on to gain access to your system.

[]{#11.htm_pgfId-1122185}In certain cases, you might need to loosen some
security mechanisms to allow a container to run. Understanding how to
deal with the security features discussed in this chapter is always
better than just running your containers with the
`--privileged`{.fm-code-in-text} flag[]{#11.htm_marker-1122186}, which
turns off all of your defenses.

[]{#11.htm_pgfId-1122187}Podman shoots for a reasonable amount of
security wrapping for containers, but it needs to allow general-purpose
containers to succeed. Understanding your container application's
security requirements and the Podman security features allows you to
ratchet up the security wrapping of your containers. If you know your
container does not need to run as root, don't start it as root. If your
container does not need any Linux capabilities, drop them. Rootless
containers are better than rootful containers. Consider also running
containers in read-only mode or inside of separated user namespaces. You
have the ability to make your castle walls thicker around your
containerized applications by simply employing these
[]{#11.htm_marker-1122188}[]{#11.htm_marker-1122189}measures.

### []{#11.htm_pgfId-1122191}11.5.2 Where should you run your containers? {#11.htm_heading_id_13 .fm-head1}

[]{#11.htm_pgfId-1122194}I'll
[]{#11.htm_marker-1122192}[]{#11.htm_marker-1122193}leave you with one
final thought. At the beginning of this chapter, I talked about the
three pigs living in different types of shelters---standalone houses,
duplexes, and condominium buildings---each slightly less secure than the
last. Container security can do better than the pigs living in
individual housing units, in that the units can be stacked together.

[]{#11.htm_pgfId-1122195}Imagine you had two different containers: a web
frontend and a database with credit card data. If you wanted to make
sure they were separate, you could put them together on the system
inside containers or, better yet, put them in containers but put them
into separate VMs, and then, finally, put the VMs on separate machines.
You would be able to put your web frontend into a machine running a VM
inside of a container inside of your DMZ exposed to the internet. You
could do all this while putting your database inside of your private
network, without limited network access to your web frontends. The
possibilities are
[]{#11.htm_marker-1122196}[]{#11.htm_marker-1122197}nearly
[]{#11.htm_marker-1122198}[]{#11.htm_marker-1122199}endless.

## []{#11.htm_pgfId-1122200}Summary {#11.htm_heading_id_14 .fm-head}

- []{#11.htm_pgfId-1122201 .calibre17}Container security has many
  different facets, including separation of running containers, trusting
  the images and registries, scanning the images, and so on.

- []{#11.htm_pgfId-1122202 .calibre17}Defense in depth means your
  container tooling takes advantage of as many security mechanisms as
  possible. If one security mechanism fails, the others might still
  protect your system.

- []{#11.htm_pgfId-1122203 .calibre17}Container security is all about
  protecting the Linux kernel and host filesystem from hostile container
  processes.

- []{#11.htm_pgfId-1122204 .calibre17}Setting up and controlling the
  container images you run on your systems is critical. Do not allow
  your users to run random applications from the
  []{#11.htm_marker-1122205 .calibre17}internet.

[]{#A.htm}

# []{#A.htm_pgfId-1277651}[]{#A.htm_id_ng1ubyme0txq}[]{#A.htm_pgfId-1277653}Appendix A. Podman-related container tools {#A.htm_heading_id_2 .tochead}

[]{#A.htm_pgfId-1277656}[]{#A.htm_id_ypyilma7lhnr}This appendix
[]{#A.htm_marker-1277655}describes the three tools that use
containers/storage and containers/image libraries. These tools address
the following functionalities:

- []{#A.htm_pgfId-1277657 .calibre17}Moving container images between
  different container registries and storage

- []{#A.htm_pgfId-1277658 .calibre17}Building container images

- []{#A.htm_pgfId-1277659 .calibre17}Testing, developing, and running
  containers in production on a single node

- []{#A.htm_pgfId-1277660 .calibre17}Running containers in production at
  scale

[]{#A.htm_pgfId-1277661}As the original creator of Podman, I recognized
the need for specialized tools, each performing specific functionality
rather than a one-size-fits-all monolithic solution.

[]{#A.htm_pgfId-1277662}From a security perspective, each of these four
categories requires different security constraints. Containers running
in production need to be run in a more secure environment than ones
running in development and testing. Moving container images between
registries requires no privileged access to the host you are running the
command on---only remote access to the registries. You will have the
least secure system with a monolithic daemon. If my containers need more
access during builds, then in production, they get the same access as
during builds.

[]{#A.htm_pgfId-1277664}Another critical problem with a monolithic
daemon is that it prevents experimentation with the tools and doesn't
allow them to go their own way. One example of this is when we proposed
a change to the Docker daemon to allow users to pull different types of
OCI content off of container registries. This change was denied, as it
had little to do with Docker containers.

[]{#A.htm_pgfId-1277665}Similarly, when the monolithic daemon is
modified for one product, it can negatively affect features of another
one using that daemon. It could cause performance degradation or
complete breakage. This happened when Kubernetes was being developed,
since it relied on the Docker daemon as the container engine. But since
Docker is monolithic and being developed for many other projects, many
of its changes affected Kubernetes, leading to instability. It was
obvious that Kubernetes needed a dedicated container engine for its
workloads, and in December 2020 it was announced that Kubernetes will
eventually use the newly developed standard, the Container Runtime
Interface (CRI; see [http://mng.bz/yaDq](http://mng.bz/yaDq){.url}) to
improve interaction between orchestrators and different container
runtimes. I wrote a coloring book, *The Container
Commandos*[]{#A.htm_marker-1282235} (figure A.1;
[https://red.ht/3gfVlHF](https://red.ht/3gfVlHF){.url}), illustrated by
Máirín Duffy[]{#A.htm_marker-1282237} (@marin), describing the container
tools talked about in this appendix, based on superheroes.

::: figure
![](images/A-01.png){.calibre18}

Figure A.1 The Container Coloring Book
([https://red.ht/3gfVlHF](https://red.ht/3gfVlHF){.url})
:::

[]{#A.htm_pgfId-1277678}Finally, sometimes there are conflicting
interests or release schedules in play. Having separate, independent
tools allows releases to be deployed independently from all the others
at their own pace to guarantee new features to their customers. Four
projects were created for the distinct functions described in table A.1.

[]{#A.htm_pgfId-1280253}Table A.1 Primary container tools based on
containers/storage and containers/image.

+----------------------------------------------------------+----------------------------------------------------------------------------------------+
| []{#A.htm_pgfId-1280257}Tool                             | []{#A.htm_pgfId-1280259}Description                                                    |
+----------------------------------------------------------+----------------------------------------------------------------------------------------+
| []{#A.htm_pgfId-1280261}Skopeo[]{#A.htm_marker-1282252}  | []{#A.htm_pgfId-1280263}Performs various operations on container images and image      |
|                                                          | repositories                                                                           |
|                                                          | ([https://github.com/containers/skopeo](https://github.com/containers/skopeo){.url})   |
+----------------------------------------------------------+----------------------------------------------------------------------------------------+
| []{#A.htm_pgfId-1280265}Buildah[]{#A.htm_marker-1282258} | []{#A.htm_pgfId-1280267}Facilitates a wide range of operations on container images     |
|                                                          | ([https://github.com/containers/buildah](https://github.com/containers/buildah){.url}) |
+----------------------------------------------------------+----------------------------------------------------------------------------------------+
| []{#A.htm_pgfId-1280269}Podman[]{#A.htm_marker-1282264}  | []{#A.htm_pgfId-1280271}All-in-one management tool for pods, containers, and images    |
|                                                          | ([https://github.com/containers/podman](https://github.com/containers/podman){.url})   |
+----------------------------------------------------------+----------------------------------------------------------------------------------------+
| []{#A.htm_pgfId-1280273}CRI-O[]{#A.htm_marker-1282270}   | []{#A.htm_pgfId-1280275}OCI-based implementation of the Kubernetes Container Runtime   |
|                                                          | Interface ([https://github.com/cri-o/cri-o](https://github.com/cri-o/cri-o){.url})     |
+----------------------------------------------------------+----------------------------------------------------------------------------------------+

[]{#A.htm_pgfId-1277711}As you have already learned a great deal about
Podman, you know now why it is included in this list. Podman is an
excellent tool for understanding and developing containers as well as
pods and images. It encapsulates everything Docker CLI does but without
locking everything under one central daemon. Because Podman works
without a daemon and uses the operating system for sharing data, other
tools can work with the same data stores and libraries. The rest of this
appendix describes the rest of the tools, starting with Skopeo (figure
A.2).

::: figure
![](images/A-02.png){.calibre18}

Figure A.2 Skopeo, Buildah, and Podman work together by sharing the same
containers/storage images and containers/image library for pulling and
pushing images.
:::

## []{#A.htm_pgfId-1277719}A.1 Skopeo {#A.htm_heading_id_3 .fm-head}

[]{#A.htm_pgfId-1277722}While
[]{#A.htm_marker-1280942}[]{#A.htm_marker-1280943}using container
engines like Docker or Podman, if you want to inspect a container image
in a registry, you are required to pull this image from the registry to
your local storage. Only then can you examine it. The problem is that
this image can be huge, and after inspecting it, you might realize it
wasn't what you expected, and you wasted time pulling it. Because the
protocol used to pull the image and inspect it is just a web protocol, a
simple tool, Skopeo, was created to pull the image's detailed
information and display it on the screen. *Skopeo* is the Greek word for
*remote viewing*.

::: figure
![](images/A-UN01.png){.calibre18}
:::

[]{#A.htm_pgfId-1277728}Execute the following `skopeo`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#A.htm_marker-1280173} to examine
an image's detailed information in JSON form:

``` programlisting
$ skopeo inspect docker:/ /quay.io/rhatdan/myimage
{
  "Name": "quay.io/rhatdan/myimage",
  "Digest":
"sha256:fe798c1576dc7b70d7de3b3ab7c72cd22300b061921f052279d88729708092d8",
  "RepoTags": [
      "Latest",
      "1.0"
  ],
...
```

[]{#A.htm_pgfId-1277739}Skopeo was extended to also copy images off of
registries. Eventually, Skopeo became the tool for copying images
between different types of storage (transports). These types of storage
became the transports defined in table A.2.

[]{#A.htm_pgfId-1280371}Table A.2 Podman-supported transports

+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280375}Transport                                                       | []{#A.htm_pgfId-1280377}Description                 |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280379}Container registry                                              | []{#A.htm_pgfId-1280381}This is the default         |
| (`docker`{.fm-code-in-text1}[]{#A.htm_marker-1280406})                                  | transport. It references a container image stored   |
|                                                                                         | in a remote container image registry website.       |
|                                                                                         | Registries store and share container images (e.g.,  |
|                                                                                         | docker.io and quay.io).                             |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280383}`oci`{.fm-code-in-text1}[]{#A.htm_marker-1280407}               | []{#A.htm_pgfId-1280385}References a container      |
|                                                                                         | image; compliant with the Open Container Initiative |
|                                                                                         | Format specification. The manifest and layer        |
|                                                                                         | tarballs are located in the local directory as      |
|                                                                                         | individual files.                                   |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280387}`dir`{.fm-code-in-text1}[]{#A.htm_marker-1280408}               | []{#A.htm_pgfId-1280389}References a container      |
|                                                                                         | image; compliant with the Docker image layout. It   |
|                                                                                         | is very similar to the `oci`{.fm-code-in-text1}     |
|                                                                                         | transport but stores the files using the legacy     |
|                                                                                         | Docker format. As a non-standardized format, it is  |
|                                                                                         | primarily useful for debugging or noninvasive       |
|                                                                                         | container inspection.                               |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280391}`docker-archive`{.fm-code-in-text1}[]{#A.htm_marker-1280409}    | []{#A.htm_pgfId-1280393}References a container      |
|                                                                                         | image in a Docker image layout, which is packed     |
|                                                                                         | into a TAR archive.                                 |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280395}`oci-archive`{.fm-code-in-text1}[]{#A.htm_marker-1280410}       | []{#A.htm_pgfId-1280397}References an image         |
|                                                                                         | compliant with the Open Container Initiative Format |
|                                                                                         | specification, which is packed into a TAR archive.  |
|                                                                                         | It is very similar to the                           |
|                                                                                         | `docker-archive`{.fm-code-in-text1} transport but   |
|                                                                                         | stores an image in OCI format.                      |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280399}`docker-daemon`{.fm-code-in-text1}[]{#A.htm_marker-1280411}     | []{#A.htm_pgfId-1280401}References an image stored  |
|                                                                                         | in the Docker daemon's internal storage. Since the  |
|                                                                                         | Docker daemon requires root privileges, Podman has  |
|                                                                                         | to be run by the root user.                         |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280403}`container-storage`{.fm-code-in-text1}[]{#A.htm_marker-1280412} | []{#A.htm_pgfId-1280405}References an image located |
|                                                                                         | in a local container storage. It is not a transport |
|                                                                                         | but more of a mechanism for storing images. It can  |
|                                                                                         | be used to convert other transports into            |
|                                                                                         | `container-storage`{.fm-code-in-text1}. Podman      |
|                                                                                         | defaults to using                                   |
|                                                                                         | `container-storage`{.fm-code-in-text1} for local    |
|                                                                                         | images.                                             |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#A.htm_pgfId-1277784}Other container engines and tools wanted to use
the functionality developed in Skopeo to copy images, so Skopeo was
split in two: the command line, Skopeo, and the underlying library,
containers/image[]{#A.htm_marker-1277785}. Splitting functionality into
a separate library made it possible to build other container tools,
including Podman.

[]{#A.htm_pgfId-1277788}The `skopeo`{.fm-code-in-text}
`copy`{.fm-code-in-text} command[]{#A.htm_marker-1277787} is very
popular for copying images between different types of container storage.
One difference compared to Podman and Buildah, as you'll see in section
A.2, is that Skopeo forces users to specify the transport for the source
and destination. Podman and Buildah default to using the
`docker`{.fm-code-in-text}[]{#A.htm_marker-1277790} or
`containers-storage`{.fm-code-in-text}
transport[]{#A.htm_marker-1277791}, depending on the context and
command. In the following example, you will copy an image from a
container registry using the `docker`{.fm-code-in-text}
transport[]{#A.htm_marker-1277792} and store the image locally using the
`container-storage`{.fm-code-in-text} transport:

``` programlisting
$ skopeo copy docker:/ /quay.io/rhatdan/myimage containers-storage:quay.io/rhatdan/myimage
Getting image source signatures
Copying blob dfd8c625d022 done 
Copying blob 68e8857e6dcb done 
Copying blob e21480a19686 done 
Copying blob fbfcc23454c6 done 
Copying blob 3f412c5136dd done 
Copying config 2c7e43d880 done 
Writing manifest to image destination
Storing signatures
```

[]{#A.htm_pgfId-1277805}Another command many Skopeo users use is
`skopeo`{.fm-code-in-text}
`sync`{.fm-code-in-text}[]{#A.htm_marker-1277804}, which lets you
synchronize images between container registries and local storage.

[]{#A.htm_pgfId-1277806}Skopeo is mainly used for infrastructure
projects to help provision multiple container registries---for example,
copying images from a public registry to a private one. Table A.3
describes the most popular commands used with Skopeo. One of the first
tools to take advantage of the containers/image library was
[]{#A.htm_marker-1277807}[]{#A.htm_marker-1277808}Buildah.

[]{#A.htm_pgfId-1280501}Table A.3 Primary Skopeo commands and their
description

+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280505}Command                                                   | []{#A.htm_pgfId-1280507}Description                 |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280509}`skopeo copy`{.fm-code-in-text1}[]{#A.htm_marker-1280540} | []{#A.htm_pgfId-1280511}Copy an image (manifest,    |
|                                                                                   | filesystem layers, or signatures) from one location |
|                                                                                   | to another.                                         |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280513}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280515}Mark the image name for     |
| `delete`{.fm-code-in-text1}[]{#A.htm_marker-1280541}                              | later deletion by the registry's garbage collector. |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280517}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280519}Return low-level            |
| `inspect`{.fm-code-in-text1}[]{#A.htm_marker-1280542}                             | information about an image name in a registry.      |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280521}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280523}List tags in the            |
| `list-tags`{.fm-code-in-text1}[]{#A.htm_marker-1280543}                           | transport-specific image repository.                |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280525}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280527}Log in to a container       |
| `login`{.fm-code-in-text1}[]{#A.htm_marker-1280544}                               | registry (the same as `podman`{.fm-code-in-text1}   |
|                                                                                   | `login`{.fm-code-in-text1}).                        |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280529}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280531}Log out of a container      |
| `logout`{.fm-code-in-text1}[]{#A.htm_marker-1280545}                              | registry (the same as `podman`{.fm-code-in-text1}   |
|                                                                                   | `logout`{.fm-code-in-text1}).                       |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280533}`skopeo`{.fm-code-in-text1} `manifest`{.fm-code-in-text1} | []{#A.htm_pgfId-1280535}Compute a manifest digest   |
| `digest`{.fm-code-in-text1}[]{#A.htm_marker-1280546}                              | for a manifest file, and write it to standard       |
|                                                                                   | output.                                             |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#A.htm_pgfId-1280537}`skopeo`{.fm-code-in-text1}                               | []{#A.htm_pgfId-1280539}Synchronize images between  |
| `sync`{.fm-code-in-text1}[]{#A.htm_marker-1280547}                                | container registries and local directories.         |
+-----------------------------------------------------------------------------------+-----------------------------------------------------+

## []{#A.htm_pgfId-1277858}A.2 Buildah {#A.htm_heading_id_4 .fm-head}

[]{#A.htm_pgfId-1277861}As
[]{#A.htm_marker-1277859}[]{#A.htm_marker-1277860}you learned in section
1.1.2, creating a container image means creating a directory on disk and
adding content to it to make it look like the root,
`/`{.fm-code-in-text}, directory on a Linux machine, called a rootfs.
Originally, the only way to do this was with `docker`{.fm-code-in-text}
`build`{.fm-code-in-text}, using a Dockerfile. While Dockerfiles and
Containerfiles are excellent ways of creating recipes for your container
images, a low-level building block tool that allowed other ways to build
container images was needed---one that allowed breaking the image-build
process into individual commands, letting you use other more powerful
scripting tools and languages than Containerfile to build images. We
created a tool called Buildah[]{#A.htm_marker-1277862}
([https://buildah.io](https://buildah.io){.url}) to serve this purpose.

::: figure
![](images/A-UN02.png){.calibre18}
:::

[]{#A.htm_pgfId-1277867}Buildah was designed to be that simple tool for
building container images. It's built on top of the container/storage
and container/image libraries, just like Podman and Skopeo. It has a lot
of functionality similar to Podman. You can pull images, push images,
commit images, and even run containers on images. What mainly
differentiates Podman from Buildah is the underlying concept of a
*container*[]{#A.htm_marker-1277868}. A Podman container is a long-lived
one, a *running* container[]{#A.htm_marker-1277869}, while a Buildah
container is just a temporary one, a *working* container, which will be
used to create an OCI image.

[]{#A.htm_pgfId-1277870}[Note]{.fm-callout-head} Buildah is a Linux-only
tool, not available on Mac or Windows. However, Podman embeds Buildah in
the `podman`{.fm-code-in-text1} `build`{.fm-code-in-text1}
command[]{#A.htm_marker-1277871}. Podman on Mac and Windows uses the
Buildah code on the server side, allowing those platforms to build using
Containerfiles and Dockerfiles. See appendixes E and F for more
information.

[]{#A.htm_marker-1282679}[]{#A.htm_pgfId-1277872}Buildah was designed to
take the steps defined in a Dockerfile and make them available at the
command line. Buildah wanted to simplify building a container image by
allowing you to use all of the tools available within the OS to populate
the image. You can add data to this directory via standard Linux tools,
like `cp`{.fm-code-in-text}[]{#A.htm_marker-1277873},
`make`{.fm-code-in-text}[]{#A.htm_marker-1277874},
`yum`{.fm-code-in-text}
`install`{.fm-code-in-text}[]{#A.htm_marker-1277875}, and so on. Then
commit the rootfs into a tarball, add some JSON to describe what the
creator of the image wanted the image to do, and finally, push this to a
container registry. Basically, Buildah breaks down the steps you learned
about in a Containerfile into individual commands you can execute from a
shell.

[]{#A.htm_pgfId-1277876}[Note]{.fm-callout-head} The name *Buildah* is a
play on the way I pronounce *builder*. If you ever heard me speak, you'd
notice I have a strong Boston accent. When the core team asked what I
wanted to call the tool, I said, "I don't care, just call it *builder*."
And they heard *Buildah*.

[]{#A.htm_pgfId-1277877}The first step when building a new container
image is pulling a base image. In a Containerfile, this is done with the
`FROM`{.fm-code-in-text} instruction[]{#A.htm_marker-1284237}.

### []{#A.htm_pgfId-1277883}A.2.1 Creating a working container from a base image {#A.htm_heading_id_5 .fm-head1}

[]{#A.htm_pgfId-1277888}The
[]{#A.htm_marker-1284239}[]{#A.htm_marker-1284240}[]{#A.htm_marker-1284241}first
command to look at is `buildah`{.fm-code-in-text}
`from`{.fm-code-in-text}[]{#A.htm_marker-1284242}. It is equivalent to
the Containerfile's `FROM`{.fm-code-in-text}
instruction[]{#A.htm_marker-1284244}. When executing
`buildah`{.fm-code-in-text} `from`{.fm-code-in-text}
`IMAGE`{.fm-code-in-text}, it pulls the specified image from the
container registry, saves it in a local container storage, and creates a
working container based on this image. As mentioned previously, this
container is similar to a Podman container, except it exists temporarily
only to become a container image. In the following example, a working
container is created based on an ubi8-init image.

[]{#A.htm_pgfId-1277890}Listing A.1 Buildah pulling an image and
creating a Buildah container

``` programlisting
$ buildah from ubi8-init
Resolved "ubi8-init" as an alias (/etc/containers/registries.conf.d/
➥ 000-shortnames.conf) 
Trying to pull registry.access.redhat.com/
➥ ubi8-init:latest...                        ❶
Getting image source signatures
Checking if image destination supports signatures
Copying blob adffa6963146 done 
Copying blob 29250971c1d2 done 
Copying blob 26f1167feaf7 done 
Copying config 4b85030f92 done 
Writing manifest to image destination
Storing signatures
ubi8-init-working-container                 ❷
```

[]{#A.htm_pgfId-1283956}[❶]{.fm-combinumeral} Pulls the image from the
container registry

[]{#A.htm_pgfId-1283957}[❷]{.fm-combinumeral} Outputs a new container
name

[]{#A.htm_pgfId-1277907}Notice that the `buildah`{.fm-code-in-text}
`from`{.fm-code-in-text} output looks the same as the
`podman`{.fm-code-in-text} `pull`{.fm-code-in-text} output, except for
the last line, which outputs the container name:
`ubi8-init-working-container`{.fm-code-in-text}. If you run the
`buildah`{.fm-code-in-text} `from`{.fm-code-in-text}
command[]{#A.htm_marker-1277908} again, you get a second container name:

``` programlisting
$ buildah from ubi8-init
ubi8-init-working-container-1
```

[]{#A.htm_pgfId-1277911}Buildah keeps track of its containers and
generates each one by incrementing a counter. Of course you can override
the container name with the `--name`{.fm-code-in-text}
option[]{#A.htm_marker-1277912}. Next, you will add content to this
container
[]{#A.htm_marker-1277913}[]{#A.htm_marker-1277914}[]{#A.htm_marker-1277915}image.

### []{#A.htm_pgfId-1277917}A.2.2 Adding data to a working container {#A.htm_heading_id_6 .fm-head1}

[]{#A.htm_pgfId-1277923}Buildah
[]{#A.htm_marker-1277918}[]{#A.htm_marker-1277919}[]{#A.htm_marker-1277920}has
two commands, `buildah`{.fm-code-in-text}
`copy`{.fm-code-in-text}[]{#A.htm_marker-1277921} and
`buildah`{.fm-code-in-text}
`add`{.fm-code-in-text}[]{#A.htm_marker-1277922}, for copying the
contents of a file, URL, or directory into the container's working
directory. They map to the same functionality as the Containerfile's
`COPY`{.fm-code-in-text}[]{#A.htm_marker-1277924} and
`ADD`{.fm-code-in-text} instructions[]{#A.htm_marker-1277925}.

[]{#A.htm_pgfId-1277926}[Note]{.fm-callout-head} It is somewhat
confusing to have two commands that do almost the same thing. In most
cases, I recommend you just use `buildah`{.fm-code-in-text1}
`copy`{.fm-code-in-text1} and `COPY`{.fm-code-in-text1} inside a
Containerfile. The main difference between the two is that
`COPY`{.fm-code-in-text1} only copies local files and directories off of
the host into the container image. The `add`{.fm-code-in-text1}
command[]{#A.htm_marker-1277927} supports the use of URLs to pull remote
content and insert it into your container. The `ADD`{.fm-code-in-text1}
command[]{#A.htm_marker-1277928} also supports taking TAR and ZIP files
and expanding them when copied into the container image.

[]{#A.htm_pgfId-1277930}The syntax of the `buildah`{.fm-code-in-text}
`copy`{.fm-code-in-text} command requires you to specify the name of the
container previously created by the `buildah`{.fm-code-in-text}
`from`{.fm-code-in-text} command, followed by the source and,
optionally, destination. If the destination is not provided, source data
will be copied into the container's working directory. The destination
directory will be created if it doesn't exist yet.

[]{#A.htm_pgfId-1277932}The following example copies the local
html/index.html file (created previously in section 3.1) into the
/var/lib/www/html directory in the container:

``` programlisting
$ buildah copy ubi8-init-working-container html/index.html 
➥ /var/lib/www/html/
```

[]{#A.htm_pgfId-1277935}If you would like to use more advanced tools
like package managers to add content to your containers, Buildah
supports running commands inside the
[]{#A.htm_marker-1277936}[]{#A.htm_marker-1277937}[]{#A.htm_marker-1277938}containers.

### []{#A.htm_pgfId-1277940}A.2.3 Running commands in a working container {#A.htm_heading_id_7 .fm-head1}

[]{#A.htm_pgfId-1277944}To
[]{#A.htm_marker-1277941}[]{#A.htm_marker-1277942}[]{#A.htm_marker-1277943}run
a command inside the working container, you need to execute
`buildah`{.fm-code-in-text} `run`{.fm-code-in-text}. Under the hood,
this command works exactly the same as the `RUN`{.fm-code-in-text}
instruction[]{#A.htm_marker-1277945}; it starts a new container on top
of the current one, executes a specified command, and commits the result
back to the working container. The syntax of `buildah`{.fm-code-in-text}
`run`{.fm-code-in-text} requires you to specify the name of the working
container followed by the command. In the following example, you install
the `httpd`{.fm-code-in-text} service[]{#A.htm_marker-1277946} within
the container:

``` programlisting
$ buildah run ubi8-init-working-container dnf -y install httpd
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered with an entitlement server. You can use 
➥ subscription-manager to register.
...
Complete!
```

[]{#A.htm_pgfId-1277955}To make sure you will have a running web server
once the running container is created, the next command enables the
Apache HTTP Server service:

``` programlisting
$ buildah run ubi8-init-working-container systemctl enable httpd.service
Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service → 
➥ /usr/lib/systemd/system/httpd.service.
```

[]{#A.htm_pgfId-1277962}Table A.4 shows the relationship between
Containerfile instructions and Buildah
[]{#A.htm_marker-1277959}[]{#A.htm_marker-1277960}[]{#A.htm_marker-1277961}commands.

[]{#A.htm_pgfId-1280628}Table A.4 Containerfile instructions mapped to
Buildah commands

+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280634}Instruction                                        | []{#A.htm_pgfId-1280636}Command                      | []{#A.htm_pgfId-1280638}Description |
+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280640}`ADD`{.fm-code-in-text1}[]{#A.htm_marker-1282708}  | []{#A.htm_pgfId-1280642}`buildah`{.fm-code-in-text1} | []{#A.htm_pgfId-1280644}Add the     |
|                                                                            | `add`{.fm-code-in-text1}                             | contents of a file, URL, or         |
|                                                                            |                                                      | directory to the container.         |
+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280646}`COPY`{.fm-code-in-text1}[]{#A.htm_marker-1282715} | []{#A.htm_pgfId-1280648}`buildah`{.fm-code-in-text1} | []{#A.htm_pgfId-1280650}Copies the  |
|                                                                            | `copy`{.fm-code-in-text1}                            | contents of a file, URL, or         |
|                                                                            |                                                      | directory into a container's        |
|                                                                            |                                                      | working directory.                  |
+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280652}`FROM`{.fm-code-in-text1}[]{#A.htm_marker-1282722} | []{#A.htm_pgfId-1280654}`buildah`{.fm-code-in-text1} | []{#A.htm_pgfId-1280656}Creates a   |
|                                                                            | `from`{.fm-code-in-text1}                            | new working container, either from  |
|                                                                            |                                                      | scratch or using a specified image  |
|                                                                            |                                                      | as a starting point.                |
+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280658}`RUN`{.fm-code-in-text1}[]{#A.htm_marker-1282729}  | []{#A.htm_pgfId-1280660}`buildah`{.fm-code-in-text1} | []{#A.htm_pgfId-1280662}Runs a      |
|                                                                            | `run`{.fm-code-in-text1}                             | command inside the container.       |
+----------------------------------------------------------------------------+------------------------------------------------------+-------------------------------------+

### []{#A.htm_pgfId-1278002}A.2.4 Adding content to a working container directly from the host {#A.htm_heading_id_8 .fm-head1}

[]{#A.htm_pgfId-1278006}Up
[]{#A.htm_marker-1278003}[]{#A.htm_marker-1278004}[]{#A.htm_marker-1278005}until
now, you've seen how Buildah can perform the same commands you execute
within a Containerfile, but one of Buildah's goals is exposing the
container image rootfs[]{#A.htm_marker-1278007} directly to the host.
This allows you to use commands available on your host machine to add
content to the container image, without requiring the commands to be
present inside the container image.

[]{#A.htm_pgfId-1278009}The `buildah`{.fm-code-in-text}
`mount`{.fm-code-in-text} command[]{#A.htm_marker-1278008} allows you to
mount a working container's root filesystem directly on your system and
then use tools like `cp`{.fm-code-in-text}[]{#A.htm_marker-1278010},
`make`{.fm-code-in-text}[]{#A.htm_marker-1278011},
`dnf`{.fm-code-in-text}[]{#A.htm_marker-1278012}, or even an editor to
manipulate the contents of the container's rootfs.

[]{#A.htm_pgfId-1278014}If you run Buildah as root, you can simply
execute the `buildah`{.fm-code-in-text} `mount`{.fm-code-in-text}
command. But in rootless mode, this isn't allowed. Recall from section
2.2.10, where you learned about the `podman`{.fm-code-in-text}
`mount`{.fm-code-in-text} command[]{#A.htm_marker-1278015}, that you
must first enter the user namespace. Similarly, the
`buildah`{.fm-code-in-text} `unshare`{.fm-code-in-text}
command[]{#A.htm_marker-1278016} creates a shell running in the user
namespace. Once you are in the user namespace, you can mount the
container. In the following example, using what you have learned so far,
you will use commands from your host's operating system
`grep`{.fm-code-in-text} to add content to the container:

``` programlisting
$ buildah unshare
# mnt=$(buildah mount ubi8-init-working-container)
# echo $mnt
/home/dwalsh/.local/share/containers/storage/overlay/133e1728eac26589b07984
➥ e3bdf31b5e318159940c866d9e0493a1d08e1d2f6a/merged
# grep dwalsh /etc/passwd >> $mnt/etc/passwd
# exit
```

[]{#A.htm_pgfId-1278024}Now you can check if your changes were actually
applied inside a working container:

``` programlisting
$ buildah run ubi8-init-working-container grep dwalsh /etc/passwd
dwalsh:x:3267:3267:Daniel J Walsh:/home/dwalsh:/bin/bash
```

[]{#A.htm_pgfId-1278027}After you are done populating the content of the
working container, it's time to specify other instructions from the
Containerfile. These will describe your intentions as the container
image
[]{#A.htm_marker-1278028}[]{#A.htm_marker-1278029}[]{#A.htm_marker-1278030}creator.

### []{#A.htm_pgfId-1278032}A.2.5 Configuring a working container {#A.htm_heading_id_9 .fm-head1}

[]{#A.htm_pgfId-1278035}You
[]{#A.htm_marker-1278033}[]{#A.htm_marker-1278034}probably noticed in
table A.3 that there are a lot of missing Containerfile instructions.
Containerfile instructions like
`LABEL`{.fm-code-in-text}[]{#A.htm_marker-1278036},
`EXPOSE`{.fm-code-in-text}[]{#A.htm_marker-1278037},
`WORKDIR`{.fm-code-in-text}[]{#A.htm_marker-1278038},
`CMD`{.fm-code-in-text}[]{#A.htm_marker-1278039}, and
`ENTRYPOINT`{.fm-code-in-text}[]{#A.htm_marker-1278040} are used to
populate the OCI image specification.

[]{#A.htm_pgfId-1278042}Now, using the `buildah`{.fm-code-in-text}
`config`{.fm-code-in-text} command[]{#A.htm_marker-1278041}, you can add
a port to expose (`EXPOSE`{.fm-code-in-text}) and mark a location inside
the container rootfs as a volume (`VOLUME`{.fm-code-in-text}), which
will be used as the website root directory:

``` programlisting
$ buildah config --port=80 --volume=/var/lib/www/html 
➥ ubi8-init-working-container
```

[]{#A.htm_pgfId-1278045}You can inspect the corresponding OCI image
specification fields using the `buildah`{.fm-code-in-text}
`inspect`{.fm-code-in-text} command[]{#A.htm_marker-1281981}:

``` programlisting
$ buildah inspect --format '{{ .OCIv1.Config.ExposedPorts }} {{ 
➥ .OCIv1.Config.Volumes }}' ubi8-init-working-container
map[80:{}] map[/var/lib/www/html:{}]
```

[]{#A.htm_pgfId-1278052}[]{#A.htm_id_zhze1r6dd4nl}Table A.4 shows the
relationship between Containerfile instructions and Buildah config
options. You can also refer to table A.5 for additional information on
these instructions.

[]{#A.htm_pgfId-1280793}Table A.5 Containerfile instructions mapped to
Buildah config options

+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280799}Instruction                                               | []{#A.htm_pgfId-1280801}Option                             | []{#A.htm_pgfId-1280803}Description |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280805}`MAINTAINER`{.fm-code-in-text1}                           | []{#A.htm_pgfId-1280807}`--author`{.fm-code-in-text1}      | []{#A.htm_pgfId-1280809}Sets        |
|                                                                                   |                                                            | contact information of the image    |
|                                                                                   |                                                            | author                              |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280811}`CMD`{.fm-code-in-text1}[]{#A.htm_marker-1280876}         | []{#A.htm_pgfId-1280813}`--cmd`{.fm-code-in-text1}         | []{#A.htm_pgfId-1280815}Sets a      |
|                                                                                   |                                                            | default command to run within a     |
|                                                                                   |                                                            | container                           |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280817}`ENTRYPOINT`{.fm-code-in-text1}[]{#A.htm_marker-1280877}  | []{#A.htm_pgfId-1280819}`--entrypoint`{.fm-code-in-text1}  | []{#A.htm_pgfId-1280821}Sets a      |
|                                                                                   |                                                            | command for a container that will   |
|                                                                                   |                                                            | run as an executable                |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280823}`ENV`{.fm-code-in-text1}[]{#A.htm_marker-1280878}         | []{#A.htm_pgfId-1280825}`--env`{.fm-code-in-text1}         | []{#A.htm_pgfId-1280827}Sets the    |
|                                                                                   |                                                            | environment variable for all        |
|                                                                                   |                                                            | subsequent instructions             |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280829}`HEALTHCHECK`{.fm-code-in-text1}[]{#A.htm_marker-1280879} | []{#A.htm_pgfId-1280831}`--healthcheck`{.fm-code-in-text1} | []{#A.htm_pgfId-1280833}Specifies a |
|                                                                                   |                                                            | command to check if a container is  |
|                                                                                   |                                                            | still running                       |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280835}`LABEL`{.fm-code-in-text1}[]{#A.htm_marker-1280880}       | []{#A.htm_pgfId-1280837}`--label`{.fm-code-in-text1}       | []{#A.htm_pgfId-1280839}Adds        |
|                                                                                   |                                                            | key-value metadata                  |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280841}`ONBUILD`{.fm-code-in-text1}[]{#A.htm_marker-1280881}     | []{#A.htm_pgfId-1280843}`--onbuild`{.fm-code-in-text1}     | []{#A.htm_pgfId-1280845}Sets a      |
|                                                                                   |                                                            | command to be run when the image is |
|                                                                                   |                                                            | used as the base for another image  |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280847}`EXPOSE`{.fm-code-in-text1}[]{#A.htm_marker-1280882}      | []{#A.htm_pgfId-1280849}`--port`{.fm-code-in-text1}        | []{#A.htm_pgfId-1280851}Specifies a |
|                                                                                   |                                                            | port that the container will listen |
|                                                                                   |                                                            | on at run time                      |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280853}`STOPSIGNAL`{.fm-code-in-text1}[]{#A.htm_marker-1280883}  | []{#A.htm_pgfId-1280855}`--stop-signal`{.fm-code-in-text1} | []{#A.htm_pgfId-1280857}Sets the    |
|                                                                                   |                                                            | stop signal to be sent when the     |
|                                                                                   |                                                            | container is stopped                |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280859}`USER`{.fm-code-in-text1}[]{#A.htm_marker-1280884}        | []{#A.htm_pgfId-1280861}`--user`{.fm-code-in-text1}        | []{#A.htm_pgfId-1280863}Sets the    |
|                                                                                   |                                                            | user to be used when running the    |
|                                                                                   |                                                            | container and for all subsequent    |
|                                                                                   |                                                            | `RUN`{.fm-code-in-text1},           |
|                                                                                   |                                                            | `CMD`{.fm-code-in-text1}, and       |
|                                                                                   |                                                            | `ENTRYPOINT`{.fm-code-in-text1}     |
|                                                                                   |                                                            | instructions                        |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280865}`VOLUME`{.fm-code-in-text1}[]{#A.htm_marker-1280885}      | []{#A.htm_pgfId-1280867}`--volume`{.fm-code-in-text1}      | []{#A.htm_pgfId-1280869}Adds a      |
|                                                                                   |                                                            | mount point and marks it as a       |
|                                                                                   |                                                            | volume for external data            |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+
| []{#A.htm_pgfId-1280871}`WORKDIR`{.fm-code-in-text1}[]{#A.htm_marker-1280886}     | []{#A.htm_pgfId-1280873}`--workingdir`{.fm-code-in-text1}  | []{#A.htm_pgfId-1280875}Sets the    |
|                                                                                   |                                                            | working directory for all           |
|                                                                                   |                                                            | subsequent                          |
|                                                                                   |                                                            | `RUN`{.fm-code-in-text1},           |
|                                                                                   |                                                            | `CMD`{.fm-code-in-text1},           |
|                                                                                   |                                                            | `ENTRYPOINT`{.fm-code-in-text1},    |
|                                                                                   |                                                            | `COPY`{.fm-code-in-text1}, and      |
|                                                                                   |                                                            | `ADD`{.fm-code-in-text1}            |
|                                                                                   |                                                            | instructions                        |
+-----------------------------------------------------------------------------------+------------------------------------------------------------+-------------------------------------+

[]{#A.htm_pgfId-1278146}Once you have finished adding content to the
Buildah container image and adding configuration to the OCI image
specification, you need to create an image from the working
[]{#A.htm_marker-1278147}[]{#A.htm_marker-1278148}container.

### []{#A.htm_pgfId-1278150}A.2.6 Creating an image from a working container {#A.htm_heading_id_10 .fm-head1}

[]{#A.htm_pgfId-1278154}The
[]{#A.htm_marker-1278151}[]{#A.htm_marker-1278152}[]{#A.htm_marker-1278153}working
container you've been building so far can be used to create the
OCI-compliant image using the `buildah`{.fm-code-in-text}
`commit`{.fm-code-in-text} command[]{#A.htm_marker-1278155}. This
command works in the same way as the `podman`{.fm-code-in-text}
`commit`{.fm-code-in-text} command[]{#A.htm_marker-1278156} you learned
about in section 2.1.9. Inputs for this command are the working
container name and an optional image tag; if a tag is not specified, the
image will have no name:

``` programlisting
$ buildah commit ubi8-init-working-container quay.io/rhatdan/myimage2
Getting image source signatures
Copying blob 352ba846236b skipped: already exists 
Copying blob 3ba8c926eef9 skipped: already exists 
Copying blob 421971707f97 skipped: already exists 
Copying blob 9ff25f020d5a done 
Copying config 5e47dbd9b7 done 
Writing manifest to image destination
Storing signatures
5e47dbd9b7b7a43dd29f3e8a477cce355e42c019bb63626c0a8feffae56fcbf9
```

[]{#A.htm_pgfId-1278167}You can see the image using
`buildah`{.fm-code-in-text} `images`{.fm-code-in-text}:

``` programlisting
$ buildah images
REPOSITORY                         TAG       IMAGE ID         CREATED    SIZE
quay.io/rhatdan/myimage2        latest   5e47dbd9b7b7   2 minutes ago  293 MB
registry.access.redhat
➥ .com/ubi8-init               latest   4b85030f924b     5 weeks ago  253 MB
```

[]{#A.htm_pgfId-1278174}Because Podman and Buildah share the same
container image storage, you can see the same images with
`podman`{.fm-code-in-text} `images`{.fm-code-in-text}:

``` programlisting
$ podman images
REPOSITORY                         TAG        IMAGE ID        CREATED    SIZE
quay.io/rhatdan/myimage2        latest    5e47dbd9b7b7  4 minutes ago  293 MB
registry.access.redhat
➥ .com/ubi8-init               latest    4b85030f924b    5 weeks ago  253 MB
```

[]{#A.htm_pgfId-1278185}You can even run a Podman container on the
[]{#A.htm_marker-1278182}[]{#A.htm_marker-1278183}[]{#A.htm_marker-1278184}image:

``` programlisting
$ podman run quay.io/rhatdan/myimage2 grep dwalsh /etc/passwd
dwalsh:x:3267:3267:Daniel J Walsh:/home/dwalsh:/bin/bash
```

### []{#A.htm_pgfId-1278189}A.2.7 Pushing an image to a container registry {#A.htm_heading_id_11 .fm-head1}

[]{#A.htm_pgfId-1278195}Similarly
[]{#A.htm_marker-1278190}[]{#A.htm_marker-1278191}[]{#A.htm_marker-1278192}to
Podman, Buildah has the `buildah`{.fm-code-in-text}
`login`{.fm-code-in-text}[]{#A.htm_marker-1278193} and
`buildah`{.fm-code-in-text} `push`{.fm-code-in-text}
commands[]{#A.htm_marker-1278194}, which allow you to push images to
container registries, as shown in the following example:

``` programlisting
$ buildah login quay.io
Username: rhatdan
Password:
Login Succeeded!
$ buildah push quay.io/rhatdan/myimage2
Getting image source signatures
Copying blob 3ba8c926eef9 done 
Copying blob 421971707f97 done 
Copying blob 9ff25f020d5a done 
Copying blob 352ba846236b done 
Copying config 5e47dbd9b7 done 
Writing manifest to image destination
Copying config 5e47dbd9b7 done 
Writing manifest to image destination
Storing signatures
```

[]{#A.htm_pgfId-1278196}[Note]{.fm-callout-head} You can also use
`podman`{.fm-code-in-text1} `login`{.fm-code-in-text1} and
`podman`{.fm-code-in-text1} `push`{.fm-code-in-text1} or even
`skopeo`{.fm-code-in-text1} `login`{.fm-code-in-text1} and
`skopeo`{.fm-code-in-text1} `copy`{.fm-code-in-text1} to accomplish the
same task.

[]{#A.htm_pgfId-1278212}Congratulations! You have successfully built an
OCI-compliant container image manually by using simple shell commands
rather than using a Containerfile. Additionally, if you want to create
an image using an existing Containerfile or Dockerfile, you can use the
`buildah`{.fm-code-in-text} `build`{.fm-code-in-text}
[]{#A.htm_marker-1278213}[]{#A.htm_marker-1278214}[]{#A.htm_marker-1278215}command[]{#A.htm_marker-1278216}.

### []{#A.htm_pgfId-1278218}A.2.8 Building an image from Containerfiles {#A.htm_heading_id_12 .fm-head1}

[]{#A.htm_pgfId-1278223}You
[]{#A.htm_marker-1278219}[]{#A.htm_marker-1278220}[]{#A.htm_marker-1278221}can
use the `buildah`{.fm-code-in-text} `build`{.fm-code-in-text} command to
build an OCI-compliant image from a Containerfile or a Dockerfile.
Buildah includes a parser that understands the Containerfile format and
can perform all tasks using previously described commands automatically.
In the next example, use the Containerfile from section 2.3.2:

``` programlisting
$ cat myapp/Containerfile
FROM ubi8/httpd-24
COPY index.html /var/www/html/index.html
```

[]{#A.htm_pgfId-1278227}You can build your container image using this
Containerfile by executing the following command:

``` programlisting
$ buildah build ./myapp
STEP 1/2: FROM ubi8/httpd-24
Resolved "ubi8/httpd-24" as an alias (/home/dwalsh/.cache/containers/
➥ short-name-aliases.conf)
Trying to pull registry.access.redhat.com/ubi8/httpd-24:latest
...
Getting image source signatures
Checking if image destination supports signatures
Copying blob adffa6963146 skipped: already exists 
...
STEP 2/2: COPY html/index.html /var/www/html/index.html
COMMIT
Getting image source signatures
Copying blob 352ba846236b skipped: already exists 
...
bbfcf76c994c738f8496c1f274bd009ddbc960334b59a74953691fff00442417
```

[]{#A.htm_pgfId-1278244}You've probably noticed that this output matches
precisely the output of the `podman`{.fm-code-in-text}
`build`{.fm-code-in-text} command[]{#A.htm_marker-1278245}. This is
because the `podman`{.fm-code-in-text} `build`{.fm-code-in-text}
command[]{#A.htm_marker-1278246} uses
[]{#A.htm_marker-1278247}[]{#A.htm_marker-1278248}[]{#A.htm_marker-1278249}Buildah.

### []{#A.htm_pgfId-1278251}A.2.9 Buildah as a library {#A.htm_heading_id_13 .fm-head1}

[]{#A.htm_pgfId-1278254}Buildah
[]{#A.htm_marker-1278252}[]{#A.htm_marker-1278253}was designed to not
only be used as a command-line tool but also to be a Golang-based
library. Buildah is being used in a few different tools, such as Podman
and the OpenShift image builder. Buildah allows these tools to
internally build OCI images. Every time you do a
`podman`{.fm-code-in-text} `build`{.fm-code-in-text}, you are executing
the Buildah library code. Having learned how to build container images
using Buildah, copy images between container storages using Skopeo, and
manage and run containers on the host using Podman, let's talk about how
all these tools are used in the
[]{#A.htm_marker-1278255}[]{#A.htm_marker-1278256}Kubernetes
[]{#A.htm_marker-1278257}[]{#A.htm_marker-1278258}ecosystem.

## []{#A.htm_pgfId-1278260}A.3 CRI-O: Container Runtime Interface for OCI containers {#A.htm_heading_id_14 .fm-head}

[]{#A.htm_pgfId-1278263}When
[]{#A.htm_marker-1278261}[]{#A.htm_marker-1278262}Kubernetes was being
developed, it used the Docker API internally to run containers.
Kubernetes relied on features of Docker that changed from release to
release, sometimes breaking Kubernetes. At the same time, CoreOS wanted
their alternative container engine, called RKT
([https://github.com/rkt/rkt](https://github.com/rkt/rkt){.url}), to
work with Kubernetes. Kubernetes developers decided, then, to split out
the Docker functionality and use a new API called the Container Runtime
Interface (CRI; [http://mng.bz/yaDq](http://mng.bz/yaDq){.url}). This
interface allows Kubernetes to use other container engines in addition
to Docker.

[]{#A.htm_pgfId-1278264}When Kubernetes wants to pull a container image,
it calls out to a remote socket via the CRI and asks the listener to
pull an OCI image for it. When it wants to launch a Pod/Container, it
calls out to the socket and asks it to launch the container.

[]{#A.htm_pgfId-1278265}[Note]{.fm-callout-head} CoreOS was eventually
acquired by Red Hat, and the RKT project has ended. Kubernetes has
deprecated Docker as a container runtime.

[]{#A.htm_pgfId-1278266}Red Hat saw the CRI as an opportunity to develop
a new container engine, which they ended up calling the Container
Runtime Interface for OCI containers (CRI-O;
[https://cri-o.io/](https://cri-o.io/){.url}). CRI-O is based on the
same containers/storage and containers/image libraries as Skopeo,
Buildah, and Podman and can be used in conjunction with these tools.
CRI-O's primary objective is replacing the Docker service as the
container engine for Kubernetes.

::: figure
![](images/A-UN03.png){.calibre18}
:::

[]{#A.htm_pgfId-1278271}CRI-O is tied to Kubernetes releases. When a new
version of Kubernetes is released, the version numbers are synchronized.
CRI-O is optimized for Kubernetes workloads; the engineers working on it
understand what Kubernetes is trying to do and are making sure CRI-O
does it in the most efficient way possible. Since CRI-O has no other
users, Kubernetes doesn't have to worry about breaking changes
[]{#A.htm_marker-1278272}[]{#A.htm_marker-1278273}in
[]{#A.htm_marker-1278274}CRI-O.

[]{#A.htm_pgfId-1278275}[Note]{.fm-callout-head} CRI-O is the core
technology used with Red Hat's OpenShift Kubernetes-based product.
OpenShift uses Podman to install and configure CRI-O before Kubernetes
starts running. The OpenShift image builder embeds Buildah functionality
to allow users to build images within their OpenShift clusters.

[]{#B.htm}

# []{#B.htm_pgfId-1282813}[]{#B.htm_pgfId-1282814}Appendix B. OCI runtimes {#B.htm_heading_id_2 .tochead}

[]{#B.htm_pgfId-1282816}This appendix []{#B.htm_marker-1282815}describes
the primary OCI runtimes used with container engines like Podman. As
discussed in chapter 1, the OCI runtime
([https://opencontainers.org](https://opencontainers.org/){.url}) is the
executable launched by container engines, including Podman, used to
configure the Linux kernel and subsystems to run the kernel; its last
step is launching the container. The OCI runtime reads the OCI runtime
specification JSON file and then configures the namespaces, security
controls, and cgroups and eventually starts the container process
(figure B.1)[]{#B.htm_marker-1285375}.

::: figure
![](images/B-01.png){.calibre18}

Figure B.1 Podman executes the OCI runtime to launch the container.
:::

[]{#B.htm_pgfId-1282825}In this appendix, you'll learn the four main OCI
runtimes in use. The `--runtime`{.fm-code-in-text}
option[]{#B.htm_marker-1282824} allows you to switch between different
OCI runtimes. In the next example, you will run the same container
command twice, each time with a different runtime. In the first command,
you run the container with a runtime, `crun`{.fm-code-in-text}, defined
in the containers.conf, so you don't need to specify the path to the
runtime.

[]{#B.htm_pgfId-1282826}Listing B.1 Podman running with the alternate
OCI runtime `crun`{.fm-code-in-text}

``` programlisting
$ podman --runtime crun run --rm ubi8 echo hi     ❶
hi
```

[]{#B.htm_pgfId-1285577}[❶]{.fm-combinumeral} The \--runtime option
tells Podman to use the crun OCI runtime, rather than the default.

[]{#B.htm_pgfId-1282830}The default runtime is defined under the
`[containers]`{.fm-code-in-text} table in the containers.conf file on
the Linux machine.

[]{#B.htm_pgfId-1282831}Listing B.2 Modifying the default OCI runtime

``` programlisting
$ grep -iA 3 "Default OCI Runtime" /usr/share/containers/containers.conf
# Default OCI runtime
#
#runtime = "crun"      ❶
```

[]{#B.htm_pgfId-1285510}[❶]{.fm-combinumeral} Podman defaults to crun on
most systems; on some older distributions, like Red Hat Enterprise
Linux, Podman defaults to runc.

[]{#B.htm_pgfId-1282839}In the second example, you use the full path of
the OCI runtime, /usr/bin/runc:

``` programlisting
$ podman --runtime /usr/bin/runc run –rm ubi8 echo hi
hi
```

[]{#B.htm_pgfId-1282842}If you want to permanently change the default
OCI runtime, you can set the runtime option in the
`[engine]`{.fm-code-in-text} table in the containers.conf file in your
home directory:

``` programlisting
$ cat > ~/.config/containers/containers.conf << EOF
[engine]
runtime="runc"
EOF
$ podman --help | grep -- runc
   --runtime string Path to the OCI-compatible binary used to run containers. (default "runc")`
```

[]{#B.htm_pgfId-1282850}[Note]{.fm-callout-head} The
`--runtime`{.fm-code-in-text1} option[]{#B.htm_marker-1282849} is only
available on Linux. `podman`{.fm-code-in-text1}
`--remote`{.fm-code-in-text1}, and therefore Podman, on Mac and Windows,
does not support the `--runtime`{.fm-code-in-text1} option, so you need
to set the containers.conf file on the server side.

[]{#B.htm_pgfId-1282851}See the `podman(1)`{.fm-code-in-text} man page
for more information: `man`{.fm-code-in-text}
`podman.`{.fm-code-in-text}

[]{#B.htm_pgfId-1282852}OCI runtimes are continuously being developed
and experimented with. You can expect innovation to happen in this space
going forward. The first container runtime developed, and the de facto
standard, is `runc`{.fm-code-in-text}.

## []{#B.htm_pgfId-1282853}B.1 runc {#B.htm_heading_id_3 .fm-head}

[]{#B.htm_pgfId-1282857}`runc`{.fm-code-in-text}
[]{#B.htm_marker-1282854}[]{#B.htm_marker-1282855}is the original OCI
runtime
([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc){.url}).
When the OCI originally formed, Docker donated `runc`{.fm-code-in-text}
to the OCI to serve as the default implementation of an OCI runtime. The
OCI continues to support and develop `runc`{.fm-code-in-text}. It is
written in Golang and also includes the libcontainer library, which is
used in many container engines and Kubernetes.

[]{#B.htm_pgfId-1282859}The `runc`{.fm-code-in-text} website states that
`runc`{.fm-code-in-text}, and all of the OCI runtimes, is a low-level
tool not designed to be used directly by the end user. It is recommended
to be launched by container engines like Podman or Docker.

[]{#B.htm_pgfId-1282860}Recall that the container engine's job is
pulling the container images to the host, configuring and mounting the
root filesystem (rootfs[]{#B.htm_marker-1282861}) to be used within the
container, and, finally, writing the OCI runtime JSON file before
launching the OCI runtime.

[]{#B.htm_pgfId-1282862}The OCI runtime specification describes only the
content of the JSON file used by OCI runtimes. Because every OCI engine
supports the `runc`{.fm-code-in-text} command line, the other OCI
runtimes adopted the same CLI commands and options. This makes it easier
for one runtime to replace another when launched by the container
engine. Table B.1 shows the commands supported by
`runc`{.fm-code-in-text} and therefore all OCI runtimes.

[]{#B.htm_marker-1282957}[]{#B.htm_pgfId-1284151}Table B.1
`runc`{.fm-code-in-text} commands

+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284155}Command                                                  | []{#B.htm_pgfId-1284157}Description                 |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284159}`checkpoint`{.fm-code-in-text1}[]{#B.htm_marker-1284222} | []{#B.htm_pgfId-1284161}Checkpoints a running       |
|                                                                                  | container                                           |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284163}`create`{.fm-code-in-text1}[]{#B.htm_marker-1284223}     | []{#B.htm_pgfId-1284165}Creates a container         |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284167}`delete`{.fm-code-in-text1}[]{#B.htm_marker-1284224}     | []{#B.htm_pgfId-1284169}Deletes any resources held  |
|                                                                                  | by the container often used with detached           |
|                                                                                  | containers                                          |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284171}`events`{.fm-code-in-text1}[]{#B.htm_marker-1284225}     | []{#B.htm_pgfId-1284173}Displays container events,  |
|                                                                                  | such as OOM notifications, CPU, memory, and IO      |
|                                                                                  | usage statistics                                    |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284175}`init`{.fm-code-in-text1}[]{#B.htm_marker-1284226}       | []{#B.htm_pgfId-1284177}Initializes the namespaces  |
|                                                                                  | and launches the process                            |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284179}`kill`{.fm-code-in-text1}[]{#B.htm_marker-1284227}       | []{#B.htm_pgfId-1284181}Sends the specified signal  |
|                                                                                  | (default: `SIGTERM`{.fm-code-in-text1}) to the      |
|                                                                                  | container's init process                            |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284183}`List`{.fm-code-in-text1}[]{#B.htm_marker-1284228}       | []{#B.htm_pgfId-1284185}Lists containers started by |
|                                                                                  | runc with the given root                            |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284187}`pause`{.fm-code-in-text1}[]{#B.htm_marker-1284229}      | []{#B.htm_pgfId-1284189}Suspends all processes      |
|                                                                                  | inside the container                                |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284191}`ps`{.fm-code-in-text1}[]{#B.htm_marker-1284230}         | []{#B.htm_pgfId-1284193}Displays the processes      |
|                                                                                  | running inside a container                          |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284195}`restore`{.fm-code-in-text1}[]{#B.htm_marker-1284231}    | []{#B.htm_pgfId-1284197}Restores a container from a |
|                                                                                  | previous checkpoint                                 |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284199}`resume`{.fm-code-in-text1}[]{#B.htm_marker-1284232}     | []{#B.htm_pgfId-1284201}Resumes all processes that  |
|                                                                                  | have been previously paused                         |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284203}`run`{.fm-code-in-text1}[]{#B.htm_marker-1284233}        | []{#B.htm_pgfId-1284205}Creates and runs a          |
|                                                                                  | container                                           |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284207}`spec`{.fm-code-in-text1}[]{#B.htm_marker-1284234}       | []{#B.htm_pgfId-1284209}Creates a new specification |
|                                                                                  | file                                                |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284211}`start`{.fm-code-in-text1}[]{#B.htm_marker-1284235}      | []{#B.htm_pgfId-1284213}Executes the user-defined   |
|                                                                                  | process in a created container                      |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284215}`state`{.fm-code-in-text1}[]{#B.htm_marker-1284236}      | []{#B.htm_pgfId-1284217}Outputs the state of a      |
|                                                                                  | container                                           |
+----------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#B.htm_pgfId-1284219}`update`{.fm-code-in-text1}[]{#B.htm_marker-1284237}     | []{#B.htm_pgfId-1284221}Updates container resource  |
|                                                                                  | constraints                                         |
+----------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#B.htm_pgfId-1282951}`runc`{.fm-code-in-text} continues to be
developed and has a very active community. The problem with
`runc`{.fm-code-in-text} is that it is written in Golang. Golang was not
designed to be a small, often-executed application that needs to start
quickly and fork/exec a command and exit quickly. Fork/exec is a heavy
operation in Golang, and although `runc`{.fm-code-in-text} attempts to
work around this, it ultimately sacrifices a bit of performance. The *a
bit* can accumulate over time though, so `crun`{.fm-code-in-text}
performs much better at
[]{#B.htm_marker-1285720}[]{#B.htm_marker-1285721}scale.

## []{#B.htm_pgfId-1282955}B.2 crun {#B.htm_heading_id_4 .fm-head}

[]{#B.htm_pgfId-1282958}`runc`{.fm-code-in-text},
[]{#B.htm_marker-1285723}[]{#B.htm_marker-1285724}being written in
Golang, is a very heavy executable---12 megabytes in size. Golang is a
great language, but it doesn't take advantage of shared libraries.
Golang executables take up considerably more memory because of this. The
size of `runc`{.fm-code-in-text} causes it to be somewhat slower loading
during container start. Another problem with Golang is that it does not
support the fork/exec model all that well; it is slower than fork/exec
in other languages (e.g., C). This lack of speed is more important when
you are starting and stopping hundreds or thousands of containers---for
example, on a Kubernetes cluster. Container engines like Podman, also
written in Go, generally run for a much longer time, so the startup time
is not as important. OCI runtimes like `runc`{.fm-code-in-text} execute
for a very short time and exit quickly.

[]{#B.htm_pgfId-1282959}Giuseppe Scrivano, a contributor to
`runc`{.fm-code-in-text} and Podman, understood these deficiencies in
`runc`{.fm-code-in-text} and wanted to write a compatible OCI runtime in
the C language. He created a very lightweight OCI runtime called
`crun`{.fm-code-in-text}.

[]{#B.htm_pgfId-1282960}`crun`{.fm-code-in-text} describes itself as "*a
fast and lightweight OCI runtime.*"
([https://github.com/containers/crun](https://github.com/containers/crun){.url})
It supports all of the same commands and options as
`runc`{.fm-code-in-text}, and the `crun`{.fm-code-in-text} executable is
many times smaller than `runc`{.fm-code-in-text}. Execute the
`du`{.fm-code-in-text} `-s`{.fm-code-in-text}
command[]{#B.htm_marker-1284956} to compare sizes:

``` programlisting
$ du -s /usr/bin/runc /usr/bin/crun
14640    /usr/bin/runc
392    /usr/bin/crun
```

[]{#B.htm_pgfId-1282965}`crun`{.fm-code-in-text}, being written in C,
supports fork and exec much better than `Golang`{.fm-code-in-text} and,
therefore, is much quicker when launching a container.

[]{#B.htm_pgfId-1282966}This also makes it plug in easily to other
libraries on the system, and there is some experimentation on using
`crun`{.fm-code-in-text} as a library for processing the OCI runtime
JSON file and launching different types of containers (e.g., WASM and
Windows containers on Linux). `crun`{.fm-code-in-text} also has
potential for launching KVM-separated containers based on libkrun.

[]{#B.htm_pgfId-1282967}`crun`{.fm-code-in-text} is now the default OCI
runtime used by Podman in Fedora and in Red Hat Enterprise Linux 9.
`runc`{.fm-code-in-text} continues to be supported and is the default
OCI runtime in Red Hat Enterprise Linux 8.

[]{#B.htm_pgfId-1282969}`crun`{.fm-code-in-text} and
`runc`{.fm-code-in-text} are the two primary OCI runtimes for managing
traditional containers that use namespace separation. Both these
projects work fairly closely together. When bugs or problems are found
in either OCI runtime, they are quickly fixed in both. See the
`crun(1)`{.fm-code-in-text} man page for more information:
[]{#B.htm_marker-1282970}[]{#B.htm_marker-1282971}`man`{.fm-code-in-text}
`crun`{.fm-code-in-text}.

## []{#B.htm_pgfId-1282973}B.3 Kata {#B.htm_heading_id_5 .fm-head}

::: figure
![](images/B-01-UN01.png){.calibre18}
:::

[]{#B.htm_pgfId-1282980}OCI
[]{#B.htm_marker-1283889}[]{#B.htm_marker-1283890}runtimes are also
written to use VM separation, with the primary example of this being
Kata Containers. The Kata Container project
([https://katacontainers.io](https://katacontainers.io){.url})
advertises itself as the following: "*The speed of containers, the
security of VMs. Kata Containers is an open source container runtime,
building lightweight virtual machines that seamlessly plug into the
container's ecosystem."*

::: figure
![](images/B-02.png){.calibre18}

Figure B.2 Kata containers launches a lightweight VM, which only runs
the container.
:::

[]{#B.htm_pgfId-1282987}Kata containers use VM technology for launching
each container, which is very different from launching a VM and running
Podman within it. A standard VM has an init system, which launches all
sorts of services, like logging systems, cron, and more. On the other
hand, a Kata container launches a micro OS, which runs only the
container and its support services (figure B.2). As its only purpose is
launching the container, when the container exits, this VM goes away.

[]{#B.htm_pgfId-1282988}I believe running containers within
VM/hypervisor separation gives you better security separation than
traditional container separation, where containers communicate directly
with the host kernel. A VM-separated container has to first break out of
containment inside of the VM, then find a way to break out of the
hypervisor---only then to face attacking the host kernel.

[]{#B.htm_pgfId-1282989}While VM-separated containers are more secure,
this does come with some downsides. There is a decent amount of overhead
in starting a Kata container, configuring the hypervisor, launching the
kernel and other processes within the VM, and then finally the
container. The VM's memory, CPU, and so on have to be preallocated and
are difficult to change. Running Kata within a VM in the cloud is often
not allowed, or is at least more expensive, because most of the cloud
vendors frown on nested virtualization.

[]{#B.htm_pgfId-1282990}Finally, and most importantly, VM-separated
containers by their very nature have difficulties sharing content with
other containers and the host operating system. The biggest problem is
with volumes.

[]{#B.htm_pgfId-1282991}While sharing content with the host machine in
traditional containers is just a bind mount, in VM-separate containers,
bind mounts do not work. Since the processes on the host and in the
container are running with two different kernels, you need a network
protocol to share content. Kata containers originally used NFS and Plan
9 networked filesystems. Reading/writing data over these networked
filesystems is considerably slower than native filesystem reads and
writes you get with a bind mount.

[]{#B.htm_pgfId-1282992}Virtiofs is a new filesystem that has the
properties of a network filesystem but allows VMs to access files on the
host. It is able to show major improvements in speed over the
network-based filesystems, while still remaining under heavy
development.

[]{#B.htm_pgfId-1282993}Kata containers have two ways to be launched.
Kata traditionally has an OCI command line,
`kata-runtime`{.fm-code-in-text}, based on the `runc`{.fm-code-in-text}
command[]{#B.htm_marker-1282994} supported by Podman. You can see the
paths defined in containers.conf, on the Linux machine, by searching for
`#kata`{.fm-code-in-text}:

``` programlisting
$ grep -A 9 '^#kata' /usr/share/containers/containers.conf
#kata = [
#  "/usr/bin/kata-runtime",
#  "/usr/sbin/kata-runtime",
#  "/usr/local/bin/kata-runtime",
#  "/usr/local/sbin/kata-runtime",
#  "/sbin/kata-runtime",
#  "/bin/kata-runtime",
#  "/usr/bin/kata-qemu",
#  "/usr/bin/kata-fc",
#]
```

[]{#B.htm_pgfId-1283006}The bottom line on Kata containers is that you
get better security with a performance overhead. You can choose between
these OCI runtimes with your workload's needs in
[]{#B.htm_marker-1283007}[]{#B.htm_marker-1283008}mind.

## []{#B.htm_pgfId-1283010}B.4 gVisor {#B.htm_heading_id_6 .fm-head}

::: figure
![](images/B-02-UN02.png){.calibre18}
:::

[]{#B.htm_pgfId-1283017}The
[]{#B.htm_marker-1283015}[]{#B.htm_marker-1283016}last OCI runtime I
cover in this appendix is gVisor
([https://gvisor.dev/](https://gvisor.dev/){.url}). The gVisor website
advertises itself as "an application kernel for containers that provides
efficient defense-in-depth anywhere."

[]{#B.htm_pgfId-1283019}gVisor includes an OCI runtime called
`runsc`{.fm-code-in-text}[]{#B.htm_marker-1283018} and works with Podman
and other container engines. The gVisor project calls itself an
application kernel, written in Golang, that implements a substantial
portion of the Linux system call interface. It provides an additional
layer of isolation between running applications and the host operating
system. Google engineering wrote the original versions of gVisor and
claims that the bulk of the containers Google Cloud run use the gVisor
OCI runtime.

[]{#B.htm_pgfId-1283020}gVisor is somewhat similar to VM-isolated
containers in that gVisor intercepts almost all system calls from within
the container and then processes them. gVisor describes itself as an
application kernel for containers written in Golang, limiting the access
to the host kernel. At the same time, it does not have the same problem
of a nested virtualization as Kata.

[]{#B.htm_pgfId-1283021}However, gVisor introduces a performance penalty
with additional CPU cycles and higher memory usage. This may introduce
increased latency, reduced throughput, or both. gVisor is also an
independent implementation of the system call surface, meaning many of
the subsystems or specific calls are not as optimized as more
[]{#B.htm_marker-1283022}[]{#B.htm_marker-1283023}mature
[]{#B.htm_marker-1283024}implementations[]{#B.htm_marker-1285384}.

[]{#C.htm}

# []{#C.htm_pgfId-1284760}[]{#C.htm_id_2bf80mf11foj}[]{#C.htm_pgfId-1284762}Appendix C. Getting Podman {#C.htm_heading_id_2 .tochead}

[]{#C.htm_pgfId-1284764}Podman is []{#C.htm_marker-1284763}a great tool
for working with containers, but how do you get it installed on your
system? What packages are required to make it work? This appendix covers
installing or building Podman on your system.

## []{#C.htm_pgfId-1284766}C.1 Installing Podman {#C.htm_heading_id_3 .fm-head}

[]{#C.htm_pgfId-1284769}Podman
[]{#C.htm_marker-1285884}[]{#C.htm_marker-1285885}is available for
almost all Linux distributions via their package managers. It is also
available on Mac, Windows, and FreeBSD platforms. The official podman.io
site,
[https://podman.io/getting-started/installation](https://podman.io/getting-started/installation){.url},
is regularly updated with new instructions on how to install Podman for
different distributions. Most of the content in this appendix originates
from the podman.io site, as seen in figure C.1.

::: figure
![](images/C-01.png){.calibre18}

Figure C.1 Podman installation instructions website
:::

### []{#C.htm_pgfId-1284778}C.1.1 macOS {#C.htm_heading_id_4 .fm-head1}

[]{#C.htm_pgfId-1284782}Because
[]{#C.htm_marker-1284779}[]{#C.htm_marker-1284780}[]{#C.htm_marker-1284781}Podman
is a tool for running Linux containers, you can use it on a macOS
desktop only if you have access to a Linux box, running either locally
or remotely. To make this process somewhat easier, Podman includes a
command, `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}, to
automatically manage VMs.

[]{#C.htm_pgfId-1284784}Homebrew

[]{#C.htm_pgfId-1284788}The
[]{#C.htm_marker-1284785}[]{#C.htm_marker-1284786}Mac client is
available through Homebrew ([https://brew.sh/](https://brew.sh/){.url}):

``` programlisting
$ brew install podman
```

[]{#C.htm_pgfId-1284790}Podman has the ability to install a VM and run a
Linux instance on your machine using the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} command. On a Mac, you must execute the
following commands to install and start the Linux VM to successfully run
containers locally:

``` programlisting
$ podman machine init
$ podman machine start
```

[]{#C.htm_pgfId-1284794}Optionally, you can use the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} command[]{#C.htm_marker-1284793} to set
up SSH connections to remote Linux machines running the Podman service.

[]{#C.htm_pgfId-1284795}You can then verify the installation information
using

``` programlisting
$ podman info
```

[]{#C.htm_pgfId-1284797}The Podman command is running natively on the
Mac but communicating with an instance of Podman running within
[]{#C.htm_marker-1284798}[]{#C.htm_marker-1284799}the
[]{#C.htm_marker-1284800}[]{#C.htm_marker-1284801}[]{#C.htm_marker-1284802}VM.

### []{#C.htm_pgfId-1284804}C.1.2 Windows {#C.htm_heading_id_5 .fm-head1}

[]{#C.htm_pgfId-1284808}Because
[]{#C.htm_marker-1284805}[]{#C.htm_marker-1284806}[]{#C.htm_marker-1284807}Podman
is a tool for running Linux containers, you can use it on a Windows
desktop only if you have access to a Linux box, running either locally
or remotely. On Windows, Podman can also utilize the Windows Subsystem
for Linux system.

[]{#C.htm_pgfId-1284810}Windows Remote client

[]{#C.htm_pgfId-1284814}You
[]{#C.htm_marker-1286526}[]{#C.htm_marker-1286527}can retrieve the
latest Windows Remote client on the
[https://github.com/containers/podman/releases](https://github.com/containers/podman/releases){.url}
site.

[]{#C.htm_pgfId-1284815}Once installed, you can configure the Windows
Remote client to connect to a Linux server using the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} command[]{#C.htm_marker-1286531}. You can
find out more about this process at
[]{#C.htm_marker-1286532}[]{#C.htm_marker-1286533}[http://mng.bz/M0Kn](http://mng.bz/M0Kn){.url}.

[]{#C.htm_pgfId-1284821}Windows Subsystem for Linux (WSL) 2.0

[]{#C.htm_pgfId-1284824}See
[]{#C.htm_marker-1284822}[]{#C.htm_marker-1284823}Windows documentation
on installing WSL 2.0, and then pick a distribution that includes
Podman, including many described below. Alternatively, the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#C.htm_marker-1284825} can bootstrap
it all for you by automatically installing and configuring WSL,
downloading and provisioning Fedora Core VM on it, and creating
corresponding SSH connections for the Podman
[]{#C.htm_marker-1284826}[]{#C.htm_marker-1284827}remote
[]{#C.htm_marker-1284828}[]{#C.htm_marker-1284829}[]{#C.htm_marker-1284830}client.

[]{#C.htm_pgfId-1284831}[Note]{.fm-callout-head} WSL 1.0 is not
supported.

### []{#C.htm_pgfId-1284833}C.1.3 Arch Linux and Manjaro Linux {#C.htm_heading_id_6 .fm-head1}

[]{#C.htm_pgfId-1284843}Arch
[]{#C.htm_marker-1284834}[]{#C.htm_marker-1284835}[]{#C.htm_marker-1284836}[]{#C.htm_marker-1284837}Linux
and Manjaro Linux use the `pacman`{.fm-code-in-text}
tool[]{#C.htm_marker-1284838} to install
[]{#C.htm_marker-1284839}[]{#C.htm_marker-1284840}[]{#C.htm_marker-1284841}[]{#C.htm_marker-1284842}software:

``` programlisting
$ sudo pacman -S podman
```

### []{#C.htm_pgfId-1284846}C.1.4 CentOS {#C.htm_heading_id_7 .fm-head1}

[]{#C.htm_pgfId-1284850}Podman
[]{#C.htm_marker-1284847}[]{#C.htm_marker-1284848}[]{#C.htm_marker-1284849}is
available in the default Extras repos for CentOS 7 and in the AppStream
repo for CentOS 8 and
[]{#C.htm_marker-1284851}[]{#C.htm_marker-1284852}[]{#C.htm_marker-1284853}Stream:

``` programlisting
$ sudo yum -y install podman
```

### []{#C.htm_pgfId-1284856}C.1.5 Debian {#C.htm_heading_id_8 .fm-head1}

[]{#C.htm_pgfId-1284864}The
[]{#C.htm_marker-1284857}[]{#C.htm_marker-1284858}[]{#C.htm_marker-1284859}`podman`{.fm-code-in-text}
package[]{#C.htm_marker-1284860} is available in the Debian 11
(bullseye) repositories and
[]{#C.htm_marker-1284861}[]{#C.htm_marker-1284862}[]{#C.htm_marker-1284863}later:

``` programlisting
$ sudo apt-get -y install podman
```

### []{#C.htm_pgfId-1284867}C.1.6 Fedora {#C.htm_heading_id_9 .fm-head1}

``` programlisting
$ sudo dnf -y install podman
```

### []{#C.htm_pgfId-1284876}C.1.7 Fedora-CoreOS, Fedora Silverblue {#C.htm_heading_id_10 .fm-head1}

[]{#C.htm_pgfId-1284885}Podman
[]{#C.htm_marker-1284877}[]{#C.htm_marker-1284878}[]{#C.htm_marker-1284879}[]{#C.htm_marker-1284880}comes
preinstalled on these distributions. There is no need to need to install
[]{#C.htm_marker-1284881}[]{#C.htm_marker-1284882}[]{#C.htm_marker-1284883}[]{#C.htm_marker-1284884}it.

### []{#C.htm_pgfId-1284887}C.1.8 Gentoo {#C.htm_heading_id_11 .fm-head1}

``` programlisting
$ sudo emerge app-emulation/podman
```

### []{#C.htm_pgfId-1284896}C.1.9 OpenEmbedded {#C.htm_heading_id_12 .fm-head1}

[]{#C.htm_pgfId-1284900}BitBake
[]{#C.htm_marker-1284897}[]{#C.htm_marker-1284898}[]{#C.htm_marker-1284899}recipes
for Podman and its dependencies are available in the meta-virtualization
layer ([http://mng.bz/aPzB](http://mng.bz/aPzB){.url}). Add the layer to
your OpenEmbedded build environment, and build Podman
[]{#C.htm_marker-1284902}[]{#C.htm_marker-1284903}[]{#C.htm_marker-1284904}using

``` programlisting
$ bitbake podman
```

### []{#C.htm_pgfId-1284907}C.1.10 openSUSE {#C.htm_heading_id_13 .fm-head1}

``` programlisting
sudo zypper install podman
```

### []{#C.htm_pgfId-1284916}C.1.11 openSUSE Kubic {#C.htm_heading_id_14 .fm-head1}

[]{#C.htm_pgfId-1284920}The
[]{#C.htm_marker-1284917}[]{#C.htm_marker-1284918}[]{#C.htm_marker-1284919}openSUSE
Kubic distribution has Podman built in. There is no need to need to
install
[]{#C.htm_marker-1284921}[]{#C.htm_marker-1284922}[]{#C.htm_marker-1284923}it.

### []{#C.htm_pgfId-1284925}C.1.12 Raspberry Pi OS arm64 {#C.htm_heading_id_15 .fm-head1}

[]{#C.htm_pgfId-1284929}The
[]{#C.htm_marker-1284926}[]{#C.htm_marker-1284927}[]{#C.htm_marker-1284928}Raspberry
Pi OS uses the standard Debian repositories, so it is fully compatible
with Debian's arm64
[]{#C.htm_marker-1284930}[]{#C.htm_marker-1284931}[]{#C.htm_marker-1284932}repository:

``` programlisting
$ sudo apt-get -y install podman
```

### []{#C.htm_pgfId-1284935}C.1.13 Red Hat Enterprise Linux {#C.htm_heading_id_16 .fm-head1}

[]{#C.htm_pgfId-1284937}RHEL7

[]{#C.htm_pgfId-1284945}Make
[]{#C.htm_marker-1284938}[]{#C.htm_marker-1284939}[]{#C.htm_marker-1284940}sure
[]{#C.htm_marker-1284941}[]{#C.htm_marker-1284942}you have a RHEL7
subscription, then enable the extras channel and install
[]{#C.htm_marker-1284943}[]{#C.htm_marker-1284944}Podman:

``` programlisting
$ sudo subscription-manager repos --enable=rhel-7-server-extras-rpms
$ sudo yum -y install podman
```

[]{#C.htm_pgfId-1284948}[Note]{.fm-callout-head} RHEL7 is no longer
receiving updates to the Podman package except for security fixes.

[]{#C.htm_pgfId-1284950}RHEL8

[]{#C.htm_pgfId-1284956}Podman
[]{#C.htm_marker-1284951}[]{#C.htm_marker-1284952}is included in the
`container-tools`{.fm-code-in-text} module[]{#C.htm_marker-1284953}
along with Buildah and
[]{#C.htm_marker-1284954}[]{#C.htm_marker-1284955}Skopeo:

``` programlisting
$ sudo yum module enable -y container-tools:rhel8
$ sudo yum module install -y container-tools:rhel8
```

[]{#C.htm_pgfId-1284960}RHEL9 (and beyond)

``` programlisting
$ sudo yum install podman
```

### []{#C.htm_pgfId-1284970}C.1.14 Ubuntu {#C.htm_heading_id_17 .fm-head1}

[]{#C.htm_pgfId-1284980}The
[]{#C.htm_marker-1284971}[]{#C.htm_marker-1284972}[]{#C.htm_marker-1284973}`podman`{.fm-code-in-text}
package[]{#C.htm_marker-1284974} is available in the official
repositories for Ubuntu 20.10
[]{#C.htm_marker-1284975}[]{#C.htm_marker-1284976}[]{#C.htm_marker-1284977}and
[]{#C.htm_marker-1284978}[]{#C.htm_marker-1284979}newer:

``` programlisting
$ sudo apt-get -y update
$ sudo apt-get -y install podman
```

## []{#C.htm_pgfId-1284984}C.2 Building from source code {#C.htm_heading_id_18 .fm-head}

[]{#C.htm_pgfId-1284987}I
[]{#C.htm_marker-1284985}[]{#C.htm_marker-1284986}usually advise people
to get the packaged versions of Podman because successfully running
Podman on Linux requires having additional tools installed, such as
conmon (container monitor[]{#C.htm_marker-1284988}),
`containernetworking-plugins`{.fm-code-in-text} (network
configuration[]{#C.htm_marker-1284989}), and
`containers-common`{.fm-code-in-text} (general
configuration[]{#C.htm_marker-1284990}). While the process of building
Podman from the source code is not very complicated, the list of
dependencies differs from one Linux distribution to another. You can
always check the latest instructions on the following Podman page:
[]{#C.htm_marker-1284991}[]{#C.htm_marker-1284992}[http://mng.bz/gRDE](http://mng.bz/gRDE){.url}.

## []{#C.htm_pgfId-1284995}C.3 Podman Desktop {#C.htm_heading_id_19 .fm-head}

[]{#C.htm_pgfId-1284998}There
[]{#C.htm_marker-1284996}[]{#C.htm_marker-1284997}is also a GUI, Podman
Desktop, for browsing, managing, and inspecting containers and images
from different container engines, available at
[https://github.com/containers/podman-desktop](https://github.com/containers/podman-desktop){.url}.
Podman Desktop offers the capability to connect to multiple engines at
the same time and provides a unified interface. This is a relatively new
project under heavy development, so expect some rough edges.

[]{#C.htm_pgfId-1285000}To provide some background, in September 2021,
Docker Inc. announced they will begin charging for the previously free
version of Docker Desktop on macOS. The Docker announcement has caused
many people to switch and look for a
[]{#C.htm_marker-1285001}[]{#C.htm_marker-1285002}replacement.

## []{#C.htm_pgfId-1285004}Summary {#C.htm_heading_id_20 .fm-head}

- []{#C.htm_pgfId-1285005 .calibre17}Podman is a tool for running Linux
  containers, so it runs only on Linux.

- []{#C.htm_pgfId-1285006 .calibre17}Podman is available in default
  package repositories of most major Linux distributions.

- []{#C.htm_pgfId-1285007 .calibre17}Podman is available as a remote
  client on Mac and Windows, which connects to either a local or remote
  Linux box.

- []{#C.htm_pgfId-1285008 .calibre17}Podman provides a special command
  for Linux VM management on macOS and Windows.

- []{#C.htm_pgfId-1285009 .calibre17}Podman can be built from source
  code, but it requires many other tools to run successfully.

- []{#C.htm_pgfId-1285011 .calibre17}Podman Desktop is an alternative
  for the popular Docker []{#C.htm_marker-1285010 .calibre17}Desktop.

[]{#D.htm}

# []{#D.htm_pgfId-1286421}[]{#D.htm_pgfId-1286422}Appendix D. Contributing to Podman {#D.htm_heading_id_2 .tochead}

[]{#D.htm_pgfId-1286424}My favorite []{#D.htm_marker-1286423}thing about
open source is the community effort. It is great to be able to
contribute to a project and, better yet, get people to contribute to
your project. The analogy I like to use comes from the *Grimms' Fairy
Tales* story "The Elves"
([https://sites.pitt.edu/\~dash/grimm039.html](https://sites.pitt.edu/~dash/grimm039.html){.url}):

[]{#D.htm_pgfId-1286426 .calibre17}A shoemaker, through no fault of his
own, had become so poor that he had only leather enough for a single
pair of shoes. He cut them out one evening, then went to bed, intending
to finish them the next morning. Having a clear conscience, he went to
bed peacefully, commended himself to God, and fell asleep. The next
morning, after saying his prayers, he was about to return to his work
when he found the shoes on his workbench, completely finished.

[]{#D.htm_pgfId-1286427}The story goes on to describe a couple of elves
that come by each night and finish the shoes. I see this as the way open
source works. Basically, the people doing little contributions, bug
reporting, bug fixes, document fixes, feature requests, and publicizing
the project are all the elves. Sometimes I even go to bed, and when I
wake up I'll find someone has fixed the problem I was attempting to deal
with the night before! And sometimes the elves grow up to be
maintainers. Some small contributions over time grow, and these
developers end up being core members of the Podman team. Some we even
hired.

## []{#D.htm_pgfId-1286429}D.1 Joining the community {#D.htm_heading_id_3 .fm-head}

[]{#D.htm_pgfId-1286432}Each
[]{#D.htm_marker-1286430}[]{#D.htm_marker-1286431}small change helps
make the project better. When I talk to college students about open
source, I tell them about the unique opportunities they have, which were
not around when I was a student. They can make a contribution to a
software project or product and then list it on their resume. When
interviewing a student for an internship or a job, having a few
github.com contributions on a resume is very impressive.

[]{#D.htm_pgfId-1286433}Podman and its underlying technologies are
always looking for new contributions (figure D.1). No contribution is
too small---from a spelling mistake in a man page up to a full-blown
feature. You don't have to be a software developer to contribute. We are
always looking for help on documentation, web design for podman.io, as
well as software help. Many great ideas come from users of the product.
Just reporting a bug or reporting what you don't like can lead to fresh
ideas that improve the project. I often ask people who have set up
complicated environments using Podman to blog about it, so others can
learn.

::: figure
![](images/D-01.png){.calibre18}

Figure D.1 Podman\'s Community page
([https://podman.io/community](https://podman.io/community){.url})
:::

[]{#D.htm_pgfId-1286442}Podman is an inclusive community, as are all of
the github.com/containers projects[]{#D.htm_marker-1286443}. The code of
conduct statement for the containers project at
[http://mng.bz/5mEB](http://mng.bz/5mEB){.url} states the
[]{#D.htm_marker-1286445}[]{#D.htm_marker-1286446}following:

[]{#D.htm_pgfId-1286447 .calibre17}*As contributors and maintainers of
the projects under the*
[https://github.com/containers](https://github.com/containers){.url1}
*repository, and in the interest of fostering an open and welcoming
community, we pledge to respect all people who contribute through
reporting problems, posting feature requests, updating documentation,
submitting pull requests or patches, and other activities to any of the
projects under the containers umbrella.*

## []{#D.htm_pgfId-1286449}D.2 Podman on github.com {#D.htm_heading_id_4 .fm-head}

[]{#D.htm_pgfId-1286453}Issues,
[]{#D.htm_marker-1286450}[]{#D.htm_marker-1286451}discussions, and pull
requests reside on the
[github.com/containers/podman](http://github.com/containers/podman){.url}
repository (figure D.2)[]{#D.htm_marker-1286454}. As of this writing,
the project has over 1,200 forks and 12,000 stars. The bottom line is it
is a very active project.

::: figure
![](images/D-02.png){.calibre18}

Figure D.2 Podman\'s github page
([github.com/containers/podman](https://github.com/containers/podman){.url})
:::

[]{#D.htm_pgfId-1286461}You can also communicate directly with the core
maintainers on IRC on the #podman channel on libera.chat. The IRC
channel is also linked to #podman:matrix.org
([https://matrix.to/#/#podman:matrix.org]{.url}) on Matrix and the
Podman Discord
([https://discord.com/invite/x5GzFF6QH4](https://discord.com/invite/x5GzFF6QH4){.url})
for web access.

[]{#D.htm_pgfId-1286467}There is also a low-volume mailing list you can
join by sending an email to podman-join@lists.podman.io. Finally, you
can follow \@podman_io on Twitter or follow
[]{#D.htm_marker-1286468}[]{#D.htm_marker-1286469}me
[]{#D.htm_marker-1286470}\@rhatdan.

[]{#E.htm}

# []{#E.htm_pgfId-1286422}[]{#E.htm_id_sira8yl9f04n}[]{#E.htm_pgfId-1286423}Appendix E. Podman on macOS {#E.htm_heading_id_2 .tochead}

[]{#E.htm_pgfId-1286425}This appendix []{#E.htm_marker-1288008}covers

- []{#E.htm_pgfId-1286426 .calibre17}Installing Podman on macOS
- []{#E.htm_pgfId-1286428 .calibre17}Using the
  `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
  `init`{.fm-code-in-text} command[]{#E.htm_marker-1288011 .calibre17}
  to download a VM with a Podman service installed
- []{#E.htm_pgfId-1286431 .calibre17}Using the
  `podman`{.fm-code-in-text} command[]{#E.htm_marker-1288014 .calibre17}
  to communicate with the Podman service running in the VM
- []{#E.htm_pgfId-1286433 .calibre17}Starting or stopping the VM with
  the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text} start/stop
  commands[]{#E.htm_marker-1288016 .calibre17}

[]{#E.htm_pgfId-1286434}Podman is a tool for launching Linux containers.
Linux containers require a Linux kernel. As much as I'd love to convince
the world to move to the Linux Desktop like I use, most users work on
macOS and Windows operating systems---perhaps even you. If you use the
Linux Desktop, hooray! And if you don't use a macOS machine, feel free
to skip this appendix.

[]{#E.htm_pgfId-1286435}Because you did not skip this appendix, I'll
assume you want to create Linux containers without having to
`ssh`{.fm-code-in-text} into a Linux box. You likely want to use native
software development tools and keep development local.

[]{#E.htm_pgfId-1286436}One way to achieve this would be running Podman
as a service on a Linux box and using the `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} command to communicate with this service.
Podman provides the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text}
command[]{#E.htm_marker-1286437} to configure how Podman communicates
with a Linux box. However, the problem with this approach is that it is
a meticulous process and requires a number of manual steps. Please refer
to this web page for an updated tutorial on this process:
[http://mng.bz/69ro](http://mng.bz/69ro){.url}.

[]{#E.htm_pgfId-1286438}A better way would be using a new command,
`podman`{.fm-code-in-text} `machine,`{.fm-code-in-text} which
encapsulates all these steps and improves your experience with managing
a Linux box to be used for `podman-remote`{.fm-code-in-text}. In this
appendix, you'll learn how to install Podman on macOS and then use the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text} commands to
install, configure, and manage the VM to allow you to use the native
Podman client to launch containers.

[]{#E.htm_pgfId-1286440}The first step to launching Podman on a macOS is
installing it. The macOS client is available through Homebrew
([https://brew.sh/](https://brew.sh/){.url}).

[]{#E.htm_pgfId-1286442}[Note]{.fm-callout-head} Homebrew describes
itself as "\... the easiest and most flexible way to install the UNIX
tools Apple didn't include with macOS"
([https://docs.brew.sh/Manpage](https://docs.brew.sh/Manpage){.url}).

[]{#E.htm_pgfId-1286444}Homebrew is the best way to get open source
software installed on your macOS. If you do not currently have Homebrew
installed on your macOS, open a terminal, and install it with the
following command at the prompt:

``` programlisting
$ /bin/bash -c "$(curl -fsSL 
➥ https:/ /raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

[]{#E.htm_pgfId-1286448}Now run the following `brew`{.fm-code-in-text}
command[]{#E.htm_marker-1286447} to install a trimmed-down version of
Podman, with only `--remote`{.fm-code-in-text}
support[]{#E.htm_marker-1286449}, into the /opt/homebrew/bin directory:

``` programlisting
$ brew install podman
```

[]{#E.htm_pgfId-1286451}If you don't have access to a Linux VM or a
remote Linux server, Podman allows you to create a locally running VM
using the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
command. It makes this easy by creating and configuring a VM with a
Podman service enabled.

[]{#E.htm_pgfId-1286452}[Note]{.fm-callout-head} If you have an existing
Linux machine, you can use the Podman system connection commands to set
up connections to those machines.

## []{#E.htm_pgfId-1286454}E.1 Using podman machine {#E.htm_heading_id_3 .fm-head}

[]{#E.htm_pgfId-1286457}The
[]{#E.htm_marker-1286455}[]{#E.htm_marker-1286456}`podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} commands allow you to pull a VM from the
internet and start it, stop it, or remove it. This VM is preconfigured
with the Podman service. Additionally, this command creates the SSH
connection and adds this information to the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text}
datastore[]{#E.htm_marker-1286458}, greatly simplifying the process of
setting up a `podman-remote`{.fm-code-in-text}
environment[]{#E.htm_marker-1286459}. Table E.1 lists all of the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text} subcommands used
to manage the life cycle of the Podman virtual machine. The first step
is initializing a new VM in your system using the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#E.htm_marker-1286460}, described in
the following section.

[]{#E.htm_pgfId-1288214}Table E.1 Podman machine commands

+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288218}Command                                             | []{#E.htm_pgfId-1288220}Description                 |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288222}`init`{.fm-code-in-text1}[]{#E.htm_marker-1288245}  | []{#E.htm_pgfId-1288224}Initialize a new virtual    |
|                                                                             | machine.                                            |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288226}`list`{.fm-code-in-text1}[]{#E.htm_marker-1288246}  | []{#E.htm_pgfId-1288228}List virtual machines.      |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288230}`rm`{.fm-code-in-text1}[]{#E.htm_marker-1288247}    | []{#E.htm_pgfId-1288232}Remove a virtual machine.   |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288234}`ssh`{.fm-code-in-text1}[]{#E.htm_marker-1288248}   | []{#E.htm_pgfId-1288236}`ssh`{.fm-code-in-text1}    |
|                                                                             | into a virtual machine. This is useful for entering |
|                                                                             | the virtual machine and running the native Podman   |
|                                                                             | commands. Some Podman commands are not supported    |
|                                                                             | remotely, and you might want to change some         |
|                                                                             | configurations inside the VM.                       |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288238}`start`{.fm-code-in-text1}[]{#E.htm_marker-1288249} | []{#E.htm_pgfId-1288240}Start a virtual machine.    |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#E.htm_pgfId-1288242}`stop`{.fm-code-in-text1}[]{#E.htm_marker-1288250}  | []{#E.htm_pgfId-1288244}Stop a virtual machine. If  |
|                                                                             | you are not running containers, you might want to   |
|                                                                             | shut down the VM to save system resources.          |
+-----------------------------------------------------------------------------+-----------------------------------------------------+

### []{#E.htm_pgfId-1286501}E.1.1 podman machine init {#E.htm_heading_id_4 .fm-head1}

[]{#E.htm_pgfId-1286503}The `podman machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#E.htm_marker-1286502} downloads and
configures a VM on your macOS system (figure E.1). By default, it
downloads the latest released `fedora-coreos`{.fm-code-in-text}
image[]{#E.htm_marker-1286504}
([https://getfedora.org/en/coreos](https://getfedora.org/en/coreos){.url})
if it was not downloaded before. Fedora CoreOS is a minimal operating
system designed to run containers.

[]{#E.htm_pgfId-1286505}[Note]{.fm-callout-head} The VM is relatively
large and takes a few minutes to download.

::: figure
![](images/E-01.png){.calibre18}

Figure E.1 The podman `machine init`{.fm-code-in-text} command pulling
the VM and configuring the SSH
:::

[]{#E.htm_pgfId-1286513}Listing E.1 Podman downloading a VM onto the Mac
and preparing it for execution

``` programlisting
$ podman machine init
Downloading VM image: fedora-coreos-35.20211215.2.
➥ 0-qemu.x86_64.qcow2.xz                                    ❶
[=========>------------------------------------------------] 111.0MiB /
➥ 620.7MiB
Downloading VM image: fedora-coreos-35.20211215.2.0-qemu.x86_64.qcow2.xz: done
Extracting compressed file                                   ❷
```

[]{#E.htm_pgfId-1290305}[❶]{.fm-combinumeral} Podman finds and downloads
the latest fedora-coreos qcow image onto your system.

[]{#E.htm_pgfId-1290306}[❷]{.fm-combinumeral} After downloading the
image, Podman decompresses the image and configures qemu to be ready to
execute it. It also configures the SSH connection to the Podman system
connection datastore.

[]{#E.htm_pgfId-1286523}Podman preconfigures the VM with the amount of
memory, disk size, and CPUs for it to use. These values can be
configured using `init`{.fm-code-in-text} subcommand
options[]{#E.htm_marker-1286524}. Table E.2 describes these options.

[]{#E.htm_pgfId-1288316}Table E.2 Podman machine
`init`{.fm-code-in-text} command options

+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
| []{#E.htm_pgfId-1288320}Option                                                            | []{#E.htm_pgfId-1288322}Description                                               |
+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
| []{#E.htm_pgfId-1288324}`--cpus uint`{.fm-code-in-text1}[]{#E.htm_marker-1288339}         | []{#E.htm_pgfId-1288326}Number of CPUs (the default is 1)                         |
+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
| []{#E.htm_pgfId-1288328}`--disk-size uint`{.fm-code-in-text1}[]{#E.htm_marker-1288340}    | []{#E.htm_pgfId-1288330}Disk size in GB (the default is 10). This is an important |
|                                                                                           | setting to consider, since it limits the number of containers and images allowed  |
|                                                                                           | to be used within the VM. If you have the space, I recommend increasing the       |
|                                                                                           | field.                                                                            |
+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
| []{#E.htm_pgfId-1288332}`--image-path string`{.fm-code-in-text1}[]{#E.htm_marker-1288341} | []{#E.htm_pgfId-1288334}Path to `qcow`{.fm-code-in-text1} image (the default is   |
|                                                                                           | `testing`{.fm-code-in-text1}). Podman has two built-in Fedora CoreOS images it    |
|                                                                                           | can pull: `testing`{.fm-code-in-text1} and `stable`{.fm-code-in-text1}. You can   |
|                                                                                           | also select other OSs and VMs to download, but the VMs must support               |
|                                                                                           | CoreOS/Ignition files                                                             |
|                                                                                           | ([https://coreos.github.io/ignition/](https://coreos.github.io/ignition/){.url}). |
+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
| []{#E.htm_pgfId-1288336}`--memory integer`{.fm-code-in-text1}[]{#E.htm_marker-1288343}    | []{#E.htm_pgfId-1288338}Memory in MB (the default is 2048). The VM requires a     |
|                                                                                           | certain amount of memory to run, and depending on the containers you want to run  |
|                                                                                           | within the VM, you might need more.                                               |
+-------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+

[]{#E.htm_pgfId-1286554}Once `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text} finishes
downloading and installing the VM, you can view the VM with the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`list`{.fm-code-in-text} command[]{#E.htm_marker-1286555}. Notice the
`*`{.fm-code-in-text} indicates the default VM to be used. The
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text} command currently
only supports running one VM at a time:

``` programlisting
$ podman machine list
NAME                    VM TYPE   CREATED      LAST UP     CPUS   
➥ MEMORY    DISK SIZE
podman-machine-default  qemu      2 minutes ago  2 minutes ago  1     
➥ 2.147GB   10.74GB
```

[]{#E.htm_pgfId-1286561}In the next section, you'll examine the
automatically created SSH connection.

### []{#E.htm_pgfId-1286563}E.1.2 Podman machine SSH configuration {#E.htm_heading_id_5 .fm-head1}

[]{#E.htm_pgfId-1286568}The
[]{#E.htm_marker-1286564}[]{#E.htm_marker-1286565}[]{#E.htm_marker-1286566}`podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text}
command[]{#E.htm_marker-1286567} provides the OS with the Ignition
config, which includes an SSH key for the core user. Then Podman adds
SSH connections on the client machine for the rootless and rootful
modes, configures the user account, and adds required packages and
configurations within the VM. The SSH configuration allows password-less
SSH commands to the `core`{.fm-code-in-text}[]{#E.htm_marker-1286569}
and `root`{.fm-code-in-text} accounts[]{#E.htm_marker-1286570} from the
client. The `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#E.htm_marker-1286571} also
configures the Podman system connection information (see section 9.5.4).
The system connection database is configured for both the rootful user
and the rootless user within the VM. If no previous connections are
present, the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#E.htm_marker-1286572} will make the
newly created connection a default one.

[]{#E.htm_pgfId-1286573}You can examine all the connections using the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} `list`{.fm-code-in-text}
command[]{#E.htm_marker-1289513}. The default connection,
`podman-machine-default`{.fm-code-in-text}, is the rootless connection:

``` programlisting
$ podman system connection list
Name                       URI                                                     
Identity                                   Default
podman-machine-default
➥ ssh:/ /core@localhost:50107/run/user/501/podman/podman.sock  
➥ /Users/danwalsh/.ssh/podman-machine-default true
podman-machine-default-root  
➥ ssh:/ /root@localhost:50107/run/podman/podman.sock       
➥ /Users/danwalsh/.ssh/podman-machine-default  false
```

[]{#E.htm_pgfId-1286584}Sometimes containers you want to execute require
root privileges and cannot run in rootless modes. For this, you can
modify the system connection to default to the rootful service using the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} `default`{.fm-code-in-text} command:

``` programlisting
$ podman system connection default podman-machine-default-root
```

[]{#E.htm_pgfId-1286586}View the connections again to confirm the
default connection is now
`podman-machine-default-root`{.fm-code-in-text}:

``` programlisting
$ $ podman system connection list
Name                       URI                                                     
➥ Identity                                   Default
podman-machine-default   
➥ ssh:/ /core@localhost:50107/run/user/501/podman/podman.sock  
➥ /Users/danwalsh/.ssh/podman-machine-default  false
podman-machine-default-root 
➥ ssh:/ /root@localhost:50107/run/podman/podman.sock       
➥ /Users/danwalsh/.ssh/podman-machine-default true
n-machine-default ssh:/ /root@localhost:38243/run/podman/podman.sock
```

[]{#E.htm_pgfId-1286593}Now all Podman commands connect directly to the
Podman service running within the root account. Change the default
connection back to the rootless user using the Podman system connection
default command again:

``` programlisting
$ podman system connection default podman-machine-default
```

[]{#E.htm_pgfId-1286595}If you attempt to run a Podman container at this
point, it fails because the VM is not actually running. You need to
start the
[]{#E.htm_marker-1286596}[]{#E.htm_marker-1286597}[]{#E.htm_marker-1286598}VM.

### []{#E.htm_pgfId-1286600}E.1.3 Starting the VM {#E.htm_heading_id_6 .fm-head1}

[]{#E.htm_pgfId-1286605}After
[]{#E.htm_marker-1286601}[]{#E.htm_marker-1286602}[]{#E.htm_marker-1286603}[]{#E.htm_marker-1286604}adding
a VM and setting a specific connection as a default one, try running a
`podman`{.fm-code-in-text} command[]{#E.htm_marker-1286606}:

``` programlisting
$ podman version
Cannot connect to Podman. Please verify your connection to the Linux system 
using `podman system connection list`, or try `podman machine init` and 
`podman machine start` to manage a new Linux VM
Error: unable to connect to Podman. failed to create sshClient: Connection 
to bastion host (ssh:/ /root@localhost:38243/run/podman/podman.sock) 
failed.: dial tcp [::1]:38243: connect: connection refused
```

[]{#E.htm_pgfId-1286614}As the error points out, the VM is not running
and must be started.

[]{#E.htm_pgfId-1286616}You start a single VM using the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`start`{.fm-code-in-text} command[]{#E.htm_marker-1286615}. Podman only
supports running one VM at a time. By default, the start command starts
the default VM. If you have multiple VMs and want to start a different
VM, you can specify the optional machine name:

``` programlisting
$ podman machine start
INFO[0000] waiting for clients...   
INFO[0000] listening tcp:/ /127.0.0.1:7777
INFO[0000] new connection from @ to /run/user/3267/podman/
➥ qemu_podman-machine-default.sock
Waiting for VM ...
macOShine "podman-machine-default" started successfully
```

[]{#E.htm_pgfId-1286624}You are now ready to begin running Podman
commands on the Linux box that runs the Podman service. Run the
`podman`{.fm-code-in-text} `version`{.fm-code-in-text}
command[]{#E.htm_marker-1286625} to confirm the client and server are
configured correctly. If not, the Podman commands should instruct you on
configuring the system:

``` programlisting
$ podman version
Client:
Version:      4.1.0
API Version:  4.1.0
Go Version:   go1.18.1
Built:        Thu May  5 16:07:47 2022
OS/Arch:      darwin/arm64
Server:
Version:      4.1.0
API Version:  4.1.0
Go Version:   go1.18
Built:        Fri May  6 12:16:38 2022
OS/Arch:      linux/arm64
```

[]{#E.htm_pgfId-1286639}Now you can use the Podman commands you learned
in the previous chapters directly on macOS. When you are done working
with containers in the VM, you probably should shut it down to save
[]{#E.htm_marker-1286640}[]{#E.htm_marker-1286641}[]{#E.htm_marker-1286642}[]{#E.htm_marker-1286643}resources.

[]{#E.htm_pgfId-1286644}[Note]{.fm-callout-head} Podman is supported on
M1 arm64 machines as well as the x86 platforms.
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1}
`init`{.fm-code-in-text1} downloads the matching architecture VM,
allowing you to build images for that architecture. Support for building
images on other architectures is being worked on as of this writing.

### []{#E.htm_pgfId-1286646}E.1.4 Stopping the VM {#E.htm_heading_id_7 .fm-head1}

[]{#E.htm_pgfId-1286652}The
[]{#E.htm_marker-1286647}[]{#E.htm_marker-1286648}[]{#E.htm_marker-1286649}[]{#E.htm_marker-1286650}`podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `stop`{.fm-code-in-text}
command[]{#E.htm_marker-1286651} allows you to shut down all containers
within the VM as well as the VM itself:

``` programlisting
$ podman machine stop
```

[]{#E.htm_pgfId-1286658}When you need to start using containers again,
launch the VM with the
[]{#E.htm_marker-1286654}[]{#E.htm_marker-1286655}[]{#E.htm_marker-1286656}[]{#E.htm_marker-1286657}`podman`{.fm-code-in-text}
`machine`{.fm-code-in-text}
[]{#E.htm_marker-1286659}[]{#E.htm_marker-1286660}`start`{.fm-code-in-text}
command[]{#E.htm_marker-1286661}.

[]{#E.htm_pgfId-1286662}[Note]{.fm-callout-head} All of the
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1} commands work
on Linux as well and allow you to test different versions of Podman at
the same time. Podman on Linux is the complete command; therefore, you
need to use the `--remote`{.fm-code-in-text1}
option[]{#E.htm_marker-1289943} to communicate with the Podman service
running within the VM launched by the Podman machine. On non-Linux
platforms the `--remote`{.fm-code-in-text1}
option[]{#E.htm_marker-1289944} is not required, since the client is
preconfigured in `--remote`{.fm-code-in-text1}
mode[]{#E.htm_marker-1289945}.

## []{#E.htm_pgfId-1286667}Summary {#E.htm_heading_id_8 .fm-head}

- []{#E.htm_pgfId-1286668 .calibre17}Linux containers require a Linux
  kernel, meaning running containers on a macOS requires a virtual
  machine running Linux.

- []{#E.htm_pgfId-1286669 .calibre17}Podman on a macOS is not running
  containers locally on the macOS. The Podman command is actually
  communicating with the Podman service running on a Linux machine.

- []{#E.htm_pgfId-1286670 .calibre17}The `podman`{.fm-code-in-text}
  `machine`{.fm-code-in-text} `init`{.fm-code-in-text} command pulls
  down and installs a Fedora CoreOS VM onto your platform, which is
  running the Podman service.

- []{#E.htm_pgfId-1286671 .calibre17}The `podman`{.fm-code-in-text}
  `machine`{.fm-code-in-text} `init`{.fm-code-in-text} command also sets
  up the SSH environment required to allow the Podman remote client to
  communicate with the Podman server inside the []{#E.htm_marker-1286672
  .calibre17}VM.

[]{#F.htm}

# []{#F.htm_pgfId-1289585}[]{#F.htm_pgfId-1289586}Appendix F. Podman on Windows {#F.htm_heading_id_2 .tochead}

[]{#F.htm_pgfId-1289588}This appendix []{#F.htm_marker-1290859}covers

- []{#F.htm_pgfId-1289589 .calibre17}Installing Podman on Windows
- []{#F.htm_pgfId-1289591 .calibre17}Using the
  `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
  `init`{.fm-code-in-text} command[]{#F.htm_marker-1292811 .calibre17}
  to create a Fedora-based WSL 2 distribution running Podman
- []{#F.htm_pgfId-1289593 .calibre17}Using the
  `podman`{.fm-code-in-text} command[]{#F.htm_marker-1290864 .calibre17}
  on Windows to communicate with the Podman service running in the WSL 2
  instance
- []{#F.htm_pgfId-1289595 .calibre17}Starting or stopping the WSL 2
  instance with the `podman`{.fm-code-in-text}
  `machine`{.fm-code-in-text} start/stop
  commands[]{#F.htm_marker-1290867 .calibre17}

[]{#F.htm_pgfId-1289596}Podman is a tool for launching Linux containers.
Linux containers require a Linux kernel. As much as I'd love to convince
the world to move to the Linux desktop like me, most users work on Mac
and Windows operating systems---perhaps even you. If you use the Linux
desktop, hooray! And if you don't use a Windows machine, feel free to
skip this appendix.

[]{#F.htm_pgfId-1289598}Because you did not skip this appendix, I'll
assume you want to create Linux containers without having to
`ssh`{.fm-code-in-text} into a Linux machine and create the container
there. You likely want to use native software development tools and keep
their software local to their machines.

[]{#F.htm_pgfId-1289599}On Linux, Podman can be run as a service
allowing remote connections to launch containers. Then, from another
system, the `podman`{.fm-code-in-text} `--remote`{.fm-code-in-text}
command can be used to communicate with the remote Podman service to
launch a container.

[]{#F.htm_pgfId-1289600}Further, you can use `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text} to configure
`podman`{.fm-code-in-text} `--remote`{.fm-code-in-text} to communicate
with a remote Linux machine running the Podman service over SSH, without
providing a URL to every command. The problem with all of this is that
someone has to configure the remote machine with the correct version of
the Podman service, and then you have to configure the SSH session.

[]{#F.htm_pgfId-1289601}Realizing that this experience is not optimal
for new users of Podman on a Windows desktop, Podman added a new
command: `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}. The
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text} command makes it
easy to create and manage a WSL 2-based Linux environment with Podman
preinstalled and configured. The Podman command on Windows is actually a
thinned down Podman command with only `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} support[]{#F.htm_marker-1289602}. In this
appendix, you'll learn how to install Podman onto your Windows machine,
and then use the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
commands to install, configure, and manage the WSL 2 instance.

## []{#F.htm_pgfId-1289603}F.1 First steps {#F.htm_heading_id_3 .fm-head}

[]{#F.htm_pgfId-1289604}The `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} command on Windows accepts all the same
commands as those used on Linux and Mac, with very similar behavior.
Still, there are a few differences, since the underlying backend on
Windows is based on Windows Subsystem for Linux
([https://docs.microsoft.com/en-us/windows/wsl/](https://docs.microsoft.com/en-us/windows/wsl/){.url})
instead of the VM, as in the other operating systems.

[]{#F.htm_pgfId-1289606}WSL 2 involves using the Windows Hyper-V
hypervisor; however, unlike a standard VM-based approach, WSL 2 shares
the same VM and Linux kernel instance across every Linux distribution
instance installed by the user. As an example, if you create two WSL 2
distributions, and you run `dmesg`{.fm-code-in-text} on each instance,
you see the same output, since the same kernel is hosting both.

[]{#F.htm_pgfId-1289607}[Note]{.fm-callout-head} WSL 1 doesn't work with
Podman; you must upgrade your Windows machine to an OS version that
supports WSL 2. For x64 systems, you will need Windows version 1,903 or
higher, with build 18,362 or higher. For arm64 systems, you will need
Windows version 2004 or higher, with build 19,041 or higher.

[]{#F.htm_pgfId-1289608}Running Podman with WSL 2 enables efficient
resource sharing between the host and all running instances in exchange
for less isolation. Keep in mind the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} command shares the same kernel with any
other distributions you have running, and be cautious when manipulating
any kernel-level setting (e.g., network interfaces and netfilter policy)
in any distribution because you may unintentionally affect containers
executed by Podman.

### []{#F.htm_pgfId-1289610}F.1.1 Prerequisites {#F.htm_heading_id_4 .fm-head1}

[]{#F.htm_pgfId-1289612}Podman []{#F.htm_marker-1289611}for Windows
requires Windows 10 (build 19,041 or later) or Windows 11. As WSL 2 uses
a hypervisor, your computer must have virtualization instructions
enabled (e.g., Intel VT-x or AMD-V). Additionally, the hypervisor
requires second-level address translation
(SLAT[]{#F.htm_marker-1289613}[]{#F.htm_marker-1289614}) support.
Finally, your system must either have internet connectivity or an
offline copy of all software to be fetched by the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}.

[]{#F.htm_pgfId-1289615}[Note]{.fm-callout-head} If at any time you
experience the errors 0x80070003 or 0x80370102 (or any error indicating
the VM cannot be started), you most likely have virtualization disabled.
Check your BIOS (or WSL 2 instance) settings to verify VT-x/AMD-V/WSL 2
instance and SLAT are enabled.

[]{#F.htm_pgfId-1289616}While not required, installing Windows Terminal
(as opposed to the standard CMD command application or PowerShell) is
strongly recommended (future versions of Windows 11 include it by
default). In addition to having modern terminal features, like
transparent cut and paste and tiled screens, it also offers direct WSL
and PowerShell integration, making it easy to switch between
environments. You can install it via the Windows store or
`winget`{.fm-code-in-text}:

``` programlisting
PS C:\Users\User> winget install Microsoft.WindowsTerminal
```

### []{#F.htm_pgfId-1289620}F.1.2 Installing Podman {#F.htm_heading_id_5 .fm-head1}

[]{#F.htm_pgfId-1289623}Installing
[]{#F.htm_marker-1289621}[]{#F.htm_marker-1289622}Podman is
straightforward. Go to the Podman site or the Podman GitHub repository,
and download the latest Podman MSI Windows Installer in the Releases
section (figure F.1;
[https://github.com/containers/podman/releases](https://github.com/containers/podman/releases){.url}).

::: figure
![](images/F-01.png){.calibre18}

Figure F.1 Downloading and running the Podman installer
:::

[]{#F.htm_pgfId-1289631}After running the installer, open a terminal
(use the `wt`{.fm-code-in-text} command if you installed Windows
Terminal as recommended), and execute your first
`podman`{.fm-code-in-text} command[]{#F.htm_marker-1289632} (figure
F.2).

::: figure
![](images/F-02.png){.calibre18}

Figure F.2 Podman commands running within the Windows Terminal
:::

[]{#F.htm_pgfId-1289641}Automatic WSL installation

[]{#F.htm_pgfId-1289644}If
[]{#F.htm_marker-1292567}[]{#F.htm_marker-1292568}WSL is not installed
on your Windows system, Podman installs it for you. Simply execute the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#F.htm_marker-1292570} (as
illustrated in figure F.3) to create your first machine instance, and
Podman prompts you for permission to install WSL. The WSL install
process requires a reboot but resumes execution of the machine creation
process. (Be sure to wait a few minutes for the terminal to relaunch and
install.) If you prefer a manual installation, refer to the WSL
[]{#F.htm_marker-1292571}[]{#F.htm_marker-1292572}installation
[]{#F.htm_marker-1292573}[]{#F.htm_marker-1292574}guide:
[https://docs.microsoft.com/en-us/windows/wsl/install](https://docs.microsoft.com/en-us/windows/wsl/install){.url}.

::: figure
![](images/F-03.png){.calibre18}

Figure F.3 The podman machine init starts the WSL installation.
:::

## []{#F.htm_pgfId-1289658}F.2 Using podman machine {#F.htm_heading_id_6 .fm-head}

[]{#F.htm_pgfId-1289661}The
[]{#F.htm_marker-1292506}[]{#F.htm_marker-1292507}setup and use of the
Linux environment is made easy through the use of
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text} commands. On
Windows, these commands create and manage a WSL 2 distribution,
including downloading a base Linux image and packages from the internet
and setting everything up for you. The WSL 2 distribution is
preconfigured with the Podman service, and SSH connection configuration
is automatically added to the `podman`{.fm-code-in-text}
`system`{.fm-code-in-text} `connection`{.fm-code-in-text}
datastore[]{#F.htm_marker-1292509}. The final result is the ability to
easily run Podman commands on your Windows desktop as if it was a Linux
system. Table F.1 lists all of the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} commands used to manage the lifecycle of the
WSL 2-backed Linux environment.

[]{#F.htm_pgfId-1291337}Table F.1 `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} commands

+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291341}Command                                             | []{#F.htm_pgfId-1291343}Description                 |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291345}`init`{.fm-code-in-text1}[]{#F.htm_marker-1292520}  | []{#F.htm_pgfId-1291347}Initialize a new WSL        |
|                                                                             | 2-based machine instance.                           |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291349}`list`{.fm-code-in-text1}[]{#F.htm_marker-1292525}  | []{#F.htm_pgfId-1291351}List WSL 2 machines.        |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291353}`rm`{.fm-code-in-text1}[]{#F.htm_marker-1292530}    | []{#F.htm_pgfId-1291355}Remove a WSL 2 machine      |
|                                                                             | instance.                                           |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291357}`set`{.fm-code-in-text1}[]{#F.htm_marker-1292535}   | []{#F.htm_pgfId-1291359}Set an updatable WSL        |
|                                                                             | machine setting.                                    |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291361}`ssh`{.fm-code-in-text1}[]{#F.htm_marker-1292540}   | []{#F.htm_pgfId-1291363}`ssh`{.fm-code-in-text1}    |
|                                                                             | into a WSL 2 machine instance. This is useful for   |
|                                                                             | entering the WSL 2 instance and running the native  |
|                                                                             | Podman commands. Some Podman commands are not       |
|                                                                             | supported remotely, and you might want to change    |
|                                                                             | some configurations inside the WSL 2 instance.      |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291365}`start`{.fm-code-in-text1}[]{#F.htm_marker-1292545} | []{#F.htm_pgfId-1291367}Start a WSL 2 machine       |
|                                                                             | instance.                                           |
+-----------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291369}`stop`{.fm-code-in-text1}[]{#F.htm_marker-1292550}  | []{#F.htm_pgfId-1291371}Stop a WSL 2 machine        |
|                                                                             | instance. If you are not running containers, you    |
|                                                                             | might want to stop to save system resources.        |
+-----------------------------------------------------------------------------+-----------------------------------------------------+

[]{#F.htm_pgfId-1289706}After installing Podman (see section F.1.2), the
first step is creating a WSL 2 machine instance on your system. You will
use the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#F.htm_marker-1289707}, described in
the following section.

### []{#F.htm_pgfId-1289708}F.2.1 podman machine init {#F.htm_heading_id_7 .fm-head1}

[]{#F.htm_pgfId-1289713}As
[]{#F.htm_marker-1293020}[]{#F.htm_marker-1293021}[]{#F.htm_marker-1293022}shown
in figure F.4, you can use the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text}
command[]{#F.htm_marker-1293023} to automate the installation of a WSL
2-based Linux environment that hosts a Podman service for running
containers. By default, `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text} downloads a known
compatible release of Fedora to create the WSL 2 instance
([https://getfedora.org](https://getfedora.org){.url}). Fedora is used,
since it is well integrated with Podman and is the operating system used
by most of the Podman core developers.

::: figure
![](images/F-04.png){.calibre18}

Figure F.4 The podman machine init command creating the WSL 2
distribution and configuring SSH connections.
:::

[]{#F.htm_pgfId-1289714}[Note]{.fm-callout-head} In addition to the base
image, a number of packages must be downloaded and installed, which can
take several minutes to complete.

[]{#F.htm_pgfId-1289721}The following shows the condensed output from
running the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#F.htm_marker-1289722}:

``` programlisting
PS C:\Users\User> podman machine init
Downloading VM image: fedora-35.20211125-x86_64.tar.xz: done
Extracting compressed file
Importing operating system into WSL (this may take 5+ minutes on a new WSL 
➥ install)...
Installing packages (this will take awhile)...
Fedora 35 - x86_64                                5.5 MB/s |  79 MB     00:14
Complete!
Configuring system...
Generating public/private ed25519 key pair.
Machine init complete
To start your machine run:
        podman machine start
```

[]{#F.htm_pgfId-1289739}Table F.2 explains the `init`{.fm-code-in-text}
options that allow you to customize the default
[]{#F.htm_marker-1289736}[]{#F.htm_marker-1289737}[]{#F.htm_marker-1289738}settings.
[]{#F.htm_marker-1289740}

[]{#F.htm_pgfId-1291462}Table F.2 `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text} command options

+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291466}Option                                                  | []{#F.htm_pgfId-1291468}Description                 |
+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291470}`--cpus`{.fm-code-in-text1}                             | []{#F.htm_pgfId-1291472}Not used                    |
| `uint`{.fm-code-in-text1}[]{#F.htm_marker-1291489}                              |                                                     |
+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291474}`--disk-size`{.fm-code-in-text1}                        | []{#F.htm_pgfId-1291476}Not used                    |
| `uint`{.fm-code-in-text1}[]{#F.htm_marker-1291490}                              |                                                     |
+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291478}`--image-path`{.fm-code-in-text1}                       | []{#F.htm_pgfId-1291480}On Windows, this option     |
| `string`{.fm-code-in-text1}[]{#F.htm_marker-1291491}                            | refers to the Fedora distribution number (e.g.,     |
|                                                                                 | 35). As with Linux and Mac, you can also specify an |
|                                                                                 | arbitrary URL or filesystem location with a custom  |
|                                                                                 | image, but Podman expects a Fedora-derived layout.  |
+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291482}`--memory`{.fm-code-in-text1}                           | []{#F.htm_pgfId-1291484}Not used                    |
| `integer`{.fm-code-in-text1}[]{#F.htm_marker-1291492}                           |                                                     |
+---------------------------------------------------------------------------------+-----------------------------------------------------+
| []{#F.htm_pgfId-1291486}`--rootful`{.fm-code-in-text1}[]{#F.htm_marker-1291493} | []{#F.htm_pgfId-1291488}Determines whether this     |
|                                                                                 | machine instance should be rootful or rootless      |
+---------------------------------------------------------------------------------+-----------------------------------------------------+

[]{#F.htm_pgfId-1289773}[Note]{.fm-callout-head} The physical limits
specified in table F.2 (e.g., CPU, memory, and disk) are currently
ignored on Windows, since the Windows Subsystem for Linux (WSL) backend
dynamically resizes and shares resources across distributions. If you
need to constrain resources, you can configure those limits in your
users' .wslconfig file. However, they apply globally to all WSL 2
distros, since they share the same underlying VM.

### []{#F.htm_pgfId-1289774}F.2.2 Podman machine SSH configuration {#F.htm_heading_id_8 .fm-head1}

[]{#F.htm_pgfId-1289779}The
[]{#F.htm_marker-1289775}[]{#F.htm_marker-1289776}[]{#F.htm_marker-1289777}`podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text}
command[]{#F.htm_marker-1289778} creates an account within the WSL 2
instance. By default, the user in Fedora is user@localhost. Podman
configures SSH on the client machine and the new user account and root
within the WSL 2 instance. The SSH configuration allows for passwordless
SSH commands to the `user`{.fm-code-in-text}[]{#F.htm_marker-1289780}
and `root`{.fm-code-in-text} accounts[]{#F.htm_marker-1289781} from the
client. The `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} command[]{#F.htm_marker-1289782} also
configures the Podman system connection information (see section 9.5.4).
The system connection database is configured for both the rootful user
and rootless user within the WSL 2 instance. If you do not have any
existing connections, the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `init`{.fm-code-in-text}
command[]{#F.htm_marker-1289783} creates and sets as a default one of
the rootless user connections to your WSL 2 instance.

[]{#F.htm_pgfId-1289784}You can examine all of the connections using the
`podman`{.fm-code-in-text} `system`{.fm-code-in-text}
`connection`{.fm-code-in-text} list command[]{#F.htm_marker-1289785}.
The default connection, `podman-machine-default`{.fm-code-in-text}, is
the rootless connection:

``` programlisting
PS C:\Users\User> podman system connection ls
Name                         URI                           Identity 
➥ Default
podman-machine-default       ssh:/ /user@localhost:57051..  podman-machine-
➥ default  true
podman-machine-default-root  ssh:/ /root@localhost:57051..  podman-machine-
➥ default  false
```

[]{#F.htm_pgfId-1289792}Sometimes containers you want to execute require
root privileges and cannot run in rootless modes. You can change the
default connection to rootful by switching the default mode for the
created machine instance. Modify the default to rootful service using
the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`set`{.fm-code-in-text} command[]{#F.htm_marker-1289793}:

``` programlisting
PS C:\Users\User> podman machine set --rootful
```

[]{#F.htm_pgfId-1289795}View the connections again to confirm the
default is now `podman-machine-default-root`{.fm-code-in-text}:

``` programlisting
PS C:\Users\User> podman system connection ls
Name                         URI                          Identity         
➥ Default
podman-machine-default       ssh:/ /user@localhost:57051.. 
➥ podman-machine-default  false
podman-machine-default-root  ssh:/ /root@localhost:57051.. 
➥ podman-machine-default  true
```

[]{#F.htm_pgfId-1289803}Now all Podman commands connect directly to the
Podman service running within the root account. Change the default
connection back to the rootless user using the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`set`{.fm-code-in-text} command[]{#F.htm_marker-1289804} again:

``` programlisting
PS C:\Users\User> podman machine set --rootful=false
```

[]{#F.htm_pgfId-1289806}If you attempt to run a Podman container at this
point, it fails because the machine instance is not actually running.
You need to start the machine
[]{#F.htm_marker-1289807}[]{#F.htm_marker-1289808}[]{#F.htm_marker-1289809}instance.

### []{#F.htm_pgfId-1289810}F.2.3 Starting the WSL 2 instance {#F.htm_heading_id_9 .fm-head1}

[]{#F.htm_pgfId-1289815}Attempting
[]{#F.htm_marker-1289811}[]{#F.htm_marker-1289812}[]{#F.htm_marker-1289813}[]{#F.htm_marker-1289814}to
execute the `podman`{.fm-code-in-text} `version`{.fm-code-in-text}
command fails because the WSL 2 instance is not started:

``` programlisting
PS C:\Users\User> podman version
Cannot connect to Podman. Please verify your connection to the Linux system 
using `podman system connection list`, or try `podman machine init` and 
`podman machine start` to manage a new Linux Linux VM
Error: unable to connect to Podman. failed to create sshClient: Connection 
to bastion host (ssh:/ /root@localhost:38243/run/podman/podman.sock) 
failed.: dial tcp [::1]:38243: connect: connection refused
```

[]{#F.htm_pgfId-1289823}As the error points out, the virtualized Linux
environment (the WSL 2 machine instance) is not running and must be
started.

[]{#F.htm_pgfId-1289825}You start a single WSL 2 instance using the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`start`{.fm-code-in-text} command[]{#F.htm_marker-1289824}. By default,
it starts the default WSL 2 instance:
`podman-machine-default`{.fm-code-in-text}. If you have multiple WSL 2
instances and want to start a different WSL 2 instance, you can specify
the optional machine name for the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `start`{.fm-code-in-text}
command[]{#F.htm_marker-1289826}:

``` programlisting
PS C:\Users\User> podman machine start
Starting machine "podman-machine-default"
This machine is currently configured in rootless mode. If your containers
require root permissions (e.g. ports < 1024), or if you run into compatibility
issues with non-podman clients, you can switch using the following command:
        podman machine set --rootful
API forwarding listening on: npipe:////./pipe/docker_engine
Docker API clients default to this address. You do not need to set 
DOCKER_HOST.
Machine "podman-machine-default" started successfully
```

[]{#F.htm_pgfId-1289837}You are now ready to begin running Podman
commands on the host that communicates with the Podman service running
in the WSL 2 instance. Run the `podman`{.fm-code-in-text}
`version`{.fm-code-in-text} command[]{#F.htm_marker-1289838} to confirm
the client and server are configured correctly. If not, the Podman
commands instruct you on how to configure the system:

``` programlisting
PS C:\Users\User> podman version
Client:       Podman Engine
Version:      4.0.0-dev
API Version:  4.0.0-dev
Go Version:   go1.17.1
Git Commit:   bac389043f268e632c45fed7b4e88bdefd2d95e6-dirty
Built:        Wed Feb 16 00:33:20 2022
OS/Arch:      windows/amd64
Server:       Podman Engine
Version:      4.0.1
API Version:  4.0.1
Go Version:   go1.16.14
Built:      Fri Feb 25 13:22:13 2022
OS/Arch:    linux/amd64
```

[]{#F.htm_pgfId-1289853}Now you can use the Podman commands you learned
in the previous chapters directly on Windows. Make sure you understand
that Podman on Windows is equivalent to `podman`{.fm-code-in-text}
`--remote`{.fm-code-in-text} talking remotely to the Podman service
within the WSL 2
[]{#F.htm_marker-1289854}[]{#F.htm_marker-1289855}[]{#F.htm_marker-1289856}[]{#F.htm_marker-1289857}instance.

### []{#F.htm_pgfId-1289859}F.2.4 Using podman machine commands {#F.htm_heading_id_10 .fm-head1}

[]{#F.htm_pgfId-1289863}After
[]{#F.htm_marker-1289860}[]{#F.htm_marker-1289861}[]{#F.htm_marker-1289862}your
machine instance is running, you can perform Podman commands in your
PowerShell prompt as if running within
[]{#F.htm_marker-1289864}[]{#F.htm_marker-1289865}[]{#F.htm_marker-1289866}Windows:

``` programlisting
PS C:\Users\User> podman run ubi8-micro date
Thu Jan  6 05:09:59 UTC 2022
```

[]{#F.htm_pgfId-1289869}Stopping the WSL 2 instance

[]{#F.htm_pgfId-1289874}When
[]{#F.htm_marker-1289870}[]{#F.htm_marker-1289871}[]{#F.htm_marker-1289872}[]{#F.htm_marker-1289873}you
are done using containers on your system, you might want to shut down
the WSL 2 instance to save on system resources. Use the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`stop`{.fm-code-in-text} command[]{#F.htm_marker-1289875} to shut down
all containers within the WSL 2 instance as well as the WSL 2 instance:

``` programlisting
PS C:\Users\User> podman machine stop
```

[]{#F.htm_pgfId-1289877}When you need to start using containers again,
launch the WSL 2 instance with the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `start`{.fm-code-in-text}
[]{#F.htm_marker-1289878}[]{#F.htm_marker-1289879}[]{#F.htm_marker-1289880}[]{#F.htm_marker-1289881}command[]{#F.htm_marker-1289882}.

[]{#F.htm_pgfId-1289883}[Note]{.fm-callout-head} All of the
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1} commands work
on Linux as well and allow you to test different versions of Podman at
the same time. Podman on Linux is the complete command; therefore, you
need to use the `--remote`{.fm-code-in-text1}
option[]{#F.htm_marker-1292703} to communicate with the Podman service
running within the WSL 2 instance launched by the
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1} command. On
non-Linux platforms, the `--remote`{.fm-code-in-text1}
option[]{#F.htm_marker-1292704} is not required, since the client is
preconfigured in `--remote`{.fm-code-in-text1}
mode[]{#F.htm_marker-1292705}.

[]{#F.htm_pgfId-1289889}Listing machines

[]{#F.htm_pgfId-1289894}You
[]{#F.htm_marker-1289890}[]{#F.htm_marker-1289891}[]{#F.htm_marker-1289892}can
list the available machine instances using the
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`ls`{.fm-code-in-text} command[]{#F.htm_marker-1289893}. The values
returned by this command on Windows reflect current active usage, as
opposed to fixed resource limits, as is the case on Mac and Linux. Disk
storage reflects the disk space currently allocated to each machine
instance. The CPU values convey the number of CPUs on the Windows host
(unless limited by WSL) repeated per machine instance. The returned
memory values are also repeated (with slight variation from sampling
variability) and reflect the total amount of memory used by the Linux
kernel for all distributions in use (since it is shared). In other
words, for total usage, you sum the disk sizes but not memory and
[]{#F.htm_marker-1289895}[]{#F.htm_marker-1289896}[]{#F.htm_marker-1289897}CPU.

``` programlisting
PS C:\Users\User> podman machine ls
NAME                    VM TYPE     CREATED        LAST UP  CPUS        
➥ MEMORY      DISK SIZE
podman-machine-default  wsl         3 days ago     Running  4           
➥ 528.4MB     845.2MB
other                   wsl         4 minutes ago  Running  4           
➥ 524.5MB     778MB
```

[]{#F.htm_pgfId-1289905}Using Podman at the WSL prompt

[]{#F.htm_pgfId-1289910}In
[]{#F.htm_marker-1289906}[]{#F.htm_marker-1289907}[]{#F.htm_marker-1289908}addition
to the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`ssh`{.fm-code-in-text} command[]{#F.htm_marker-1289909}, you can also
access the `podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`guest`{.fm-code-in-text} using the WSL prompt. If you are running
Windows Terminal, the `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `guests`{.fm-code-in-text} (names prefixed
by Podman) are in the down-arrow dropdown. Alternatively, you can drop
into a WSL shell from any PowerShell prompt by using the
`wsl`{.fm-code-in-text} command and specifying the backing distribution
name. For example, the default instance created by
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} is `podman-machine-default`{.fm-code-in-text}.
You can use either approach to manage the guest and execute Podman
commands inside a full-featured Linux shell
[]{#F.htm_marker-1289911}[]{#F.htm_marker-1289912}[]{#F.htm_marker-1289913}environment:

``` programlisting
PS C:\Users\User> wsl -d podman-machine-default
[root@WIN10PRO /]# podman version
Client:       Podman Engine
Version:      4.0.1
API Version:  4.0.1
Go Version:   go1.16.14
 
Built:      Fri Feb 25 13:22:13 2022
OS/Arch:    linux/amd64
```

[]{#F.htm_pgfId-1289924}Updating Fedora

[]{#F.htm_pgfId-1289929}Since
[]{#F.htm_marker-1289925}[]{#F.htm_marker-1289926}[]{#F.htm_marker-1289927}[]{#F.htm_marker-1289928}the
Windows machine implementation is based on Fedora, not Fedora CoreOS,
fixes and enhancements are not automatic. They must be explicitly
initiated on the guest using Fedora's package management command:
`dnf`{.fm-code-in-text}. Further, upgrading to a new version of Fedora
requires exporting any data you need to preserve and using
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`init`{.fm-code-in-text} to create a second machine instance (or
replacing the existing one after a `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `rm`{.fm-code-in-text}
command[]{#F.htm_marker-1289930}).

[]{#F.htm_pgfId-1289931}[Note]{.fm-callout-head} Currently, it is
difficult to run Fedora CoreOS inside of WSL, so it was decided to
default to Fedora. If Windows support for CoreOS changes in the future,
`podman`{.fm-code-in-text1} `machine`{.fm-code-in-text1} will move to
Fedora CoreOS.

[]{#F.htm_pgfId-1289932}As an example, to pull the latest packages for
the version of Fedora running on the p`odman`{.fm-code-in-text}
`guest`{.fm-code-in-text}, perform the following
[]{#F.htm_marker-1289933}[]{#F.htm_marker-1289934}[]{#F.htm_marker-1289935}[]{#F.htm_marker-1289936}command:

``` programlisting
PS C:\Users\User> podman machine ssh dnf upgrade -y
Warning: Permanently added '[localhost]:52581' (ED25519) to the list of 
known hosts.
Last metadata expiration check: 1:18:35 ago on Wed Jan  5 21:13:15 2022.
Dependencies resolved.
...
Complete!
```

[]{#F.htm_pgfId-1289945}Advanced stopping and restarting

[]{#F.htm_pgfId-1289951}Normally,
[]{#F.htm_marker-1289946}[]{#F.htm_marker-1289947}[]{#F.htm_marker-1289948}[]{#F.htm_marker-1289949}[]{#F.htm_marker-1289950}to
stop and restart Podman, you would use the respective
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`stop`{.fm-code-in-text}[]{#F.htm_marker-1289952} and
`podman`{.fm-code-in-text} `machine`{.fm-code-in-text}
`start`{.fm-code-in-text} commands[]{#F.htm_marker-1289953}. Stopping
the machine is the preferred approach, since system services can come to
a clean stop. However, in some cases, you may wish to force a hard
restart of the WSL facilities, including the shared Linux kernel, which
stays active even after a machine stop. To kill all processes associated
with a WSL distribution, use the `wsl`{.fm-code-in-text}
`--terminate`{.fm-code-in-text} `<machine`{.fm-code-in-text}
`name>`{.fm-code-in-text} command[]{#F.htm_marker-1289954}. To shut down
the Linux kernel, killing all running distributions, use the
`wsl`{.fm-code-in-text} `--shutdown`{.fm-code-in-text}
command[]{#F.htm_marker-1289955}. After these commands are issued, you
can use a standard `podman`{.fm-code-in-text}
`machine`{.fm-code-in-text} `start`{.fm-code-in-text}
command[]{#F.htm_marker-1289956} to relaunch
[]{#F.htm_marker-1289957}[]{#F.htm_marker-1289958}[]{#F.htm_marker-1289959}[]{#F.htm_marker-1289960}[]{#F.htm_marker-1289961}your
[]{#F.htm_marker-1289962}[]{#F.htm_marker-1289963}instance:

``` programlisting
PS C:\Users\User> wsl --shutdown
PS C:\Users\User> podman machine start
Starting machine...
Machine "podman-machine-default" started successfully
```

## []{#F.htm_pgfId-1289968}Summary {#F.htm_heading_id_11 .fm-head}

- []{#F.htm_pgfId-1289969 .calibre17}Linux containers require a Linux
  kernel, meaning running containers on a Mac or Windows platform
  requires a VM running Linux.

- []{#F.htm_pgfId-1289970 .calibre17}Podman on Windows does not run
  containers locally on Windows. The Podman command is actually
  `podman`{.fm-code-in-text} `--remote`{.fm-code-in-text} communicating
  with the Podman service running on a Linux machine backed by WSL 2.

- []{#F.htm_pgfId-1289971 .calibre17}The `podman`{.fm-code-in-text}
  `machine`{.fm-code-in-text} `init`{.fm-code-in-text} pulls down and
  installs a virtual Linux environment onto your platform, which runs
  the Podman service.

- []{#F.htm_pgfId-1289972 .calibre17}The `podman`{.fm-code-in-text}
  `machine`{.fm-code-in-text} `init`{.fm-code-in-text} command also sets
  up the SSH environment required to allow the Podman remote client to
  communicate with the Podman server inside of the WSL 2 instance.

- []{#F.htm_pgfId-1289973 .calibre17}Podman on Windows with WSL is the
  full Podman command. WSL is running the Podman commands under the
  Linux kernel, even though it feels like it is running natively on the
  Windows []{#F.htm_marker-1289974 .calibre17}machine.

[]{#index.htm}

# []{#index.htm_pgfId-261944}index {#index.htm_heading_id_2 .tochead}

[]{#index.htm_pgfId-432134 .calibre17}A[]{#index.htm_Symbols
.calibre17}[]{#index.htm_Numerics .calibre17}[]{#index.htm_A .calibre17}

[]{#index.htm_pgfId-432138 .calibre17}[accept flag
224](#11.htm_marker-1121962){.index1}

[]{#index.htm_pgfId-432140 .calibre17}[add command
239](#A.htm_marker-1277927){.index1}

[]{#index.htm_pgfId-432142 .calibre17}[ADD instruction
239](#A.htm_marker-1277925){.index1} --
[240](#A.htm_marker-1282708){.index1}

[]{#index.htm_pgfId-432145 .calibre17}[- -all option
35](#02.htm_marker-1048910){.index1} --
[36](#02.htm_marker-1037776){.index1},
[38](#02.htm_marker-1037853){.index1},
[44](#02.htm_marker-1038312){.index1},
[49](#02.htm_marker-1038499){.index1},
[54](#02.htm_marker-1038633){.index1},
[84](#04.htm_marker-1103916){.index1} --
[86](#04.htm_marker-1103991){.index1}

[]{#index.htm_pgfId-432154 .calibre17}[always option
137](#07.htm_marker-1110646){.index1}

[]{#index.htm_pgfId-432156 .calibre17}[Apache Service
132](#07.htm_marker-1110442){.index1} --
[134](#07.htm_marker-1110499){.index1}

[]{#index.htm_pgfId-432159 .calibre17}[APIs, Podman-supported
171](#09.htm_marker-1109567){.index1} --
[173](#09.htm_marker-1109680){.index1}

[]{#index.htm_pgfId-432162 .calibre17}[apt tool
24](#01.htm_marker-1032148){.index1}

[]{#index.htm_pgfId-432164 .calibre17}[Arch Linux
256](#C.htm_marker-1284837){.index1}

[]{#index.htm_pgfId-432166 .calibre17}[- -arch option
58](#02.htm_marker-1038798){.index1}

[]{#index.htm_pgfId-432168 .calibre17}[arm64 machine
13](#01.htm_marker-1031749){.index1}

[]{#index.htm_pgfId-432170 .calibre17}[attach command
40](#02.htm_marker-1044866){.index1}

[]{#index.htm_pgfId-432172 .calibre17}[- -attach option
35](#02.htm_marker-1037753){.index1}

[]{#index.htm_pgfId-432174 .calibre17}[auditing
218](#11.htm_marker-1121708){.index1} --
[220](#11.htm_marker-1121777){.index1}

[]{#index.htm_pgfId-432177 .calibre17}[aufs storage driver
95](#05.htm_marker-1108319){.index1}

[]{#index.htm_pgfId-432179 .calibre17}[augenrules - -load command
220](#11.htm_marker-1121771){.index1}

[]{#index.htm_pgfId-432181 .calibre17}[- -auth-file option
49](#02.htm_marker-1038481){.index1}

[]{#index.htm_pgfId-432183 .calibre17}[automatic WSL installation
272](#F.htm_marker-1292568){.index1}

[]{#index.htm_pgfId-432185 .calibre17}[automating building of
application 64](#02.htm_marker-1039051){.index1} --
[65](#02.htm_marker-1039109){.index1}

[]{#index.htm_pgfId-432188 .calibre17}[auto-userns-max-size option
201](#10.htm_marker-1121487){.index1}

[]{#index.htm_pgfId-432190 .calibre17}[auto-userns-min-size option
201](#10.htm_marker-1121482){.index1}

[]{#index.htm_pgfId-432192 .calibre17}B[]{#index.htm_B .calibre17}

[]{#index.htm_pgfId-432194 .calibre17}[bash script
30](#02.htm_marker-1037611){.index1}

[]{#index.htm_pgfId-432196 .calibre17}[binderfs mount type
117](#06.htm_marker-1112573){.index1}

[]{#index.htm_pgfId-432198 .calibre17}[bind mount type
117](#06.htm_marker-1112572){.index1}

[]{#index.htm_pgfId-432200 .calibre17}[blocking pulling from container
registries 98](#05.htm_marker-1105831){.index1} --
[100](#05.htm_marker-1105903){.index1}

[]{#index.htm_pgfId-432203 .calibre17}[Bounding set of capabilities
194](#10.htm_marker-1114244){.index1}

[]{#index.htm_pgfId-432205 .calibre17}[BPF (Berkeley Packet Filter)
214](#10.htm_marker-1115138){.index1}

[]{#index.htm_pgfId-432207 .calibre17}[brew command
263](#E.htm_marker-1286447){.index1}

[]{#index.htm_pgfId-432209 .calibre17}[btrfs storage driver
95](#05.htm_marker-1108320){.index1}

[]{#index.htm_pgfId-432211 .calibre17}[Buildah
237](#A.htm_marker-1277860){.index1} --
[244](#A.htm_marker-1278258){.index1}

[]{#index.htm_pgfId-432214 .calibre17}[add command
239](#A.htm_marker-1277922){.index1}

[]{#index.htm_pgfId-432216 .calibre17}[adding content to working
container directly from host 240](#A.htm_marker-1278005){.index1} --
[241](#A.htm_marker-1278030){.index1}

[]{#index.htm_pgfId-432219 .calibre17}[adding data to working container
239](#A.htm_marker-1277920){.index1}

[]{#index.htm_pgfId-432221 .calibre17}[as library
244](#A.htm_marker-1278253){.index1}

[]{#index.htm_pgfId-432223 .calibre17}[build command
243](#A.htm_marker-1278216){.index1}

[]{#index.htm_pgfId-432225 .calibre17}[building images from
Containerfiles 243](#A.htm_marker-1278221){.index1} --
[244](#A.htm_marker-1278249){.index1}

[]{#index.htm_pgfId-432228 .calibre17}[commit command
242](#A.htm_marker-1278155){.index1}

[]{#index.htm_pgfId-432230 .calibre17}[config command
241](#A.htm_marker-1278041){.index1}

[]{#index.htm_pgfId-432232 .calibre17}[configuring working container
241](#A.htm_marker-1278034){.index1} --
[242](#A.htm_marker-1278148){.index1}

[]{#index.htm_pgfId-432235 .calibre17}[copy command
239](#A.htm_marker-1277921){.index1}

[]{#index.htm_pgfId-432237 .calibre17}[creating images from working
container 242](#A.htm_marker-1278153){.index1} --
[243](#A.htm_marker-1278184){.index1}

[]{#index.htm_pgfId-432240 .calibre17}[creating working container from
base image 238](#A.htm_marker-1282679){.index1} --
[239](#A.htm_marker-1277915){.index1}

[]{#index.htm_pgfId-432243 .calibre17}[from command
238](#A.htm_marker-1282679){.index1} --
[239](#A.htm_marker-1277908){.index1}

[]{#index.htm_pgfId-432246 .calibre17}[inspect command
241](#A.htm_marker-1281981){.index1}

[]{#index.htm_pgfId-432248 .calibre17}[login command
243](#A.htm_marker-1278193){.index1}

[]{#index.htm_pgfId-432250 .calibre17}[mount command
240](#A.htm_marker-1278008){.index1}

[]{#index.htm_pgfId-432252 .calibre17}[push command
243](#A.htm_marker-1278194){.index1}

[]{#index.htm_pgfId-432254 .calibre17}[pushing images to container
registry 243](#A.htm_marker-1278192){.index1}

[]{#index.htm_pgfId-432256 .calibre17}[running commands in working
container 239](#A.htm_marker-1277943){.index1} --
[240](#A.htm_marker-1277961){.index1}

[]{#index.htm_pgfId-432259 .calibre17}[unshare command
240](#A.htm_marker-1278016){.index1}

[]{#index.htm_pgfId-432261 .calibre17}[Buildah tool
237](#A.htm_marker-1277862){.index1}

[]{#index.htm_pgfId-432263 .calibre17}[command
234](#A.htm_marker-1282258){.index1}

[]{#index.htm_pgfId-432265 .calibre17}[management tool
7](#01.htm_marker-1036166){.index1}

[]{#index.htm_pgfId-432267 .calibre17}[build command
65](#02.htm_marker-1046087){.index1}

[]{#index.htm_pgfId-432269 .calibre17}[- -build flag
159](#08.htm_marker-1118891){.index1}

[]{#index.htm_pgfId-432271 .calibre17}[building images
60](#02.htm_marker-1038886){.index1} --
[65](#02.htm_marker-1039111){.index1}

[]{#index.htm_pgfId-432274 .calibre17}[automating building of
application 64](#02.htm_marker-1039050){.index1} --
[65](#02.htm_marker-1039108){.index1}

[]{#index.htm_pgfId-432277 .calibre17}[format of Containerfile or
Dockerfile 61](#02.htm_marker-1038899){.index1} --
[64](#02.htm_marker-1039045){.index1}

[]{#index.htm_pgfId-432280 .calibre17}[adding content to image
61](#02.htm_marker-1038905){.index1} --
[62](#02.htm_marker-1038928){.index1}

[]{#index.htm_pgfId-432283 .calibre17}[committing image
63](#02.htm_marker-1039033){.index1} --
[64](#02.htm_marker-1039041){.index1}

[]{#index.htm_pgfId-432286 .calibre17}[documenting how to use image
62](#02.htm_marker-1038933){.index1} --
[63](#02.htm_marker-1038975){.index1}

[]{#index.htm_pgfId-432289 .calibre17}[- -build option
160](#08.htm_marker-1118893){.index1}

[]{#index.htm_pgfId-432291 .calibre17}C[]{#index.htm_C .calibre17}

[]{#index.htm_pgfId-432293 .calibre17}capabilities

[]{#index.htm_pgfId-432294 .calibre17}[adding
197](#10.htm_marker-1114416){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-432297 .calibre17}[- -cap-add flag
197](#10.htm_marker-1114419){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-432300 .calibre17}[CAP_AUDIT_WRITE
155](#08.htm_marker-1118765){.index1},
[195](#10.htm_marker-1114291){.index1}

[]{#index.htm_pgfId-432303 .calibre17}[CAP_CHOWN option
115](#06.htm_marker-1110501){.index1},
[196](#10.htm_marker-1118968){.index1},
[201](#10.htm_marker-1114555){.index1}

[]{#index.htm_pgfId-432307 .calibre17}[CAP_DAC_OVERRIDE option
196](#10.htm_marker-1118969){.index1}

[]{#index.htm_pgfId-432309 .calibre17}[- -cap-drop flag
163](#08.htm_marker-1122583){.index1},
[197](#10.htm_marker-1114390){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-432313 .calibre17}[CAP_FOWNER option
196](#10.htm_marker-1118970){.index1}

[]{#index.htm_pgfId-432315 .calibre17}[CAP_KILL option
196](#10.htm_marker-1118972){.index1}

[]{#index.htm_pgfId-432317 .calibre17}[CAP_MKNOD option
155](#08.htm_marker-1118763){.index1},
[195](#10.htm_marker-1114290){.index1}

[]{#index.htm_pgfId-432320 .calibre17}[CAP_NET_ADMIN option
115](#06.htm_marker-1110500){.index1}

[]{#index.htm_pgfId-432322 .calibre17}[CAP_NET_BIND_SERVICE option
196](#10.htm_marker-1118973){.index1}

[]{#index.htm_pgfId-432324 .calibre17}[CAP_NET_RAW option
155](#08.htm_marker-1118764){.index1},
[195](#10.htm_marker-1114292){.index1}

[]{#index.htm_pgfId-432327 .calibre17}[CAP_SETFCAP option
196](#10.htm_marker-1118974){.index1}

[]{#index.htm_pgfId-432329 .calibre17}[CAP_SETFSID option
196](#10.htm_marker-1118971){.index1}

[]{#index.htm_pgfId-432331 .calibre17}[CAP_SETGID option
115](#06.htm_marker-1110499){.index1},
[196](#10.htm_marker-1118975){.index1}

[]{#index.htm_pgfId-432334 .calibre17}[CAP_SETUID option
115](#06.htm_marker-1110497){.index1},
[196](#10.htm_marker-1118977){.index1}

[]{#index.htm_pgfId-432337 .calibre17}[capsh program
194](#10.htm_marker-1114243){.index1} --
[195](#10.htm_marker-1114272){.index1}

[]{#index.htm_pgfId-432340 .calibre17}[CAP_SYS_ADMIN option
115](#06.htm_marker-1110509){.index1},
[163](#08.htm_marker-1121497){.index1},
[192](#10.htm_marker-1114142){.index1},
[196](#10.htm_marker-1122768){.index1},
[206](#10.htm_marker-1114741){.index1}

[]{#index.htm_pgfId-432346 .calibre17}[CAP_SYS_CHROOT option
196](#10.htm_marker-1118978){.index1}

[]{#index.htm_pgfId-432348 .calibre17}[dropped CAP_SYS_ADMIN
196](#10.htm_marker-1114372){.index1}

[]{#index.htm_pgfId-432350 .calibre17}[dropping
197](#10.htm_marker-1114387){.index1}

[]{#index.htm_pgfId-432352 .calibre17}[root without
198](#10.htm_marker-1114453){.index1}

[]{#index.htm_pgfId-432354 .calibre17}[user namespaced Linux
capabilities 201](#10.htm_marker-1114541){.index1} --
[202](#10.htm_marker-1114565){.index1}

[]{#index.htm_pgfId-432357 .calibre17}[CentOS
256](#C.htm_marker-1284849){.index1}

[]{#index.htm_pgfId-432359 .calibre17}[cgroupfs mount type
117](#06.htm_marker-1112575){.index1}

[]{#index.htm_pgfId-432361 .calibre17}[cgroups resource constraints
4](#01.htm_marker-1031558){.index1}

[]{#index.htm_pgfId-432363 .calibre17}[- -change option
40](#02.htm_marker-1037948){.index1}

[]{#index.htm_pgfId-432365 .calibre17}[checkpoint command
40](#02.htm_marker-1044867){.index1},
[248](#B.htm_marker-1284222){.index1}

[]{#index.htm_pgfId-432368 .calibre17}[chmod command
82](#04.htm_marker-1103856){.index1}

[]{#index.htm_pgfId-432370 .calibre17}[chown command
114](#06.htm_marker-1110465){.index1}

[]{#index.htm_pgfId-432372 .calibre17}[CI (continuous integration)
systems 153](#08.htm_marker-1118694){.index1},
[182](#09.htm_marker-1109969){.index1}

[]{#index.htm_pgfId-432375 .calibre17}[cleanup command
40](#02.htm_marker-1044868){.index1}

[]{#index.htm_pgfId-432377 .calibre17}[client machine
184](#09.htm_marker-1110072){.index1} --
[185](#09.htm_marker-1110085){.index1}

[]{#index.htm_pgfId-432380 .calibre17}[CMD instruction
40](#02.htm_marker-1037950){.index1},
[62](#02.htm_marker-1038936){.index1},
[241](#A.htm_marker-1278039){.index1}

[]{#index.htm_pgfId-432384 .calibre17}[cmd option
129](#07.htm_marker-1116219){.index1}

[]{#index.htm_pgfId-432386 .calibre17}coloring books

[]{#index.htm_pgfId-432387 .calibre17}[*Container Coloring Book*
190](#10.htm_marker-1114084){.index1}

[]{#index.htm_pgfId-432389 .calibre17}[*Container Commandos*
233](#A.htm_marker-1282235){.index1}

[]{#index.htm_pgfId-432391 .calibre17}[*SELinux Coloring Book*
208](#10.htm_marker-1125639){.index1}

[]{#index.htm_pgfId-432393 .calibre17}[command line
27](#02.htm_marker-1040231){.index1} --
[66](#02.htm_marker-1039283){.index1}

[]{#index.htm_pgfId-432396 .calibre17}[building images
60](#02.htm_marker-1038885){.index1} --
[65](#02.htm_marker-1039110){.index1}

[]{#index.htm_pgfId-432399 .calibre17}[automating building of
application 64](#02.htm_marker-1039049){.index1} --
[65](#02.htm_marker-1039107){.index1}

[]{#index.htm_pgfId-432402 .calibre17}[format of Containerfile or
Dockerfile 61](#02.htm_marker-1038898){.index1} --
[64](#02.htm_marker-1039044){.index1}

[]{#index.htm_pgfId-432405 .calibre17}[user-friendly, Podman
19](#01.htm_marker-1032036){.index1} --
[20](#01.htm_marker-1032050){.index1}

[]{#index.htm_pgfId-432408 .calibre17}[working with container images
41](#02.htm_marker-1038204){.index1} --
[60](#02.htm_marker-1038882){.index1}

[]{#index.htm_pgfId-432411 .calibre17}[differences between container and
image 42](#02.htm_marker-1038210){.index1} --
[44](#02.htm_marker-1038259){.index1}

[]{#index.htm_pgfId-432414 .calibre17}[inspecting images
45](#02.htm_marker-1038323){.index1} --
[46](#02.htm_marker-1038362){.index1}

[]{#index.htm_pgfId-432417 .calibre17}[listing images
44](#02.htm_marker-1038264){.index1} --
[45](#02.htm_marker-1038318){.index1}

[]{#index.htm_pgfId-432420 .calibre17}[logging into container registry
48](#02.htm_marker-1038458){.index1} --
[50](#02.htm_marker-1038509){.index1}

[]{#index.htm_pgfId-432423 .calibre17}[mounting images
59](#02.htm_marker-1038845){.index1} --
[60](#02.htm_marker-1038880){.index1}

[]{#index.htm_pgfId-432426 .calibre17}[pulling images
55](#02.htm_marker-1038660){.index1} --
[58](#02.htm_marker-1038810){.index1}

[]{#index.htm_pgfId-432429 .calibre17}[pushing images
46](#02.htm_marker-1038367){.index1} --
[48](#02.htm_marker-1045229){.index1}

[]{#index.htm_pgfId-432432 .calibre17}[removing images
53](#02.htm_marker-1038586){.index1} --
[55](#02.htm_marker-1038655){.index1}

[]{#index.htm_pgfId-432435 .calibre17}[searching for images
58](#02.htm_marker-1038815){.index1}

[]{#index.htm_pgfId-432437 .calibre17}[tagging images
50](#02.htm_marker-1038515){.index1} --
[52](#02.htm_marker-1038573){.index1}

[]{#index.htm_pgfId-432440 .calibre17}[working with containers
28](#02.htm_marker-1037548){.index1} --
[40](#02.htm_marker-1037967){.index1}

[]{#index.htm_pgfId-432443 .calibre17}[creating image from container
39](#02.htm_marker-1037919){.index1} --
[40](#02.htm_marker-1037965){.index1}

[]{#index.htm_pgfId-432446 .calibre17}[exec-ing into container
38](#02.htm_marker-1037866){.index1} --
[39](#02.htm_marker-1037914){.index1}

[]{#index.htm_pgfId-432449 .calibre17}[exploring containers
28](#02.htm_marker-1037554){.index1} --
[30](#02.htm_marker-1037617){.index1}

[]{#index.htm_pgfId-432452 .calibre17}[inspecting containers
36](#02.htm_marker-1037798){.index1} --
[37](#02.htm_marker-1037841){.index1}

[]{#index.htm_pgfId-432455 .calibre17}[listing containers
36](#02.htm_marker-1037768){.index1}

[]{#index.htm_pgfId-432457 .calibre17}[removing containers
37](#02.htm_marker-1037846){.index1} --
[38](#02.htm_marker-1037861){.index1}

[]{#index.htm_pgfId-432460 .calibre17}[running containerized application
30](#02.htm_marker-1037622){.index1} --
[34](#02.htm_marker-1037694){.index1}

[]{#index.htm_pgfId-432463 .calibre17}[starting containers
35](#02.htm_marker-1037740){.index1}

[]{#index.htm_pgfId-432465 .calibre17}[stopping containers
34](#02.htm_marker-1037699){.index1} --
[35](#02.htm_marker-1037735){.index1}

[]{#index.htm_pgfId-432468 .calibre17}[commands
277](#F.htm_marker-1289862){.index1}

[]{#index.htm_pgfId-432470 .calibre17}[adding data to working container
239](#A.htm_marker-1277919){.index1}

[]{#index.htm_pgfId-432472 .calibre17}[from base image command
238](#A.htm_marker-1282679){.index1} --
[239](#A.htm_marker-1277914){.index1}

[]{#index.htm_pgfId-432475 .calibre17}[running in working container
239](#A.htm_marker-1277942){.index1} --
[240](#A.htm_marker-1277960){.index1}

[]{#index.htm_pgfId-432478 .calibre17}[commit command
40](#02.htm_marker-1044869){.index1}

[]{#index.htm_pgfId-432480 .calibre17}[committing images
63](#02.htm_marker-1039032){.index1} --
[64](#02.htm_marker-1039040){.index1}

[]{#index.htm_pgfId-432483 .calibre17}[community, joining
259](#D.htm_marker-1286431){.index1} --
[260](#D.htm_marker-1286446){.index1}

[]{#index.htm_pgfId-432486 .calibre17}[compat API
174](#09.htm_marker-1109693){.index1},
[177](#09.htm_marker-1109835){.index1}

[]{#index.htm_pgfId-432489 .calibre17}[complete podman command
180](#09.htm_marker-1109930){.index1}

[]{#index.htm_pgfId-432491 .calibre17}[configuration files
89](#05.htm_marker-1111462){.index1} --
[105](#05.htm_marker-1106091){.index1}

[]{#index.htm_pgfId-432494 .calibre17}[for engines
100](#05.htm_marker-1108749){.index1} --
[103](#05.htm_marker-1106058){.index1}

[]{#index.htm_pgfId-432497 .calibre17}[for registries
96](#05.htm_marker-1105770){.index1} --
[100](#05.htm_marker-1105906){.index1}

[]{#index.htm_pgfId-432500 .calibre17}[for storage
91](#05.htm_marker-1105546){.index1} --
[96](#05.htm_marker-1105766){.index1}

[]{#index.htm_pgfId-432503 .calibre17}[storage drivers
94](#05.htm_marker-1105644){.index1} --
[96](#05.htm_marker-1105764){.index1}

[]{#index.htm_pgfId-432506 .calibre17}[storage location
91](#05.htm_marker-1109584){.index1} --
[94](#05.htm_marker-1105639){.index1}

[]{#index.htm_pgfId-432509 .calibre17}[system configuration files
104](#05.htm_marker-1108996){.index1} --
[105](#05.htm_marker-1108202){.index1}

[]{#index.htm_pgfId-432512 .calibre17}[conmon (container monitor) tool
121](#06.htm_marker-1110715){.index1},
[124](#06.htm_marker-1110767){.index1},
[138](#07.htm_marker-1110698){.index1},
[257](#C.htm_marker-1284988){.index1}

[]{#index.htm_pgfId-432517 .calibre17}[connection command
186](#09.htm_marker-1116332){.index1}

[]{#index.htm_pgfId-432519 .calibre17}[container engines
4](#01.htm_marker-1031535){.index1}

[]{#index.htm_pgfId-432521 .calibre17}[Containerfiles
61](#02.htm_marker-1038897){.index1} --
[64](#02.htm_marker-1039043){.index1},
[243](#A.htm_marker-1278220){.index1} --
[244](#A.htm_marker-1278248){.index1}

[]{#index.htm_pgfId-432526 .calibre17}[adding content to image
61](#02.htm_marker-1038904){.index1} --
[62](#02.htm_marker-1038927){.index1}

[]{#index.htm_pgfId-432529 .calibre17}[committing image
63](#02.htm_marker-1039031){.index1} --
[64](#02.htm_marker-1039039){.index1}

[]{#index.htm_pgfId-432532 .calibre17}[documenting how to use image
62](#02.htm_marker-1038932){.index1} --
[63](#02.htm_marker-1038974){.index1}

[]{#index.htm_pgfId-432535 .calibre17}[container_file_t type
209](#10.htm_marker-1114862){.index1}

[]{#index.htm_pgfId-432537 .calibre17}container images

[]{#index.htm_pgfId-432538 .calibre17}[building using Podman and
Kubernetes YAML files 159](#08.htm_marker-1118889){.index1} --
[162](#08.htm_marker-1118973){.index1}

[]{#index.htm_pgfId-432541 .calibre17}[command line working with
41](#02.htm_marker-1038203){.index1} --
[60](#02.htm_marker-1038881){.index1}

[]{#index.htm_pgfId-432544 .calibre17}[differences between container and
image 42](#02.htm_marker-1038209){.index1} --
[44](#02.htm_marker-1038258){.index1}

[]{#index.htm_pgfId-432547 .calibre17}[inspecting images
45](#02.htm_marker-1038322){.index1} --
[46](#02.htm_marker-1038361){.index1}

[]{#index.htm_pgfId-432550 .calibre17}[listing images
44](#02.htm_marker-1038263){.index1} --
[45](#02.htm_marker-1038317){.index1}

[]{#index.htm_pgfId-432553 .calibre17}[logging into container registry
48](#02.htm_marker-1038457){.index1} --
[50](#02.htm_marker-1038508){.index1}

[]{#index.htm_pgfId-432556 .calibre17}[mounting images
59](#02.htm_marker-1038844){.index1} --
[60](#02.htm_marker-1038879){.index1}

[]{#index.htm_pgfId-432559 .calibre17}[pulling images
55](#02.htm_marker-1038659){.index1} --
[58](#02.htm_marker-1038809){.index1}

[]{#index.htm_pgfId-432562 .calibre17}[pushing images
46](#02.htm_marker-1038366){.index1} --
[48](#02.htm_marker-1045228){.index1}

[]{#index.htm_pgfId-432565 .calibre17}[removing images
53](#02.htm_marker-1038585){.index1} --
[55](#02.htm_marker-1038654){.index1}

[]{#index.htm_pgfId-432568 .calibre17}[searching for images
58](#02.htm_marker-1038814){.index1}

[]{#index.htm_pgfId-432570 .calibre17}[tagging images
50](#02.htm_marker-1038514){.index1} --
[52](#02.htm_marker-1038572){.index1}

[]{#index.htm_pgfId-432573 .calibre17}[containing content owned by
multiple UIDs 110](#06.htm_marker-1113925){.index1} --
[117](#06.htm_marker-1110575){.index1}

[]{#index.htm_pgfId-432576 .calibre17}[mount namespace
115](#06.htm_marker-1110519){.index1} --
[116](#06.htm_marker-1110555){.index1}

[]{#index.htm_pgfId-432579 .calibre17}[user namespace
111](#06.htm_marker-1110395){.index1} --
[115](#06.htm_marker-1110513){.index1}

[]{#index.htm_pgfId-432582 .calibre17}[user namespace and mount
namespace 117](#06.htm_marker-1110563){.index1}

[]{#index.htm_pgfId-432584 .calibre17}[creating from container
39](#02.htm_marker-1037918){.index1} --
[40](#02.htm_marker-1037964){.index1}

[]{#index.htm_pgfId-432587 .calibre17}[creating images from working
container 242](#A.htm_marker-1278152){.index1} --
[243](#A.htm_marker-1278183){.index1}

[]{#index.htm_pgfId-432590 .calibre17}[format of
13](#01.htm_marker-1031714){.index1} --
[14](#01.htm_marker-1031791){.index1}

[]{#index.htm_pgfId-432593 .calibre17}[leading to microservices
11](#01.htm_marker-1031691){.index1}

[]{#index.htm_pgfId-432595 .calibre17}[overview
9](#01.htm_marker-1031666){.index1} --
[11](#01.htm_marker-1031680){.index1}

[]{#index.htm_pgfId-432598 .calibre17}[Podman image signing
224](#11.htm_marker-1121985){.index1} --
[227](#11.htm_marker-1126248){.index1}

[]{#index.htm_pgfId-432601 .calibre17}[configuring Podman to pull signed
images 226](#11.htm_marker-1122032){.index1} --
[227](#11.htm_marker-1126247){.index1}

[]{#index.htm_pgfId-432604 .calibre17}[signing and pushing image
225](#11.htm_marker-1122002){.index1}

[]{#index.htm_pgfId-432606 .calibre17}[pulling images
119](#06.htm_marker-1110667){.index1} --
[120](#06.htm_marker-1110678){.index1}

[]{#index.htm_pgfId-432609 .calibre17}container libraries

[]{#index.htm_pgfId-432610 .calibre17}[containers/buildah library
90](#05.htm_marker-1108163){.index1}

[]{#index.htm_pgfId-432612 .calibre17}[containers/common library
90](#05.htm_marker-1108162){.index1}

[]{#index.htm_pgfId-432614 .calibre17}[containers/image library
90](#05.htm_marker-1108161){.index1},
[236](#A.htm_marker-1277785){.index1}

[]{#index.htm_pgfId-432617 .calibre17}[containers/storage library
90](#05.htm_marker-1108160){.index1}

[]{#index.htm_pgfId-432619 .calibre17}[containers-common tool
257](#C.htm_marker-1284990){.index1}

[]{#index.htm_pgfId-432621 .calibre17}[containernetworking-plugins
257](#C.htm_marker-1284989){.index1}

[]{#index.htm_pgfId-432623 .calibre17}[container orchestrators
4](#01.htm_marker-1031534){.index1}

[]{#index.htm_pgfId-432625 .calibre17}[container runtimes
4](#01.htm_marker-1031536){.index1}

[]{#index.htm_pgfId-432627 .calibre17}[OCI container runtimes
246](#B.htm_marker-1285375){.index1} --
[253](#B.htm_marker-1285384){.index1}

[]{#index.htm_pgfId-432630 .calibre17}[containers
7](#01.htm_marker-1031593){.index1} --
[14](#01.htm_marker-1031805){.index1},
[237](#A.htm_marker-1277868){.index1}

[]{#index.htm_pgfId-432634 .calibre17}[adding to pods
81](#04.htm_marker-1103830){.index1} --
[83](#04.htm_marker-1103882){.index1}

[]{#index.htm_pgfId-432637 .calibre17}[command line working with
28](#02.htm_marker-1037547){.index1} --
[40](#02.htm_marker-1037966){.index1}

[]{#index.htm_pgfId-432640 .calibre17}[creating image from container
39](#02.htm_marker-1037917){.index1} --
[40](#02.htm_marker-1037963){.index1}

[]{#index.htm_pgfId-432643 .calibre17}[exec-ing into container
38](#02.htm_marker-1037865){.index1} --
[39](#02.htm_marker-1037913){.index1}

[]{#index.htm_pgfId-432646 .calibre17}[exploring containers
28](#02.htm_marker-1037553){.index1} --
[30](#02.htm_marker-1037616){.index1}

[]{#index.htm_pgfId-432649 .calibre17}[inspecting containers
36](#02.htm_marker-1037797){.index1} --
[37](#02.htm_marker-1037840){.index1}

[]{#index.htm_pgfId-432652 .calibre17}[listing containers
36](#02.htm_marker-1037767){.index1}

[]{#index.htm_pgfId-432654 .calibre17}[removing containers
37](#02.htm_marker-1037845){.index1} --
[38](#02.htm_marker-1037860){.index1}

[]{#index.htm_pgfId-432657 .calibre17}[running containerized application
30](#02.htm_marker-1037621){.index1} --
[34](#02.htm_marker-1037693){.index1}

[]{#index.htm_pgfId-432660 .calibre17}[starting containers
35](#02.htm_marker-1037739){.index1}

[]{#index.htm_pgfId-432662 .calibre17}[stopping containers
34](#02.htm_marker-1037698){.index1} --
[35](#02.htm_marker-1037734){.index1}

[]{#index.htm_pgfId-432665 .calibre17}[differences between images and
containers 42](#02.htm_marker-1038208){.index1} --
[44](#02.htm_marker-1038257){.index1}

[]{#index.htm_pgfId-432668 .calibre17}[generating from Kubernetes YAML
files 157](#08.htm_marker-1118802){.index1} --
[162](#08.htm_marker-1118977){.index1}

[]{#index.htm_pgfId-432671 .calibre17}[building images
159](#08.htm_marker-1118888){.index1} --
[162](#08.htm_marker-1118972){.index1}

[]{#index.htm_pgfId-432674 .calibre17}[shutting down pods and containers
158](#08.htm_marker-1118858){.index1} --
[159](#08.htm_marker-1118882){.index1}

[]{#index.htm_pgfId-432677 .calibre17}[reasons for using Podman
15](#01.htm_marker-1031812){.index1}

[]{#index.htm_pgfId-432679 .calibre17}[rolling back failed containers
after update 147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-432681 .calibre17}[rootless containers
16](#01.htm_marker-1031985){.index1} --
[17](#01.htm_marker-1031998){.index1}

[]{#index.htm_pgfId-432684 .calibre17}[running containers in notify unit
files 145](#07.htm_marker-1110960){.index1} --
[146](#07.htm_marker-1110977){.index1}

[]{#index.htm_pgfId-432687 .calibre17}[running Podman within
162](#08.htm_marker-1118981){.index1} --
[165](#08.htm_marker-1119116){.index1}

[]{#index.htm_pgfId-432690 .calibre17}[Kubernetes pod
164](#08.htm_marker-1119074){.index1} --
[165](#08.htm_marker-1119114){.index1}

[]{#index.htm_pgfId-432693 .calibre17}[Podman container
163](#08.htm_marker-1121494){.index1} --
[164](#08.htm_marker-1119070){.index1}

[]{#index.htm_pgfId-432696 .calibre17}[running systemd within
128](#07.htm_marker-1110310){.index1} --
[134](#07.htm_marker-1110501){.index1}

[]{#index.htm_pgfId-432699 .calibre17}[containerized systemd
requirements 131](#07.htm_marker-1110357){.index1}

[]{#index.htm_pgfId-432701 .calibre17}[Podman container in systemd mode
131](#07.htm_marker-1116576){.index1} --
[132](#07.htm_marker-1110437){.index1}

[]{#index.htm_pgfId-432704 .calibre17}[running Apache Service within
systemd container 132](#07.htm_marker-1110441){.index1} --
[134](#07.htm_marker-1110498){.index1}

[]{#index.htm_pgfId-432707 .calibre17}[socket-activated Podman
containers 147](#07.htm_marker-1110994){.index1} --
[149](#07.htm_marker-1111049){.index1}

[]{#index.htm_pgfId-432710 .calibre17}[standards
14](#01.htm_marker-1031795){.index1}

[]{#index.htm_pgfId-432712 .calibre17}[starting at boot
137](#07.htm_marker-1110635){.index1} --
[145](#07.htm_marker-1117753){.index1}

[]{#index.htm_pgfId-432715 .calibre17}[automatically updating Podman
containers 142](#07.htm_marker-1110845){.index1} --
[145](#07.htm_marker-1117751){.index1}

[]{#index.htm_pgfId-432718 .calibre17}[distributing systemd unit files
to manage Podman containers 141](#07.htm_marker-1110772){.index1} --
[142](#07.htm_marker-1110840){.index1}

[]{#index.htm_pgfId-432721 .calibre17}[Podman containers as systemd
services 138](#07.htm_marker-1110689){.index1} --
[141](#07.htm_marker-1110767){.index1}

[]{#index.htm_pgfId-432724 .calibre17}[restarting containers
137](#07.htm_marker-1110641){.index1}

[]{#index.htm_pgfId-432726 .calibre17}[using volumes with
68](#03.htm_marker-1048602){.index1} --
[74](#03.htm_marker-1053240){.index1}

[]{#index.htm_pgfId-432729 .calibre17}[named volumes
70](#03.htm_marker-1048658){.index1} --
[72](#03.htm_marker-1048728){.index1}

[]{#index.htm_pgfId-432732 .calibre17}[volume mount options
72](#03.htm_marker-1048733){.index1} --
[74](#03.htm_marker-1053225){.index1}

[]{#index.htm_pgfId-432735 .calibre17}[CONTAINERS_CONF environment
variable 101](#05.htm_marker-1105952){.index1}

[]{#index.htm_pgfId-432737 .calibre17}[containers-registries.conf(5) man
page 100](#05.htm_marker-1105897){.index1}

[]{#index.htm_pgfId-432739 .calibre17}[container-tools module
257](#C.htm_marker-1284953){.index1}

[]{#index.htm_pgfId-432741 .calibre17}[container_t process
210](#10.htm_marker-1114890){.index1}

[]{#index.htm_pgfId-432743 .calibre17}[container_t type
208](#10.htm_marker-1125639){.index1} --
[209](#10.htm_marker-1114867){.index1}

[]{#index.htm_pgfId-432746 .calibre17}[COPY instruction
61](#02.htm_marker-1038916){.index1},
[64](#02.htm_marker-1039066){.index1},
[239](#A.htm_marker-1277924){.index1} --
[240](#A.htm_marker-1282715){.index1}

[]{#index.htm_pgfId-432751 .calibre17}[core account
266](#E.htm_marker-1286569){.index1}

[]{#index.htm_pgfId-432753 .calibre17}[COW (copy-on-write) file systems
94](#05.htm_marker-1105654){.index1}

[]{#index.htm_pgfId-432755 .calibre17}[cp tool
40](#02.htm_marker-1044870){.index1},
[238](#A.htm_marker-1282679){.index1},
[240](#A.htm_marker-1278010){.index1}

[]{#index.htm_pgfId-432759 .calibre17}[- -cpus uint option
265](#E.htm_marker-1288339){.index1},
[275](#F.htm_marker-1291489){.index1}

[]{#index.htm_pgfId-432762 .calibre17}[create command
40](#02.htm_marker-1044871){.index1},
[86](#04.htm_marker-1107359){.index1},
[153](#08.htm_marker-1118713){.index1},
[221](#11.htm_marker-1125733){.index1},
[248](#B.htm_marker-1284223){.index1}

[]{#index.htm_pgfId-432768 .calibre17}[CREATED heading
44](#02.htm_marker-1044998){.index1}

[]{#index.htm_pgfId-432770 .calibre17}[credential helpers
49](#02.htm_marker-1038487){.index1}

[]{#index.htm_pgfId-432772 .calibre17}[CRI-O (Container Runtime
Interface for OCI containers) 244](#A.htm_marker-1278262){.index1} --
[245](#A.htm_marker-1278273){.index1}

[]{#index.htm_pgfId-432775 .calibre17}[CRI-O tool
234](#A.htm_marker-1282270){.index1}

[]{#index.htm_pgfId-432777 .calibre17}[crun runtime
4](#01.htm_marker-1031547){.index1},
[7](#01.htm_marker-1031582){.index1},
[14](#01.htm_marker-1031787){.index1},
[103](#05.htm_marker-1106036){.index1},
[121](#06.htm_marker-1110717){.index1},
[249](#B.htm_marker-1282957){.index1} --
[250](#B.htm_marker-1282971){.index1}

[]{#index.htm_pgfId-432785 .calibre17}[- -ctr\* option
85](#04.htm_marker-1103958){.index1}

[]{#index.htm_pgfId-432787 .calibre17}[- -ctr-names option
158](#08.htm_marker-1118833){.index1}

[]{#index.htm_pgfId-432789 .calibre17}[curl command
170](#09.htm_marker-1109509){.index1} --
[171](#09.htm_marker-1109594){.index1}

[]{#index.htm_pgfId-432792 .calibre17}[customizability
25](#01.htm_marker-1032213){.index1}

[]{#index.htm_pgfId-432794 .calibre17}D[]{#index.htm_D .calibre17}

[]{#index.htm_pgfId-432796 .calibre17}[DAC (discretionary access
control) 110](#06.htm_marker-1113928){.index1}

[]{#index.htm_pgfId-432798 .calibre17}[daemons
19](#01.htm_marker-1032028){.index1},
[217](#11.htm_marker-1121666){.index1} --
[220](#11.htm_marker-1121780){.index1}

[]{#index.htm_pgfId-432802 .calibre17}[access to docker.sock
217](#11.htm_marker-1121673){.index1}

[]{#index.htm_pgfId-432804 .calibre17}[auditing and logging
218](#11.htm_marker-1121707){.index1} --
[220](#11.htm_marker-1121776){.index1}

[]{#index.htm_pgfId-432807 .calibre17}[dangling images
54](#02.htm_marker-1038630){.index1}

[]{#index.htm_pgfId-432809 .calibre17}[-d (- -detach) option
31](#02.htm_marker-1037628){.index1}

[]{#index.htm_pgfId-432811 .calibre17}[Debian
256](#C.htm_marker-1284859){.index1}

[]{#index.htm_pgfId-432813 .calibre17}[default policy
224](#11.htm_marker-1121965){.index1}

[]{#index.htm_pgfId-432815 .calibre17}[delete command
248](#B.htm_marker-1284224){.index1}

[]{#index.htm_pgfId-432817 .calibre17}[- -detach (-d) mode
123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-432819 .calibre17}[devmapper storage driver
95](#05.htm_marker-1109998){.index1}

[]{#index.htm_pgfId-432821 .calibre17}[devpts mount type
117](#06.htm_marker-1112574){.index1}

[]{#index.htm_pgfId-432823 .calibre17}[df command
186](#09.htm_marker-1116339){.index1}

[]{#index.htm_pgfId-432825 .calibre17}[diff command
40](#02.htm_marker-1044872){.index1},
[65](#02.htm_marker-1046088){.index1}

[]{#index.htm_pgfId-432828 .calibre17}[dir transport
25](#01.htm_marker-1035272){.index1},
[47](#02.htm_marker-1045313){.index1},
[235](#A.htm_marker-1280408){.index1}

[]{#index.htm_pgfId-432832 .calibre17}[discretionary access control
(DAC) 110](#06.htm_marker-1113929){.index1}

[]{#index.htm_pgfId-432834 .calibre17}[- -disk-size uint option
265](#E.htm_marker-1288340){.index1},
[275](#F.htm_marker-1291490){.index1}

[]{#index.htm_pgfId-432837 .calibre17}[dnf tool
24](#01.htm_marker-1032146){.index1},
[133](#07.htm_marker-1110455){.index1},
[174](#09.htm_marker-1109696){.index1},
[240](#A.htm_marker-1278012){.index1}

[]{#index.htm_pgfId-432842 .calibre17}[docker-archive transport
25](#01.htm_marker-1035273){.index1},
[47](#02.htm_marker-1045314){.index1},
[236](#A.htm_marker-1280409){.index1}

[]{#index.htm_pgfId-432846 .calibre17}[docker-compose
176](#09.htm_marker-1116555){.index1} --
[180](#09.htm_marker-1109930){.index1}

[]{#index.htm_pgfId-432849 .calibre17}[compose command
179](#09.htm_marker-1109876){.index1}

[]{#index.htm_pgfId-432851 .calibre17}[compose tool
177](#09.htm_marker-1109826){.index1} --
[179](#09.htm_marker-1109874){.index1}

[]{#index.htm_pgfId-432854 .calibre17}[docker-daemon transport
25](#01.htm_marker-1035274){.index1},
[48](#02.htm_marker-1045315){.index1},
[236](#A.htm_marker-1280411){.index1}

[]{#index.htm_pgfId-432858 .calibre17}[Dockerfile (container file)
61](#02.htm_marker-1038896){.index1} --
[64](#02.htm_marker-1039042){.index1}

[]{#index.htm_pgfId-432861 .calibre17}[adding content to image
61](#02.htm_marker-1038903){.index1} --
[62](#02.htm_marker-1038926){.index1}

[]{#index.htm_pgfId-432864 .calibre17}[committing image
63](#02.htm_marker-1039030){.index1} --
[64](#02.htm_marker-1039038){.index1}

[]{#index.htm_pgfId-432867 .calibre17}[documenting how to use image
62](#02.htm_marker-1038931){.index1} --
[63](#02.htm_marker-1038973){.index1}

[]{#index.htm_pgfId-432870 .calibre17}[docker.from_env() function
174](#09.htm_marker-1109713){.index1}

[]{#index.htm_pgfId-432872 .calibre17}[DOCKER_HOST environment variable
174](#09.htm_marker-1109709){.index1} --
[176](#09.htm_marker-1109779){.index1},
[178](#09.htm_marker-1109844){.index1}

[]{#index.htm_pgfId-432876 .calibre17}[docker.io registry
56](#02.htm_marker-1045523){.index1}

[]{#index.htm_pgfId-432878 .calibre17}[docker-py
21](#01.htm_marker-1032056){.index1},
[174](#09.htm_marker-1114807){.index1} --
[175](#09.htm_marker-1109729){.index1}

[]{#index.htm_pgfId-432882 .calibre17}[docker rm command
17](#01.htm_marker-1031992){.index1}

[]{#index.htm_pgfId-432884 .calibre17}[docker.sock
217](#11.htm_marker-1121672){.index1}

[]{#index.htm_pgfId-432886 .calibre17}[docker transport
46](#02.htm_marker-1038378){.index1},
[236](#A.htm_marker-1277790){.index1}

[]{#index.htm_pgfId-432889 .calibre17}[- -down flag
159](#08.htm_marker-1118877){.index1}

[]{#index.htm_pgfId-432891 .calibre17}[drivers, storage
94](#05.htm_marker-1105643){.index1} --
[96](#05.htm_marker-1105763){.index1}

[]{#index.htm_pgfId-432894 .calibre17}[dropped Linux capabilities
195](#10.htm_marker-1114270){.index1} --
[196](#10.htm_marker-1122766){.index1}

[]{#index.htm_pgfId-432897 .calibre17}[- -dry-run option
145](#07.htm_marker-1110933){.index1}

[]{#index.htm_pgfId-432899 .calibre17}[Duffy, Máirín
190](#10.htm_marker-1114083){.index1},
[233](#A.htm_marker-1282237){.index1}

[]{#index.htm_pgfId-432902 .calibre17}[du -s command
249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-432904 .calibre17}E[]{#index.htm_E .calibre17}

[]{#index.htm_pgfId-432906 .calibre17}[engines, configuration files for
100](#05.htm_marker-1108748){.index1} --
[103](#05.htm_marker-1106057){.index1}

[]{#index.htm_pgfId-432909 .calibre17}[ENTRYPOINT instruction
40](#02.htm_marker-1037951){.index1},
[62](#02.htm_marker-1038935){.index1},
[241](#A.htm_marker-1278040){.index1}

[]{#index.htm_pgfId-432913 .calibre17}["/bin/sh -c" directive example
63](#02.htm_marker-1045746){.index1}

[]{#index.htm_pgfId-432915 .calibre17}[- -env-host option
183](#09.htm_marker-1116014){.index1}

[]{#index.htm_pgfId-432917 .calibre17}[ENV instruction
40](#02.htm_marker-1037952){.index1},
[62](#02.htm_marker-1038940){.index1},
[241](#A.htm_marker-1280878){.index1}

[]{#index.htm_pgfId-432921 .calibre17}events

[]{#index.htm_pgfId-432922 .calibre17}[events, journald
136](#07.htm_marker-1110577){.index1} --
[137](#07.htm_marker-1110629){.index1}

[]{#index.htm_pgfId-432925 .calibre17}[events command
248](#B.htm_marker-1284225){.index1}

[]{#index.htm_pgfId-432927 .calibre17}[events_logger option
136](#07.htm_marker-1110587){.index1}

[]{#index.htm_pgfId-432929 .calibre17}[example_myapp_vol volume
179](#09.htm_marker-1109877){.index1}

[]{#index.htm_pgfId-432931 .calibre17}[exec command
38](#02.htm_marker-1037864){.index1} --
[40](#02.htm_marker-1044873){.index1}

[]{#index.htm_pgfId-432934 .calibre17}[ExecStart command
139](#07.htm_marker-1110710){.index1},
[141](#07.htm_marker-1116822){.index1}

[]{#index.htm_pgfId-432937 .calibre17}[ExecStop command
139](#07.htm_marker-1110712){.index1},
[141](#07.htm_marker-1116824){.index1}

[]{#index.htm_pgfId-432940 .calibre17}[ExecStopPost command
141](#07.htm_marker-1116811){.index1}

[]{#index.htm_pgfId-432942 .calibre17}[ExecStopPost script
144](#07.htm_marker-1110888){.index1}

[]{#index.htm_pgfId-432944 .calibre17}[exec syscall
213](#10.htm_marker-1115112){.index1}

[]{#index.htm_pgfId-432946 .calibre17}[exists command
41](#02.htm_marker-1044874){.index1},
[65](#02.htm_marker-1046089){.index1},
[86](#04.htm_marker-1107360){.index1}

[]{#index.htm_pgfId-432950 .calibre17}[exit command
59](#02.htm_marker-1038854){.index1}

[]{#index.htm_pgfId-432952 .calibre17}[export command
41](#02.htm_marker-1044875){.index1}

[]{#index.htm_pgfId-432954 .calibre17}[EXPOSE instruction
40](#02.htm_marker-1037953){.index1},
[62](#02.htm_marker-1038939){.index1} --
[63](#02.htm_marker-1045747){.index1},
[241](#A.htm_marker-1278037){.index1} --
[242](#A.htm_marker-1280882){.index1}

[]{#index.htm_pgfId-432960 .calibre17}F[]{#index.htm_F .calibre17}

[]{#index.htm_pgfId-432962 .calibre17}[Fedora
256](#C.htm_marker-1284870){.index1},
[279](#F.htm_marker-1289928){.index1}

[]{#index.htm_pgfId-432965 .calibre17}[Fedora-CoreOS
256](#C.htm_marker-1284879){.index1}

[]{#index.htm_pgfId-432967 .calibre17}[fedora-coreos image
264](#E.htm_marker-1286504){.index1}

[]{#index.htm_pgfId-432969 .calibre17}[Fedora Silverblue
256](#C.htm_marker-1284880){.index1}

[]{#index.htm_pgfId-432971 .calibre17}[file system isolation
206](#10.htm_marker-1114737){.index1} --
[213](#10.htm_marker-1115098){.index1}

[]{#index.htm_pgfId-432974 .calibre17}[SELinux MCS separation
211](#10.htm_marker-1114959){.index1} --
[213](#10.htm_marker-1115094){.index1}

[]{#index.htm_pgfId-432977 .calibre17}[SELinux type enforcement
207](#10.htm_marker-1120091){.index1} --
[210](#10.htm_marker-1114951){.index1}

[]{#index.htm_pgfId-432980 .calibre17}[find command
228](#11.htm_marker-1122132){.index1}

[]{#index.htm_pgfId-432982 .calibre17}[force_mask storage driver
96](#05.htm_marker-1110087){.index1}

[]{#index.htm_pgfId-432984 .calibre17}[- -force option
38](#02.htm_marker-1037855){.index1},
[54](#02.htm_marker-1038623){.index1} --
[55](#02.htm_marker-1038648){.index1},
[69](#03.htm_marker-1048648){.index1},
[71](#03.htm_marker-1048704){.index1},
[86](#04.htm_marker-1103993){.index1}

[]{#index.htm_pgfId-432991 .calibre17}[fork/exec model
17](#01.htm_marker-1032009){.index1} --
[18](#01.htm_marker-1032024){.index1},
[217](#11.htm_marker-1121665){.index1} --
[220](#11.htm_marker-1121779){.index1}

[]{#index.htm_pgfId-432996 .calibre17}[access to docker.sock
217](#11.htm_marker-1121671){.index1}

[]{#index.htm_pgfId-432998 .calibre17}[auditing and logging
218](#11.htm_marker-1121706){.index1} --
[220](#11.htm_marker-1121775){.index1}

[]{#index.htm_pgfId-433001 .calibre17}[fork syscall
213](#10.htm_marker-1115111){.index1}

[]{#index.htm_pgfId-433003 .calibre17}[- -format option
37](#02.htm_marker-1037833){.index1},
[45](#02.htm_marker-1038345){.index1} --
[46](#02.htm_marker-1038355){.index1},
[58](#02.htm_marker-1038832){.index1},
[85](#04.htm_marker-1103960){.index1}

[]{#index.htm_pgfId-433009 .calibre17}[FROM instruction
61](#02.htm_marker-1038910){.index1},
[63](#02.htm_marker-1039035){.index1} --
[64](#02.htm_marker-1039065){.index1},
[238](#A.htm_marker-1282679){.index1},
[240](#A.htm_marker-1282722){.index1}

[]{#index.htm_pgfId-433015 .calibre17}[FUSE mount type
117](#06.htm_marker-1112576){.index1}

[]{#index.htm_pgfId-433017 .calibre17}[fuse-overlay driver
103](#05.htm_marker-1106041){.index1}

[]{#index.htm_pgfId-433019 .calibre17}[fuse-overlayfs executable
95](#05.htm_marker-1105705){.index1},
[120](#06.htm_marker-1110684){.index1}

[]{#index.htm_pgfId-433022 .calibre17}G[]{#index.htm_G .calibre17}

[]{#index.htm_pgfId-433024 .calibre17}[Gentoo
256](#C.htm_marker-1284890){.index1}

[]{#index.htm_pgfId-433026 .calibre17}[GIDs (group identifiers)
110](#06.htm_marker-1113926){.index1}

[]{#index.htm_pgfId-433028 .calibre17}[github.com
261](#D.htm_marker-1286451){.index1}

[]{#index.htm_pgfId-433030 .calibre17}[github.com/containers/podman
repository 261](#D.htm_marker-1286454){.index1}

[]{#index.htm_pgfId-433032 .calibre17}[github.com/containers/storage
library 91](#05.htm_marker-1105547){.index1}

[]{#index.htm_pgfId-433034 .calibre17}[github.com/containers projects
260](#D.htm_marker-1286443){.index1}

[]{#index.htm_pgfId-433036 .calibre17}[givisord container runtime
14](#01.htm_marker-1031789){.index1}

[]{#index.htm_pgfId-433038 .calibre17}[graphRoot storage location
91](#05.htm_marker-1105564){.index1}

[]{#index.htm_pgfId-433040 .calibre17}[- -group-add option
183](#09.htm_marker-1116020){.index1}

[]{#index.htm_pgfId-433042 .calibre17}[gVisor runtime
7](#01.htm_marker-1031582){.index1},
[252](#B.htm_marker-1283016){.index1} --
[253](#B.htm_marker-1283023){.index1}

[]{#index.htm_pgfId-433046 .calibre17}H[]{#index.htm_H .calibre17}

[]{#index.htm_pgfId-433048 .calibre17}[HEALTHCHECK instruction
242](#A.htm_marker-1280879){.index1}

[]{#index.htm_pgfId-433050 .calibre17}[history command
65](#02.htm_marker-1046090){.index1}

[]{#index.htm_pgfId-433052 .calibre17}[Homebrew
254](#C.htm_marker-1284786){.index1} --
[255](#C.htm_marker-1284799){.index1}

[]{#index.htm_pgfId-433055 .calibre17}[\$HOME environment variable
93](#05.htm_marker-1105623){.index1}

[]{#index.htm_pgfId-433057 .calibre17}[host, adding content from
240](#A.htm_marker-1278004){.index1} --
[241](#A.htm_marker-1278029){.index1}

[]{#index.htm_pgfId-433060 .calibre17}[HPC (high-performance computing)
95](#05.htm_marker-1105706){.index1},
[106](#06.htm_marker-1110291){.index1}

[]{#index.htm_pgfId-433063 .calibre17}[httpd service
133](#07.htm_marker-1110464){.index1},
[239](#A.htm_marker-1277946){.index1}

[]{#index.htm_pgfId-433066 .calibre17}[- -http-proxy option
183](#09.htm_marker-1116024){.index1}

[]{#index.htm_pgfId-433068 .calibre17}I[]{#index.htm_I .calibre17}

[]{#index.htm_pgfId-433070 .calibre17}[-identity option
185](#09.htm_marker-1110093){.index1}

[]{#index.htm_pgfId-433072 .calibre17}[idmap option
203](#10.htm_marker-1114619){.index1} --
[204](#10.htm_marker-1114634){.index1}

[]{#index.htm_pgfId-433075 .calibre17}[ignore_chown_errors option
95](#05.htm_marker-1105708){.index1} --
[96](#05.htm_marker-1110057){.index1}

[]{#index.htm_pgfId-433078 .calibre17}[- -ignore flag
154](#08.htm_marker-1121704){.index1}

[]{#index.htm_pgfId-433080 .calibre17}[IMAGE ID heading
44](#02.htm_marker-1044997){.index1}

[]{#index.htm_pgfId-433082 .calibre17}[- -image-path string option
265](#E.htm_marker-1288341){.index1},
[275](#F.htm_marker-1291491){.index1}

[]{#index.htm_pgfId-433085 .calibre17}[import command
66](#02.htm_marker-1046091){.index1}

[]{#index.htm_pgfId-433087 .calibre17}[info command
186](#09.htm_marker-1116346){.index1}

[]{#index.htm_pgfId-433089 .calibre17}[infra container
77](#04.htm_marker-1103758){.index1}

[]{#index.htm_pgfId-433091 .calibre17}[init command
41](#02.htm_marker-1044876){.index1},
[248](#B.htm_marker-1284226){.index1},
[264](#E.htm_marker-1288245){.index1} --
[265](#E.htm_marker-1286524){.index1},
[273](#F.htm_marker-1292520){.index1}

[]{#index.htm_pgfId-433097 .calibre17} -- init option 129

[]{#index.htm_pgfId-433099 .calibre17}[inode storage driver
96](#05.htm_marker-1110077){.index1}

[]{#index.htm_pgfId-433101 .calibre17}inspecting

[]{#index.htm_pgfId-433102 .calibre17}[containers
36](#02.htm_marker-1037796){.index1} --
[37](#02.htm_marker-1037839){.index1}

[]{#index.htm_pgfId-433105 .calibre17}[images
45](#02.htm_marker-1038321){.index1} --
[46](#02.htm_marker-1038360){.index1}

[]{#index.htm_pgfId-433108 .calibre17}[inspect command
41](#02.htm_marker-1044877){.index1},
[66](#02.htm_marker-1039267){.index1},
[86](#04.htm_marker-1107361){.index1},
[221](#11.htm_marker-1125734){.index1}

[]{#index.htm_pgfId-433113 .calibre17}[installing
254](#C.htm_marker-1285885){.index1} --
[257](#C.htm_marker-1284979){.index1}

[]{#index.htm_pgfId-433116 .calibre17}[Arch Linux and Manjaro Linux
256](#C.htm_marker-1284836){.index1}

[]{#index.htm_pgfId-433118 .calibre17}[CentOS
256](#C.htm_marker-1284848){.index1}

[]{#index.htm_pgfId-433120 .calibre17}[Debian
256](#C.htm_marker-1284858){.index1}

[]{#index.htm_pgfId-433122 .calibre17}[Fedora
256](#C.htm_marker-1284869){.index1}

[]{#index.htm_pgfId-433124 .calibre17}[Fedora-CoreOS, Fedora Silverblue
256](#C.htm_marker-1284878){.index1}

[]{#index.htm_pgfId-433126 .calibre17}[Gentoo
256](#C.htm_marker-1284889){.index1}

[]{#index.htm_pgfId-433128 .calibre17}[MacOS
254](#C.htm_marker-1284781){.index1} --
[255](#C.htm_marker-1284802){.index1}

[]{#index.htm_pgfId-433131 .calibre17}[OpenEmbedded
256](#C.htm_marker-1284899){.index1}

[]{#index.htm_pgfId-433133 .calibre17}[openSUSE
257](#C.htm_marker-1284910){.index1}

[]{#index.htm_pgfId-433135 .calibre17}[openSUSE Kubic
257](#C.htm_marker-1284919){.index1}

[]{#index.htm_pgfId-433137 .calibre17}[Raspberry Pi OS arm64
257](#C.htm_marker-1284928){.index1}

[]{#index.htm_pgfId-433139 .calibre17}[Red Hat Enterprise Linux
257](#C.htm_marker-1284940){.index1}

[]{#index.htm_pgfId-433141 .calibre17}[Ubuntu
257](#C.htm_marker-1284973){.index1}

[]{#index.htm_pgfId-433143 .calibre17}[Windows
255](#C.htm_marker-1284807){.index1} --
[256](#C.htm_marker-1284830){.index1},
[271](#F.htm_marker-1289622){.index1} --
[272](#F.htm_marker-1292574){.index1}

[]{#index.htm_pgfId-433148 .calibre17}[- -interactive (-i) option
34](#02.htm_marker-1037686){.index1} --
[35](#02.htm_marker-1037755){.index1},
[38](#02.htm_marker-1037870){.index1} --
[39](#02.htm_marker-1037906){.index1}

[]{#index.htm_pgfId-433153 .calibre17}[io.containers.autoupdate label
143](#07.htm_marker-1110884){.index1}

[]{#index.htm_pgfId-433155 .calibre17}[-i option
29](#02.htm_marker-1037562){.index1},
[39](#02.htm_marker-1037907){.index1}

[]{#index.htm_pgfId-433158 .calibre17}[IPC (inter-process communication)
namespace 206](#10.htm_marker-1123075){.index1}

[]{#index.htm_pgfId-433160 .calibre17}isolation

[]{#index.htm_pgfId-433161 .calibre17}[file system isolation
206](#10.htm_marker-1114736){.index1} --
[213](#10.htm_marker-1115097){.index1}

[]{#index.htm_pgfId-433164 .calibre17}[SELinux MCS separation
211](#10.htm_marker-1114958){.index1} --
[213](#10.htm_marker-1115093){.index1}

[]{#index.htm_pgfId-433167 .calibre17}[SELinux type enforcement
207](#10.htm_marker-1120090){.index1} --
[210](#10.htm_marker-1114950){.index1}

[]{#index.htm_pgfId-433170 .calibre17}[IPC (inter-process communication)
isolation 206](#10.htm_marker-1123074){.index1}

[]{#index.htm_pgfId-433172 .calibre17}[network isolation
205](#10.htm_marker-1114674){.index1}

[]{#index.htm_pgfId-433174 .calibre17}[process isolation
204](#10.htm_marker-1114648){.index1}

[]{#index.htm_pgfId-433176 .calibre17}[system call isolation
213](#10.htm_marker-1115105){.index1} --
[214](#10.htm_marker-1115146){.index1}

[]{#index.htm_pgfId-433179 .calibre17}[UID isolation
198](#10.htm_marker-1114464){.index1} --
[204](#10.htm_marker-1114643){.index1}

[]{#index.htm_pgfId-433182 .calibre17}[isolating containers using -
-userns=auto flag 199](#10.htm_marker-1114479){.index1} --
[200](#10.htm_marker-1114510){.index1}

[]{#index.htm_pgfId-433185 .calibre17}[rootless Podman with -
-userns=auto flag 202](#10.htm_marker-1114571){.index1}

[]{#index.htm_pgfId-433187 .calibre17}[user namespaced Linux
capabilities 201](#10.htm_marker-1114540){.index1} --
[202](#10.htm_marker-1114564){.index1}

[]{#index.htm_pgfId-433190 .calibre17}[user volumes with - -userns=auto
flag 202](#10.htm_marker-1114593){.index1} --
[204](#10.htm_marker-1114640){.index1}

[]{#index.htm_pgfId-433193 .calibre17}J[]{#index.htm_J .calibre17}

[]{#index.htm_pgfId-433195 .calibre17}[journald
134](#07.htm_marker-1110505){.index1} --
[137](#07.htm_marker-1110631){.index1}

[]{#index.htm_pgfId-433198 .calibre17}[events
136](#07.htm_marker-1110576){.index1} --
[137](#07.htm_marker-1110628){.index1}

[]{#index.htm_pgfId-433201 .calibre17}[log driver
135](#07.htm_marker-1110511){.index1} --
[136](#07.htm_marker-1110572){.index1}

[]{#index.htm_pgfId-433204 .calibre17}[jq command
171](#09.htm_marker-1109597){.index1}

[]{#index.htm_pgfId-433206 .calibre17}K[]{#index.htm_K .calibre17}

[]{#index.htm_pgfId-433208 .calibre17}[Kata container runtime
14](#01.htm_marker-1031788){.index1}

[]{#index.htm_pgfId-433210 .calibre17}[Kata containers
250](#B.htm_marker-1283890){.index1} --
[252](#B.htm_marker-1283008){.index1}

[]{#index.htm_pgfId-433213 .calibre17}[kill command
41](#02.htm_marker-1044878){.index1},
[86](#04.htm_marker-1107362){.index1},
[248](#B.htm_marker-1284227){.index1}

[]{#index.htm_pgfId-433217 .calibre17}Kubernetes

[]{#index.htm_pgfId-433218 .calibre17}[generating Podman pods and
containers from 157](#08.htm_marker-1118801){.index1} --
[162](#08.htm_marker-1118976){.index1}

[]{#index.htm_pgfId-433221 .calibre17}[building images
159](#08.htm_marker-1118887){.index1} --
[162](#08.htm_marker-1118971){.index1}

[]{#index.htm_pgfId-433224 .calibre17}[shutting down pods and containers
158](#08.htm_marker-1118857){.index1} --
[159](#08.htm_marker-1118881){.index1}

[]{#index.htm_pgfId-433227 .calibre17}[generating with Podman
153](#08.htm_marker-1118707){.index1} --
[157](#08.htm_marker-1118796){.index1}

[]{#index.htm_pgfId-433230 .calibre17}[Kubernetes YAML files
151](#08.htm_marker-1119983){.index1} --
[165](#08.htm_marker-1119125){.index1}

[]{#index.htm_pgfId-433233 .calibre17}[overview
153](#08.htm_marker-1118697){.index1}

[]{#index.htm_pgfId-433235 .calibre17}[running Podman within container
162](#08.htm_marker-1118980){.index1} --
[165](#08.htm_marker-1119115){.index1}

[]{#index.htm_pgfId-433238 .calibre17}[Kubernetes pod
164](#08.htm_marker-1119073){.index1} --
[165](#08.htm_marker-1119113){.index1}

[]{#index.htm_pgfId-433241 .calibre17}[Podman container
163](#08.htm_marker-1121493){.index1} --
[164](#08.htm_marker-1119069){.index1}

[]{#index.htm_pgfId-433244 .calibre17}[*Kubernetes for Developers*
(Denniss) 152](#08.htm_marker-1118687){.index1}

[]{#index.htm_pgfId-433246 .calibre17}[*Kubernetes in Action* (Lukša)
152](#08.htm_marker-1118684){.index1}

[]{#index.htm_pgfId-433248 .calibre17}[KVM (Kernel-based Virtual
Machine) 215](#10.htm_marker-1115153){.index1}

[]{#index.htm_pgfId-433250 .calibre17}L[]{#index.htm_L .calibre17}

[]{#index.htm_pgfId-433252 .calibre17}[LABEL instruction
40](#02.htm_marker-1037954){.index1},
[241](#A.htm_marker-1278036){.index1} --
[242](#A.htm_marker-1280880){.index1}

[]{#index.htm_pgfId-433256 .calibre17}[- -latest (-l) option
35](#02.htm_marker-1048907){.index1},
[37](#02.htm_marker-1037831){.index1},
[70](#03.htm_marker-1048652){.index1},
[84](#04.htm_marker-1103918){.index1} --
[85](#04.htm_marker-1103940){.index1},
[183](#09.htm_marker-1116039){.index1}

[]{#index.htm_pgfId-433263 .calibre17}[latest tag
56](#02.htm_marker-1045428){.index1}

[]{#index.htm_pgfId-433265 .calibre17}[layered file system
94](#05.htm_marker-1105652){.index1}

[]{#index.htm_pgfId-433267 .calibre17}[Linux capabilities
194](#10.htm_marker-1114240){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433270 .calibre17}[adding capabilities
197](#10.htm_marker-1114415){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433273 .calibre17}[dropped CAP_SYS_ADMIN
196](#10.htm_marker-1114371){.index1}

[]{#index.htm_pgfId-433275 .calibre17}[dropped Linux capabilities
195](#10.htm_marker-1114269){.index1} --
[196](#10.htm_marker-1122765){.index1}

[]{#index.htm_pgfId-433278 .calibre17}[dropping capabilities
197](#10.htm_marker-1114386){.index1}

[]{#index.htm_pgfId-433280 .calibre17}[no new privileges
198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433282 .calibre17}[root with no capabilities is
still dangerous 198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433284 .calibre17}[Linux kernel pseudo file systems
191](#10.htm_marker-1114102){.index1} --
[194](#10.htm_marker-1114236){.index1}

[]{#index.htm_pgfId-433287 .calibre17}[masking additional paths
193](#10.htm_marker-1114203){.index1} --
[194](#10.htm_marker-1114234){.index1}

[]{#index.htm_pgfId-433290 .calibre17}[unmasking masked paths
192](#10.htm_marker-1114168){.index1} --
[193](#10.htm_marker-1123820){.index1}

[]{#index.htm_pgfId-433293 .calibre17}[List command
66](#02.htm_marker-1046092){.index1},
[86](#04.htm_marker-1107363){.index1},
[248](#B.htm_marker-1284228){.index1},
[264](#E.htm_marker-1288246){.index1},
[273](#F.htm_marker-1292525){.index1}

[]{#index.htm_pgfId-433299 .calibre17}listing

[]{#index.htm_pgfId-433300 .calibre17}[containers
36](#02.htm_marker-1037766){.index1}

[]{#index.htm_pgfId-433302 .calibre17}[images
44](#02.htm_marker-1038262){.index1} --
[45](#02.htm_marker-1038316){.index1}

[]{#index.htm_pgfId-433305 .calibre17}[machines
278](#F.htm_marker-1289892){.index1}

[]{#index.htm_pgfId-433307 .calibre17}[pods
85](#04.htm_marker-1103950){.index1}

[]{#index.htm_pgfId-433309 .calibre17}[List (ps) command
41](#02.htm_marker-1044879){.index1}

[]{#index.htm_pgfId-433311 .calibre17}[load command
66](#02.htm_marker-1046093){.index1}

[]{#index.htm_pgfId-433313 .calibre17}[local connections
180](#09.htm_marker-1109930){.index1} --
[182](#09.htm_marker-1109972){.index1}

[]{#index.htm_pgfId-433316 .calibre17}[localhost registry
47](#02.htm_marker-1038392){.index1}

[]{#index.htm_pgfId-433318 .calibre17}[localhost tag
53](#02.htm_marker-1038600){.index1}

[]{#index.htm_pgfId-433320 .calibre17}[location, storage
91](#05.htm_marker-1109583){.index1} --
[94](#05.htm_marker-1105638){.index1}

[]{#index.htm_pgfId-433323 .calibre17}[logging
218](#11.htm_marker-1121705){.index1} --
[220](#11.htm_marker-1121774){.index1}

[]{#index.htm_pgfId-433326 .calibre17}[log_driver option
135](#07.htm_marker-1110555){.index1}

[]{#index.htm_pgfId-433328 .calibre17}[log drivers, journald
135](#07.htm_marker-1110510){.index1} --
[136](#07.htm_marker-1110571){.index1}

[]{#index.htm_pgfId-433331 .calibre17}[logs command
41](#02.htm_marker-1044880){.index1},
[86](#04.htm_marker-1107364){.index1}

[]{#index.htm_pgfId-433334 .calibre17}[ls command
221](#11.htm_marker-1125735){.index1}

[]{#index.htm_pgfId-433336 .calibre17}[ls -Z command
209](#10.htm_marker-1114873){.index1}

[]{#index.htm_pgfId-433338 .calibre17}[Lukša, Marko
152](#08.htm_marker-1118685){.index1}

[]{#index.htm_pgfId-433340 .calibre17}M[]{#index.htm_M .calibre17}

[]{#index.htm_pgfId-433342 .calibre17}[macOS
254](#C.htm_marker-1284780){.index1} --
[255](#C.htm_marker-1284801){.index1},
[262](#E.htm_marker-1288008){.index1} --
[268](#E.htm_marker-1286672){.index1}

[]{#index.htm_pgfId-433347 .calibre17}[Homebrew
254](#C.htm_marker-1284785){.index1} --
[255](#C.htm_marker-1284798){.index1}

[]{#index.htm_pgfId-433350 .calibre17}[using podman machine
263](#E.htm_marker-1286456){.index1} --
[268](#E.htm_marker-1286660){.index1}

[]{#index.htm_pgfId-433353 .calibre17}[podman machine SSH configuration
266](#E.htm_marker-1286566){.index1} --
[267](#E.htm_marker-1286598){.index1}

[]{#index.htm_pgfId-433356 .calibre17}[starting virtual machine
267](#E.htm_marker-1286604){.index1} --
[268](#E.htm_marker-1286643){.index1}

[]{#index.htm_pgfId-433359 .calibre17}[stopping virtual machine
268](#E.htm_marker-1286650){.index1}

[]{#index.htm_pgfId-433361 .calibre17}[make tool
238](#A.htm_marker-1282679){.index1},
[240](#A.htm_marker-1278011){.index1}

[]{#index.htm_pgfId-433364 .calibre17}[Manjaro Linux
256](#C.htm_marker-1284835){.index1}

[]{#index.htm_pgfId-433366 .calibre17}man pages

[]{#index.htm_pgfId-433367 .calibre17}[mount command
68](#03.htm_marker-1048598){.index1}

[]{#index.htm_pgfId-433369 .calibre17}[podman-build command
65](#02.htm_marker-1039106){.index1}

[]{#index.htm_pgfId-433371 .calibre17}[podman-commit command
40](#02.htm_marker-1037960){.index1}

[]{#index.htm_pgfId-433373 .calibre17}[podman-exec command
39](#02.htm_marker-1037909){.index1}

[]{#index.htm_pgfId-433375 .calibre17}[podman-image-inspect command
46](#02.htm_marker-1038357){.index1}

[]{#index.htm_pgfId-433377 .calibre17}[podman-image-prune command
55](#02.htm_marker-1038650){.index1}

[]{#index.htm_pgfId-433379 .calibre17}[podman-images command
45](#02.htm_marker-1038328){.index1}

[]{#index.htm_pgfId-433381 .calibre17}[podman-inspect command
37](#02.htm_marker-1037837){.index1}

[]{#index.htm_pgfId-433383 .calibre17}[podman-login command
49](#02.htm_marker-1038492){.index1}

[]{#index.htm_pgfId-433385 .calibre17}[podman-logout command
49](#02.htm_marker-1038501){.index1}

[]{#index.htm_pgfId-433387 .calibre17}[podman-ps command
36](#02.htm_marker-1037789){.index1}

[]{#index.htm_pgfId-433389 .calibre17}[podman-pull command
58](#02.htm_marker-1038802){.index1}

[]{#index.htm_pgfId-433391 .calibre17}[podman-rm command
38](#02.htm_marker-1037857){.index1}

[]{#index.htm_pgfId-433393 .calibre17}[podman-run command
34](#02.htm_marker-1037690){.index1}

[]{#index.htm_pgfId-433395 .calibre17}[podman-search command
58](#02.htm_marker-1038835){.index1}

[]{#index.htm_pgfId-433397 .calibre17}[podman-start command
35](#02.htm_marker-1037757){.index1}

[]{#index.htm_pgfId-433399 .calibre17}[podman-stop command
35](#02.htm_marker-1037730){.index1}

[]{#index.htm_pgfId-433401 .calibre17}[podman-system-prune command
45](#02.htm_marker-1038314){.index1}

[]{#index.htm_pgfId-433403 .calibre17}[mariadb container
73](#03.htm_marker-1048765){.index1}

[]{#index.htm_pgfId-433405 .calibre17}[mariadb image
73](#03.htm_marker-1048755){.index1}

[]{#index.htm_pgfId-433407 .calibre17}[masking paths
193](#10.htm_marker-1114202){.index1} --
[194](#10.htm_marker-1114233){.index1}

[]{#index.htm_pgfId-433410 .calibre17}[MCS (Multi-Category security)
separation, SELinux 211](#10.htm_marker-1114954){.index1} --
[213](#10.htm_marker-1115089){.index1}

[]{#index.htm_pgfId-433413 .calibre17}[- -memory integer option
265](#E.htm_marker-1288343){.index1},
[275](#F.htm_marker-1291492){.index1}

[]{#index.htm_pgfId-433416 .calibre17}[microservices
11](#01.htm_marker-1031690){.index1},
[128](#07.htm_marker-1110312){.index1}

[]{#index.htm_pgfId-433419 .calibre17}[migrate command
186](#09.htm_marker-1116353){.index1}

[]{#index.htm_pgfId-433421 .calibre17}[mkdir syscall
214](#10.htm_marker-1115119){.index1}

[]{#index.htm_pgfId-433423 .calibre17}[mount command
41](#02.htm_marker-1044881){.index1},
[66](#02.htm_marker-1046094){.index1}

[]{#index.htm_pgfId-433426 .calibre17}[mounting images
59](#02.htm_marker-1038843){.index1} --
[60](#02.htm_marker-1038878){.index1}

[]{#index.htm_pgfId-433429 .calibre17}[mount namespace
9](#01.htm_marker-1035526){.index1},
[115](#06.htm_marker-1110518){.index1} --
[117](#06.htm_marker-1110562){.index1},
[206](#10.htm_marker-1114735){.index1} --
[207](#10.htm_marker-1114748){.index1}

[]{#index.htm_pgfId-433435 .calibre17}[mount options, volume
72](#03.htm_marker-1048732){.index1} --
[74](#03.htm_marker-1053224){.index1}

[]{#index.htm_pgfId-433438 .calibre17}[SELinux volume options
73](#03.htm_marker-1048781){.index1} --
[74](#03.htm_marker-1053208){.index1}

[]{#index.htm_pgfId-433441 .calibre17}[U volume option
72](#03.htm_marker-1048743){.index1} --
[73](#03.htm_marker-1048776){.index1}

[]{#index.htm_pgfId-433444 .calibre17}[mount_program option
95](#05.htm_marker-1105703){.index1} --
[96](#05.htm_marker-1110062){.index1}

[]{#index.htm_pgfId-433447 .calibre17}[mqueue mount type
117](#06.htm_marker-1112578){.index1}

[]{#index.htm_pgfId-433449 .calibre17}[Multi-Category security (MCS)
separation, SELinux 211](#10.htm_marker-1114957){.index1} --
[213](#10.htm_marker-1115092){.index1}

[]{#index.htm_pgfId-433452 .calibre17}[myapp container
32](#02.htm_marker-1037672){.index1},
[38](#02.htm_marker-1037871){.index1} --
[40](#02.htm_marker-1037936){.index1},
[82](#04.htm_marker-1103843){.index1} --
[83](#04.htm_marker-1103900){.index1},
[109](#06.htm_marker-1110328){.index1},
[143](#07.htm_marker-1110867){.index1},
[154](#08.htm_marker-1121704){.index1},
[161](#08.htm_marker-1118967){.index1},
[178](#09.htm_marker-1109854){.index1}

[]{#index.htm_pgfId-433463 .calibre17}[myapp-new service
143](#07.htm_marker-1110881){.index1}

[]{#index.htm_pgfId-433465 .calibre17}[myapp-pod-myapp container
158](#08.htm_marker-1118823){.index1}

[]{#index.htm_pgfId-433467 .calibre17}[myapp-pod pod
154](#08.htm_marker-1121704){.index1},
[158](#08.htm_marker-1118821){.index1},
[161](#08.htm_marker-1118966){.index1}

[]{#index.htm_pgfId-433471 .calibre17}[myapp pods
156](#08.htm_marker-1118789){.index1}

[]{#index.htm_pgfId-433473 .calibre17}[myapp_vol volume
178](#09.htm_marker-1109855){.index1}

[]{#index.htm_pgfId-433475 .calibre17}[myimage application
71](#03.htm_marker-1048689){.index1}

[]{#index.htm_pgfId-433477 .calibre17}[myimage container
69](#03.htm_marker-1051591){.index1},
[71](#03.htm_marker-1051690){.index1}

[]{#index.htm_pgfId-433480 .calibre17}[myimage image
42](#02.htm_marker-1038221){.index1} --
[43](#02.htm_marker-1038239){.index1},
[46](#02.htm_marker-1038385){.index1}

[]{#index.htm_pgfId-433484 .calibre17}[mypod pod
80](#04.htm_marker-1103805){.index1},
[83](#04.htm_marker-1103871){.index1}

[]{#index.htm_pgfId-433487 .calibre17}[mysql user
73](#03.htm_marker-1048767){.index1}

[]{#index.htm_pgfId-433489 .calibre17}[mysystemd image
160](#08.htm_marker-1118904){.index1}

[]{#index.htm_pgfId-433491 .calibre17}[myuser user account
185](#09.htm_marker-1110094){.index1}

[]{#index.htm_pgfId-433493 .calibre17}N[]{#index.htm_N .calibre17}

[]{#index.htm_pgfId-433495 .calibre17}[named volumes
70](#03.htm_marker-1048657){.index1} --
[72](#03.htm_marker-1048727){.index1}

[]{#index.htm_pgfId-433498 .calibre17}[- -name myapp option
32](#02.htm_marker-1037651){.index1}

[]{#index.htm_pgfId-433500 .calibre17}[- -name option
239](#A.htm_marker-1277912){.index1}

[]{#index.htm_pgfId-433502 .calibre17}[namespaces
9](#01.htm_marker-1031651){.index1},
[42](#02.htm_marker-1038213){.index1}

[]{#index.htm_pgfId-433505 .calibre17}[net1 network
205](#10.htm_marker-1114677){.index1}

[]{#index.htm_pgfId-433507 .calibre17}[net2 network
205](#10.htm_marker-1114678){.index1}

[]{#index.htm_pgfId-433509 .calibre17}[network namespace
9](#01.htm_marker-1031652){.index1},
[205](#10.htm_marker-1114673){.index1}

[]{#index.htm_pgfId-433512 .calibre17}[- -network net1 option
205](#10.htm_marker-1114684){.index1}

[]{#index.htm_pgfId-433514 .calibre17}[networks
120](#06.htm_marker-1110696){.index1} --
[121](#06.htm_marker-1110705){.index1}

[]{#index.htm_pgfId-433517 .calibre17}[- -new flag
141](#07.htm_marker-1110774){.index1} --
[142](#07.htm_marker-1110810){.index1}

[]{#index.htm_pgfId-433520 .calibre17}[- -new option
141](#07.htm_marker-1116820){.index1} --
[142](#07.htm_marker-1114052){.index1}

[]{#index.htm_pgfId-433523 .calibre17}[nobody user
113](#06.htm_marker-1110433){.index1}

[]{#index.htm_pgfId-433525 .calibre17}[no new privileges option
198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433527 .calibre17}[no-new-privileges option
198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-433529 .calibre17}[notify service type
146](#07.htm_marker-1110962){.index1}

[]{#index.htm_pgfId-433531 .calibre17}[NOTIFY_SOCKET environment
variable 146](#07.htm_marker-1110966){.index1}

[]{#index.htm_pgfId-433533 .calibre17}[notify unit files
145](#07.htm_marker-1110959){.index1} --
[146](#07.htm_marker-1110976){.index1}

[]{#index.htm_pgfId-433536 .calibre17}[- -no-trunc option
58](#02.htm_marker-1038833){.index1}

[]{#index.htm_pgfId-433538 .calibre17}[nsenter tool
59](#02.htm_marker-1038856){.index1}

[]{#index.htm_pgfId-433540 .calibre17}O[]{#index.htm_O .calibre17}

[]{#index.htm_pgfId-433542 .calibre17}[oci-archive transport
25](#01.htm_marker-1035275){.index1},
[48](#02.htm_marker-1045317){.index1},
[236](#A.htm_marker-1280410){.index1}

[]{#index.htm_pgfId-433546 .calibre17}[OCI (Open Container Initiative)
runtimes 121](#06.htm_marker-1110731){.index1} --
[123](#06.htm_marker-1110753){.index1},
[246](#B.htm_marker-1282815){.index1} --
[253](#B.htm_marker-1283024){.index1}

[]{#index.htm_pgfId-433551 .calibre17}[crun
249](#B.htm_marker-1282957){.index1} --
[250](#B.htm_marker-1282970){.index1}

[]{#index.htm_pgfId-433554 .calibre17}[gVisor
252](#B.htm_marker-1283015){.index1} --
[253](#B.htm_marker-1283022){.index1}

[]{#index.htm_pgfId-433557 .calibre17}[Kata
250](#B.htm_marker-1283889){.index1} --
[252](#B.htm_marker-1283007){.index1}

[]{#index.htm_pgfId-433560 .calibre17}[runc
248](#B.htm_marker-1282855){.index1} --
[249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-433563 .calibre17}[oci transport
25](#01.htm_marker-1035271){.index1},
[47](#02.htm_marker-1045312){.index1},
[235](#A.htm_marker-1280407){.index1}

[]{#index.htm_pgfId-433567 .calibre17}[ONBUILD instruction
40](#02.htm_marker-1037955){.index1},
[63](#02.htm_marker-1045748){.index1},
[242](#A.htm_marker-1280881){.index1}

[]{#index.htm_pgfId-433571 .calibre17}[OpenEmbedded
256](#C.htm_marker-1284898){.index1}

[]{#index.htm_pgfId-433573 .calibre17}[openSUSE Kubic
257](#C.htm_marker-1284918){.index1}

[]{#index.htm_pgfId-433575 .calibre17}[open syscall
213](#10.htm_marker-1115108){.index1}

[]{#index.htm_pgfId-433577 .calibre17}[other permission
113](#06.htm_marker-1110449){.index1}

[]{#index.htm_pgfId-433579 .calibre17}[overlayfs mount type
117](#06.htm_marker-1112579){.index1}

[]{#index.htm_pgfId-433581 .calibre17}[overlay storage driver
94](#05.htm_marker-1105655){.index1} --
[95](#05.htm_marker-1108315){.index1}

[]{#index.htm_pgfId-433584 .calibre17}[overlay storage options
95](#05.htm_marker-1105700){.index1} --
[96](#05.htm_marker-1105761){.index1}

[]{#index.htm_pgfId-433587 .calibre17}P[]{#index.htm_P .calibre17}

[]{#index.htm_pgfId-433589 .calibre17}[pacman tool
256](#C.htm_marker-1284838){.index1}

[]{#index.htm_pgfId-433591 .calibre17}[pause command
41](#02.htm_marker-1044882){.index1},
[86](#04.htm_marker-1107365){.index1},
[248](#B.htm_marker-1284229){.index1}

[]{#index.htm_pgfId-433595 .calibre17}[- -pause option
40](#02.htm_marker-1037945){.index1}

[]{#index.htm_pgfId-433597 .calibre17}[- -pid=host flag
204](#10.htm_marker-1114651){.index1}

[]{#index.htm_pgfId-433599 .calibre17}[PID namespace
9](#01.htm_marker-1035529){.index1},
[204](#10.htm_marker-1114647){.index1}

[]{#index.htm_pgfId-433602 .calibre17}[- -pid option
204](#10.htm_marker-1114668){.index1}

[]{#index.htm_pgfId-433604 .calibre17}[pivot_root syscall
206](#10.htm_marker-1114740){.index1} --
[207](#10.htm_marker-1114742){.index1}

[]{#index.htm_pgfId-433607 .calibre17}[play command
157](#08.htm_marker-1118813){.index1}

[]{#index.htm_pgfId-433609 .calibre17}[pod.lists() function
176](#09.htm_marker-1109755){.index1}

[]{#index.htm_pgfId-433611 .calibre17}[Podman
3](#01.htm_marker-1033181){.index1} --
[26](#01.htm_marker-1032245){.index1},
[254](#C.htm_marker-1284763){.index1} --
[258](#C.htm_marker-1285010){.index1}

[]{#index.htm_pgfId-433616 .calibre17}[advanced stopping and restarting
279](#F.htm_marker-1289950){.index1}

[]{#index.htm_pgfId-433618 .calibre17}[building from source code
257](#C.htm_marker-1284986){.index1} --
[258](#C.htm_marker-1284992){.index1}

[]{#index.htm_pgfId-433621 .calibre17}[containers
7](#01.htm_marker-1031592){.index1} --
[14](#01.htm_marker-1031804){.index1}

[]{#index.htm_pgfId-433624 .calibre17}[as systemd services
138](#07.htm_marker-1110688){.index1} --
[141](#07.htm_marker-1110766){.index1}

[]{#index.htm_pgfId-433627 .calibre17}[automatically updating
142](#07.htm_marker-1110844){.index1} --
[145](#07.htm_marker-1117750){.index1}

[]{#index.htm_pgfId-433630 .calibre17}[container images
9](#01.htm_marker-1031665){.index1} --
[11](#01.htm_marker-1031679){.index1},
[13](#01.htm_marker-1031713){.index1} --
[14](#01.htm_marker-1031790){.index1}

[]{#index.htm_pgfId-433635 .calibre17}[container images leading to
microservices 11](#01.htm_marker-1031689){.index1}

[]{#index.htm_pgfId-433637 .calibre17}[distributing systemd unit files
to manage 141](#07.htm_marker-1110771){.index1} --
[142](#07.htm_marker-1110839){.index1}

[]{#index.htm_pgfId-433640 .calibre17}[in systemd mode
131](#07.htm_marker-1116575){.index1} --
[132](#07.htm_marker-1110436){.index1}

[]{#index.htm_pgfId-433643 .calibre17}[standards
14](#01.htm_marker-1031794){.index1}

[]{#index.htm_pgfId-433645 .calibre17}[contributing to
259](#D.htm_marker-1286423){.index1} --
[261](#D.htm_marker-1286470){.index1}

[]{#index.htm_pgfId-433648 .calibre17}[joining community
259](#D.htm_marker-1286430){.index1} --
[260](#D.htm_marker-1286445){.index1}

[]{#index.htm_pgfId-433651 .calibre17}[Podman on github.com
261](#D.htm_marker-1286450){.index1}

[]{#index.htm_pgfId-433653 .calibre17}[generating Kubernetes YAML files
with 153](#08.htm_marker-1118706){.index1} --
[157](#08.htm_marker-1118795){.index1}

[]{#index.htm_pgfId-433656 .calibre17}[generating pods and containers
from Kubernetes YAML files 157](#08.htm_marker-1118800){.index1} --
[162](#08.htm_marker-1118975){.index1}

[]{#index.htm_pgfId-433659 .calibre17}[building images
159](#08.htm_marker-1118886){.index1} --
[162](#08.htm_marker-1118970){.index1}

[]{#index.htm_pgfId-433662 .calibre17}[shutting down pods and containers
158](#08.htm_marker-1118856){.index1} --
[159](#08.htm_marker-1118880){.index1}

[]{#index.htm_pgfId-433665 .calibre17}[installing
254](#C.htm_marker-1285884){.index1} --
[257](#C.htm_marker-1284978){.index1}

[]{#index.htm_pgfId-433668 .calibre17}[Arch Linux and Manjaro Linux
256](#C.htm_marker-1284834){.index1}

[]{#index.htm_pgfId-433670 .calibre17}[CentOS
256](#C.htm_marker-1284847){.index1}

[]{#index.htm_pgfId-433672 .calibre17}[Debian
256](#C.htm_marker-1284857){.index1}

[]{#index.htm_pgfId-433674 .calibre17}[Fedora
256](#C.htm_marker-1284868){.index1}

[]{#index.htm_pgfId-433676 .calibre17}[Fedora-CoreOS, Fedora Silverblue
256](#C.htm_marker-1284877){.index1}

[]{#index.htm_pgfId-433678 .calibre17}[Gentoo
256](#C.htm_marker-1284888){.index1}

[]{#index.htm_pgfId-433680 .calibre17}[MacOS
254](#C.htm_marker-1284779){.index1} --
[255](#C.htm_marker-1284800){.index1}

[]{#index.htm_pgfId-433683 .calibre17}[OpenEmbedded
256](#C.htm_marker-1284897){.index1}

[]{#index.htm_pgfId-433685 .calibre17}[openSUSE
257](#C.htm_marker-1284908){.index1}

[]{#index.htm_pgfId-433687 .calibre17}[openSUSE Kubic
257](#C.htm_marker-1284917){.index1}

[]{#index.htm_pgfId-433689 .calibre17}[Raspberry Pi OS arm64
257](#C.htm_marker-1284927){.index1}

[]{#index.htm_pgfId-433691 .calibre17}[Red Hat Enterprise Linux
257](#C.htm_marker-1284939){.index1}

[]{#index.htm_pgfId-433693 .calibre17}[Ubuntu
257](#C.htm_marker-1284972){.index1}

[]{#index.htm_pgfId-433695 .calibre17}[Windows
255](#C.htm_marker-1284806){.index1} --
[256](#C.htm_marker-1284829){.index1}

[]{#index.htm_pgfId-433698 .calibre17}[Podman Desktop
258](#C.htm_marker-1284997){.index1}

[]{#index.htm_pgfId-433700 .calibre17}[reasons for using
15](#01.htm_marker-1031808){.index1} --
[26](#01.htm_marker-1032231){.index1}

[]{#index.htm_pgfId-433703 .calibre17}[complete customizability
25](#01.htm_marker-1032212){.index1}

[]{#index.htm_pgfId-433705 .calibre17}[customizable registries
23](#01.htm_marker-1039162){.index1} --
[24](#01.htm_marker-1032157){.index1}

[]{#index.htm_pgfId-433708 .calibre17}[fork/exec model
17](#01.htm_marker-1032008){.index1} --
[18](#01.htm_marker-1032023){.index1}

[]{#index.htm_pgfId-433711 .calibre17}[integration with systemd
21](#01.htm_marker-1032063){.index1} --
[22](#01.htm_marker-1032081){.index1}

[]{#index.htm_pgfId-433714 .calibre17}[multiple transports
25](#01.htm_marker-1032161){.index1}

[]{#index.htm_pgfId-433716 .calibre17}[Podman is daemonless
19](#01.htm_marker-1032027){.index1}

[]{#index.htm_pgfId-433718 .calibre17}[pods
22](#01.htm_marker-1032091){.index1} --
[23](#01.htm_marker-1032097){.index1}

[]{#index.htm_pgfId-433721 .calibre17}[rootless containers
16](#01.htm_marker-1031984){.index1} --
[17](#01.htm_marker-1031997){.index1}

[]{#index.htm_pgfId-433724 .calibre17}[support for REST API
21](#01.htm_marker-1032054){.index1}

[]{#index.htm_pgfId-433726 .calibre17}[user-friendly command line
19](#01.htm_marker-1032035){.index1} --
[20](#01.htm_marker-1032050){.index1}

[]{#index.htm_pgfId-433729 .calibre17}[user namespace support
26](#01.htm_marker-1032225){.index1}

[]{#index.htm_pgfId-433731 .calibre17}[why have only one way to run
containers 15](#01.htm_marker-1031811){.index1}

[]{#index.htm_pgfId-433733 .calibre17}[start options
35](#02.htm_marker-1037751){.index1}

[]{#index.htm_pgfId-433735 .calibre17}[terms
4](#01.htm_marker-1031532){.index1} --
[7](#01.htm_marker-1031589){.index1}

[]{#index.htm_pgfId-433738 .calibre17}[when not to use
26](#01.htm_marker-1032234){.index1}

[]{#index.htm_pgfId-433740 .calibre17}[Pod Manager
4](#01.htm_marker-1031555){.index1},
[77](#04.htm_marker-1103752){.index1}

[]{#index.htm_pgfId-433743 .calibre17}[Podman as a service
166](#09.htm_marker-1111843){.index1} --
[186](#09.htm_marker-1110198){.index1}

[]{#index.htm_pgfId-433746 .calibre17}[overview
167](#09.htm_marker-1115468){.index1} --
[171](#09.htm_marker-1109562){.index1}

[]{#index.htm_pgfId-433749 .calibre17}[podman - -remote command
180](#09.htm_marker-1109930){.index1} --
[185](#09.htm_marker-1116225){.index1}

[]{#index.htm_pgfId-433752 .calibre17}[configuring connection
185](#09.htm_marker-1110089){.index1}

[]{#index.htm_pgfId-433754 .calibre17}[local connections
180](#09.htm_marker-1109930){.index1} --
[182](#09.htm_marker-1109971){.index1}

[]{#index.htm_pgfId-433757 .calibre17}[remote connections
182](#09.htm_marker-1112092){.index1} --
[184](#09.htm_marker-1110066){.index1}

[]{#index.htm_pgfId-433760 .calibre17}[setting up SSH on client machine
184](#09.htm_marker-1110071){.index1} --
[185](#09.htm_marker-1110084){.index1}

[]{#index.htm_pgfId-433763 .calibre17}[Podman-supported APIs
171](#09.htm_marker-1109566){.index1} --
[173](#09.htm_marker-1109679){.index1}

[]{#index.htm_pgfId-433766 .calibre17}[Python libraries for interacting
with Podman 173](#09.htm_marker-1109684){.index1} --
[177](#09.htm_marker-1109819){.index1}

[]{#index.htm_pgfId-433769 .calibre17}[using docker-py with Podman API
174](#09.htm_marker-1114806){.index1} --
[175](#09.htm_marker-1109728){.index1}

[]{#index.htm_pgfId-433772 .calibre17}[using podman-py with Podman API
175](#09.htm_marker-1109734){.index1} --
[176](#09.htm_marker-1109773){.index1}

[]{#index.htm_pgfId-433775 .calibre17}[which Python library to use
176](#09.htm_marker-1109777){.index1} --
[177](#09.htm_marker-1109817){.index1}

[]{#index.htm_pgfId-433778 .calibre17}[systemd services
168](#09.htm_marker-1112574){.index1} --
[171](#09.htm_marker-1109561){.index1}

[]{#index.htm_pgfId-433781 .calibre17}[using docker-compose with
177](#09.htm_marker-1109822){.index1} --
[180](#09.htm_marker-1109930){.index1}

[]{#index.htm_pgfId-433784 .calibre17}[podman attach command
123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-433786 .calibre17}[podman auto-update command
143](#07.htm_marker-1110883){.index1} --
[144](#07.htm_marker-1110901){.index1},
[147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-433790 .calibre17}[podman auto-update options
145](#07.htm_marker-1110931){.index1}

[]{#index.htm_pgfId-433792 .calibre17}[podman build command
60](#02.htm_marker-1048537){.index1} --
[61](#02.htm_marker-1038908){.index1},
[64](#02.htm_marker-1039080){.index1} --
[65](#02.htm_marker-1039100){.index1},
[237](#A.htm_marker-1277871){.index1},
[244](#A.htm_marker-1278245){.index1}

[]{#index.htm_pgfId-433799 .calibre17}[podman command
29](#02.htm_marker-1037572){.index1},
[31](#02.htm_marker-1037625){.index1},
[180](#09.htm_marker-1109930){.index1},
[262](#E.htm_marker-1288014){.index1},
[267](#E.htm_marker-1286606){.index1},
[269](#F.htm_marker-1290864){.index1},
[272](#F.htm_marker-1289632){.index1}

[]{#index.htm_pgfId-433807 .calibre17}[podman commit command
39](#02.htm_marker-1049110){.index1} --
[40](#02.htm_marker-1037940){.index1},
[242](#A.htm_marker-1278156){.index1}

[]{#index.htm_pgfId-433811 .calibre17}[podman commit options
40](#02.htm_marker-1037943){.index1}

[]{#index.htm_pgfId-433813 .calibre17}[podman-container(1) man pages
40](#02.htm_marker-1037969){.index1}

[]{#index.htm_pgfId-433815 .calibre17}[podman container cleanup command
124](#06.htm_marker-1110775){.index1}

[]{#index.htm_pgfId-433817 .calibre17}[podman container cleanup \$CTRID
command 121](#06.htm_marker-1110719){.index1},
[124](#06.htm_marker-1110772){.index1}

[]{#index.htm_pgfId-433820 .calibre17}[podman container create command
80](#04.htm_marker-1103812){.index1}

[]{#index.htm_pgfId-433822 .calibre17}[podman container inspect command
36](#02.htm_marker-1037804){.index1}

[]{#index.htm_pgfId-433824 .calibre17}[podman create command
32](#02.htm_marker-1037674){.index1},
[81](#04.htm_marker-1103831){.index1}

[]{#index.htm_pgfId-433827 .calibre17}[Podman Desktop
258](#C.htm_marker-1284996){.index1}

[]{#index.htm_pgfId-433829 .calibre17}[podman-docker package
20](#01.htm_marker-1032050){.index1},
[175](#09.htm_marker-1109724){.index1}

[]{#index.htm_pgfId-433832 .calibre17}[podman exec command
38](#02.htm_marker-1037869){.index1},
[68](#03.htm_marker-1048604){.index1}

[]{#index.htm_pgfId-433835 .calibre17}[podman exec options
39](#02.htm_marker-1037902){.index1}

[]{#index.htm_pgfId-433837 .calibre17}[podman generate kube command
22](#01.htm_marker-1032093){.index1},
[153](#08.htm_marker-1118703){.index1} --
[154](#08.htm_marker-1121704){.index1},
[158](#08.htm_marker-1118820){.index1}

[]{#index.htm_pgfId-433842 .calibre17}[podman generate kube myapp
command 154](#08.htm_marker-1121704){.index1}

[]{#index.htm_pgfId-433844 .calibre17}[podman image diff podman command
43](#02.htm_marker-1038242){.index1}

[]{#index.htm_pgfId-433846 .calibre17}[podman image inspect command
45](#02.htm_marker-1038327){.index1}

[]{#index.htm_pgfId-433848 .calibre17}[podman image inspect options
46](#02.htm_marker-1038353){.index1}

[]{#index.htm_pgfId-433850 .calibre17}[podman image mount command
59](#02.htm_marker-1038847){.index1},
[228](#11.htm_marker-1122127){.index1}

[]{#index.htm_pgfId-433853 .calibre17}[podman image options
44](#02.htm_marker-1038310){.index1}

[]{#index.htm_pgfId-433855 .calibre17}[podman image prune command
54](#02.htm_marker-1038629){.index1},
[65](#02.htm_marker-1039101){.index1}

[]{#index.htm_pgfId-433858 .calibre17}[podman image prune options
54](#02.htm_marker-1038644){.index1}

[]{#index.htm_pgfId-433860 .calibre17}[podman images command
44](#02.htm_marker-1038266){.index1},
[50](#02.htm_marker-1038518){.index1}

[]{#index.htm_pgfId-433863 .calibre17}[podman image subcommands
60](#02.htm_marker-1038875){.index1}

[]{#index.htm_pgfId-433865 .calibre17}[podman image tree command
43](#02.htm_marker-1038241){.index1},
[45](#02.htm_marker-1038325){.index1}

[]{#index.htm_pgfId-433868 .calibre17}[Podman image trust command
221](#11.htm_marker-1121865){.index1} --
[227](#11.htm_marker-1126250){.index1}

[]{#index.htm_pgfId-433871 .calibre17}[podman image trust command
221](#11.htm_marker-1121867){.index1} --
[222](#11.htm_marker-1121872){.index1}

[]{#index.htm_pgfId-433874 .calibre17}[podman image trust show command
223](#11.htm_marker-1121950){.index1}

[]{#index.htm_pgfId-433876 .calibre17}[podman info command
57](#02.htm_marker-1038763){.index1},
[91](#05.htm_marker-1105554){.index1} --
[92](#05.htm_marker-1105589){.index1}

[]{#index.htm_pgfId-433880 .calibre17}[podman inspect command
13](#01.htm_marker-1031723){.index1},
[36](#02.htm_marker-1037801){.index1} --
[37](#02.htm_marker-1037817){.index1},
[45](#02.htm_marker-1038329){.index1}

[]{#index.htm_pgfId-433885 .calibre17}[podman inspect options
37](#02.htm_marker-1037829){.index1}

[]{#index.htm_pgfId-433887 .calibre17}[podman kill command
35](#02.htm_marker-1037715){.index1}

[]{#index.htm_pgfId-433889 .calibre17}[podman login command
48](#02.htm_marker-1038469){.index1} --
[49](#02.htm_marker-1038484){.index1}

[]{#index.htm_pgfId-433892 .calibre17}[podman logs command
134](#07.htm_marker-1110493){.index1}

[]{#index.htm_pgfId-433894 .calibre17}[podman machine
273](#F.htm_marker-1293022){.index1} --
[275](#F.htm_marker-1289738){.index1}

[]{#index.htm_pgfId-433897 .calibre17}[macOS
263](#E.htm_marker-1286455){.index1} --
[268](#E.htm_marker-1286659){.index1}

[]{#index.htm_pgfId-433900 .calibre17}[podman machine SSH configuration
266](#E.htm_marker-1286565){.index1} --
[267](#E.htm_marker-1286597){.index1}

[]{#index.htm_pgfId-433903 .calibre17}[starting VM (virtual machine)
267](#E.htm_marker-1286603){.index1} --
[268](#E.htm_marker-1286642){.index1}

[]{#index.htm_pgfId-433906 .calibre17}[stopping VM (virtual machine)
268](#E.htm_marker-1286649){.index1}

[]{#index.htm_pgfId-433908 .calibre17}[Windows
272](#F.htm_marker-1292507){.index1} --
[279](#F.htm_marker-1289963){.index1}

[]{#index.htm_pgfId-433911 .calibre17}[advanced stopping and restarting
279](#F.htm_marker-1289949){.index1}

[]{#index.htm_pgfId-433913 .calibre17}[listing machines
278](#F.htm_marker-1289891){.index1}

[]{#index.htm_pgfId-433915 .calibre17}[Podman machine init
273](#F.htm_marker-1293021){.index1} --
[275](#F.htm_marker-1289737){.index1}

[]{#index.htm_pgfId-433918 .calibre17}[Podman machine SSH configuration
275](#F.htm_marker-1289777){.index1} --
[276](#F.htm_marker-1289809){.index1}

[]{#index.htm_pgfId-433921 .calibre17}[starting WSL 2 instance
276](#F.htm_marker-1289814){.index1} --
[277](#F.htm_marker-1289857){.index1}

[]{#index.htm_pgfId-433924 .calibre17}[stopping WSL 2 instance
277](#F.htm_marker-1289873){.index1}

[]{#index.htm_pgfId-433926 .calibre17}[updating Fedora
279](#F.htm_marker-1289927){.index1}

[]{#index.htm_pgfId-433928 .calibre17}[using Podman at WSL prompt
278](#F.htm_marker-1289908){.index1}

[]{#index.htm_pgfId-433930 .calibre17}[using podman machine commands
277](#F.htm_marker-1289861){.index1}

[]{#index.htm_pgfId-433932 .calibre17}[podman machine init command
256](#C.htm_marker-1284825){.index1},
[262](#E.htm_marker-1288011){.index1} --
[264](#E.htm_marker-1286502){.index1},
[266](#E.htm_marker-1286567){.index1},
[269](#F.htm_marker-1292811){.index1},
[272](#F.htm_marker-1292570){.index1} --
[275](#F.htm_marker-1289740){.index1}

[]{#index.htm_pgfId-433940 .calibre17}[podman machine list command
265](#E.htm_marker-1286555){.index1}

[]{#index.htm_pgfId-433942 .calibre17}[podman machine ls command
278](#F.htm_marker-1289893){.index1}

[]{#index.htm_pgfId-433944 .calibre17}[podman machine rm command
279](#F.htm_marker-1289930){.index1}

[]{#index.htm_pgfId-433946 .calibre17}[podman machine set command
276](#F.htm_marker-1289793){.index1}

[]{#index.htm_pgfId-433948 .calibre17}[podman machine ssh command
91](#05.htm_marker-1105551){.index1},
[222](#11.htm_marker-1121870){.index1},
[278](#F.htm_marker-1289909){.index1}

[]{#index.htm_pgfId-433952 .calibre17}[podman machine start/stop
commands 262](#E.htm_marker-1288016){.index1},
[269](#F.htm_marker-1290867){.index1}

[]{#index.htm_pgfId-433955 .calibre17}[podman machine start command
267](#E.htm_marker-1286615){.index1} --
[268](#E.htm_marker-1286661){.index1},
[276](#F.htm_marker-1289824){.index1} --
[277](#F.htm_marker-1289882){.index1},
[279](#F.htm_marker-1289953){.index1}

[]{#index.htm_pgfId-433961 .calibre17}[podman machine stop command
268](#E.htm_marker-1286651){.index1},
[277](#F.htm_marker-1289875){.index1},
[279](#F.htm_marker-1289952){.index1}

[]{#index.htm_pgfId-433965 .calibre17}[podman mount command
240](#A.htm_marker-1278015){.index1}

[]{#index.htm_pgfId-433967 .calibre17}[podman network create command
205](#10.htm_marker-1114676){.index1}

[]{#index.htm_pgfId-433969 .calibre17}[podman package
256](#C.htm_marker-1284860){.index1} --
[257](#C.htm_marker-1284974){.index1}

[]{#index.htm_pgfId-433972 .calibre17}[podman pause process
105](#05.htm_marker-1108199){.index1},
[118](#06.htm_marker-1110642){.index1}

[]{#index.htm_pgfId-433975 .calibre17}[podman play kube - -build command
161](#08.htm_marker-1118946){.index1}

[]{#index.htm_pgfId-433977 .calibre17}[podman play kube command
23](#01.htm_marker-1032095){.index1},
[156](#08.htm_marker-1118790){.index1} --
[157](#08.htm_marker-1118804){.index1}

[]{#index.htm_pgfId-433981 .calibre17}[podman play kube - -down command
158](#08.htm_marker-1118860){.index1}

[]{#index.htm_pgfId-433983 .calibre17}[podman pod create command
80](#04.htm_marker-1103806){.index1}

[]{#index.htm_pgfId-433985 .calibre17}[podman pod list command
85](#04.htm_marker-1103951){.index1}

[]{#index.htm_pgfId-433987 .calibre17}[podman pod ps command
158](#08.htm_marker-1118831){.index1} --
[159](#08.htm_marker-1118867){.index1}

[]{#index.htm_pgfId-433990 .calibre17}[podman pod rm - -all - -force
command 161](#08.htm_marker-1118936){.index1}

[]{#index.htm_pgfId-433992 .calibre17}[podman pod rm command
85](#04.htm_marker-1103970){.index1}

[]{#index.htm_pgfId-433994 .calibre17}[podman pod start command
83](#04.htm_marker-1103887){.index1}

[]{#index.htm_pgfId-433996 .calibre17}[podman pod stop command
84](#04.htm_marker-1103928){.index1},
[158](#08.htm_marker-1118851){.index1}

[]{#index.htm_pgfId-433999 .calibre17}[podman port command
31](#02.htm_marker-1037638){.index1}

[]{#index.htm_pgfId-434001 .calibre17}[podman ps -a command
180](#09.htm_marker-1109930){.index1}

[]{#index.htm_pgfId-434003 .calibre17}[podman ps command
20](#01.htm_marker-1032050){.index1},
[36](#02.htm_marker-1037770){.index1},
[83](#04.htm_marker-1103891){.index1} --
[84](#04.htm_marker-1103932){.index1},
[158](#08.htm_marker-1118838){.index1}

[]{#index.htm_pgfId-434009 .calibre17}[podman pull command
55](#02.htm_marker-1038662){.index1},
[61](#02.htm_marker-1038913){.index1}

[]{#index.htm_pgfId-434012 .calibre17}[podman push command
46](#02.htm_marker-1038368){.index1} --
[47](#02.htm_marker-1038401){.index1},
[64](#02.htm_marker-1039082){.index1},
[225](#11.htm_marker-1122021){.index1}

[]{#index.htm_pgfId-434017 .calibre17}[podman-py
175](#09.htm_marker-1109733){.index1} --
[176](#09.htm_marker-1109772){.index1}

[]{#index.htm_pgfId-434020 .calibre17}[podman-py library
166](#09.htm_marker-1111843){.index1}

[]{#index.htm_pgfId-434022 .calibre17}[podman-remote clients
185](#09.htm_marker-1116220){.index1}

[]{#index.htm_pgfId-434024 .calibre17}[podman - -remote command
180](#09.htm_marker-1109930){.index1} --
[185](#09.htm_marker-1116224){.index1}

[]{#index.htm_pgfId-434027 .calibre17}[configuring connection
185](#09.htm_marker-1110088){.index1}

[]{#index.htm_pgfId-434029 .calibre17}[local connections
180](#09.htm_marker-1109930){.index1} --
[182](#09.htm_marker-1109970){.index1}

[]{#index.htm_pgfId-434032 .calibre17}[remote connections
182](#09.htm_marker-1112091){.index1} --
[184](#09.htm_marker-1110065){.index1}

[]{#index.htm_pgfId-434035 .calibre17}[enabling Podman service on server
machine 183](#09.htm_marker-1116099){.index1} --
[184](#09.htm_marker-1110063){.index1}

[]{#index.htm_pgfId-434038 .calibre17}[enabling SSHD connections
183](#09.htm_marker-1110036){.index1}

[]{#index.htm_pgfId-434040 .calibre17}[setting up SSH on client machine
184](#09.htm_marker-1110070){.index1} --
[185](#09.htm_marker-1110083){.index1}

[]{#index.htm_pgfId-434043 .calibre17}[podman-remote command
180](#09.htm_marker-1109930){.index1}

[]{#index.htm_pgfId-434045 .calibre17}[podman-remote environment
263](#E.htm_marker-1286459){.index1}

[]{#index.htm_pgfId-434047 .calibre17}[podman rm command
37](#02.htm_marker-1037848){.index1},
[154](#08.htm_marker-1121704){.index1},
[161](#08.htm_marker-1118937){.index1}

[]{#index.htm_pgfId-434051 .calibre17}[podman rmi - -all - -force
command 109](#06.htm_marker-1110317){.index1}

[]{#index.htm_pgfId-434053 .calibre17}[podman rmi command
53](#02.htm_marker-1038595){.index1},
[161](#08.htm_marker-1118938){.index1}

[]{#index.htm_pgfId-434056 .calibre17}[podman run command
28](#02.htm_marker-1037550){.index1},
[32](#02.htm_marker-1037655){.index1},
[34](#02.htm_marker-1043634){.index1},
[55](#02.htm_marker-1038677){.index1},
[61](#02.htm_marker-1038919){.index1},
[68](#03.htm_marker-1048615){.index1},
[71](#03.htm_marker-1051690){.index1},
[137](#07.htm_marker-1110643){.index1},
[141](#07.htm_marker-1116823){.index1},
[144](#07.htm_marker-1110892){.index1}

[]{#index.htm_pgfId-434067 .calibre17}[podman-run command
129](#07.htm_marker-1110325){.index1}

[]{#index.htm_pgfId-434069 .calibre17}[podman run - -detach command
138](#07.htm_marker-1110700){.index1}

[]{#index.htm_pgfId-434071 .calibre17}[podman-run man page
34](#02.htm_marker-1037689){.index1}

[]{#index.htm_pgfId-434073 .calibre17}[podman run man pages
193](#10.htm_marker-1123817){.index1}

[]{#index.htm_pgfId-434075 .calibre17}[podman run - -stop-signal option
34](#02.htm_marker-1037708){.index1}

[]{#index.htm_pgfId-434077 .calibre17}[podman search command
58](#02.htm_marker-1038817){.index1}

[]{#index.htm_pgfId-434079 .calibre17}[podman secret
220](#11.htm_marker-1121787){.index1}

[]{#index.htm_pgfId-434081 .calibre17}[podman start command
33](#02.htm_marker-1037677){.index1},
[35](#02.htm_marker-1037746){.index1}

[]{#index.htm_pgfId-434084 .calibre17}[podman stop command
34](#02.htm_marker-1037701){.index1},
[124](#06.htm_marker-1110765){.index1},
[143](#07.htm_marker-1110885){.index1}

[]{#index.htm_pgfId-434088 .calibre17}[podman stop myapp command
32](#02.htm_marker-1037653){.index1}

[]{#index.htm_pgfId-434090 .calibre17}[podman stop options
35](#02.htm_marker-1037719){.index1}

[]{#index.htm_pgfId-434092 .calibre17}[podman system connection add
command 185](#09.htm_marker-1110092){.index1}

[]{#index.htm_pgfId-434094 .calibre17}[podman system connection command
185](#09.htm_marker-1110090){.index1},
[255](#C.htm_marker-1284793){.index1} --
[256](#C.htm_marker-1286531){.index1},
[262](#E.htm_marker-1286437){.index1}

[]{#index.htm_pgfId-434099 .calibre17}[podman system connection
datastore 263](#E.htm_marker-1286458){.index1},
[272](#F.htm_marker-1292509){.index1}

[]{#index.htm_pgfId-434102 .calibre17}[podman system connection list
command 185](#09.htm_marker-1110098){.index1},
[266](#E.htm_marker-1289513){.index1},
[275](#F.htm_marker-1289785){.index1}

[]{#index.htm_pgfId-434106 .calibre17}[podman system df command
55](#02.htm_marker-1038663){.index1}

[]{#index.htm_pgfId-434108 .calibre17}[podman system migrate command
105](#05.htm_marker-1108200){.index1},
[118](#06.htm_marker-1110654){.index1}

[]{#index.htm_pgfId-434111 .calibre17}[podman system service command
167](#09.htm_marker-1115470){.index1} --
[169](#09.htm_marker-1109496){.index1}

[]{#index.htm_pgfId-434114 .calibre17}[podman tag command
50](#02.htm_marker-1038517){.index1},
[64](#02.htm_marker-1039046){.index1} --
[65](#02.htm_marker-1039105){.index1}

[]{#index.htm_pgfId-434118 .calibre17}[Podman tool
234](#A.htm_marker-1282264){.index1}

[]{#index.htm_pgfId-434120 .calibre17}[podman unpause command
40](#02.htm_marker-1037947){.index1}

[]{#index.htm_pgfId-434122 .calibre17}[podman unshare command
59](#02.htm_marker-1038853){.index1},
[72](#03.htm_marker-1048751){.index1},
[114](#06.htm_marker-1110480){.index1},
[116](#06.htm_marker-1110527){.index1}

[]{#index.htm_pgfId-434127 .calibre17}[podman version command
267](#E.htm_marker-1286625){.index1},
[277](#F.htm_marker-1289838){.index1}

[]{#index.htm_pgfId-434130 .calibre17}[podman volume create command
70](#03.htm_marker-1048661){.index1}

[]{#index.htm_pgfId-434132 .calibre17}[podman-volume-create man pages
72](#03.htm_marker-1048722){.index1}

[]{#index.htm_pgfId-434134 .calibre17}[podman volume export command
72](#03.htm_marker-1048723){.index1}

[]{#index.htm_pgfId-434136 .calibre17}[podman volume import command
72](#03.htm_marker-1048725){.index1}

[]{#index.htm_pgfId-434138 .calibre17}[podman volume rm command
71](#03.htm_marker-1051690){.index1}

[]{#index.htm_pgfId-434140 .calibre17}[- -pod mypod option
81](#04.htm_marker-1103833){.index1}

[]{#index.htm_pgfId-434142 .calibre17}[pods
4](#01.htm_marker-1031556){.index1},
[77](#04.htm_marker-1104179){.index1} --
[86](#04.htm_marker-1104115){.index1},
[162](#08.htm_marker-1118974){.index1}

[]{#index.htm_pgfId-434147 .calibre17}[generating from Kubernetes YAML
files 157](#08.htm_marker-1118799){.index1}

[]{#index.htm_pgfId-434149 .calibre17}[building images
159](#08.htm_marker-1118885){.index1} --
[162](#08.htm_marker-1118969){.index1}

[]{#index.htm_pgfId-434152 .calibre17}[shutting down pods and containers
158](#08.htm_marker-1118855){.index1} --
[159](#08.htm_marker-1118879){.index1}

[]{#index.htm_pgfId-434155 .calibre17}[Podman, advantages with
22](#01.htm_marker-1032090){.index1} --
[23](#01.htm_marker-1032096){.index1}

[]{#index.htm_pgfId-434158 .calibre17}[running
77](#04.htm_marker-1103756){.index1} --
[86](#04.htm_marker-1103989){.index1}

[]{#index.htm_pgfId-434161 .calibre17}[adding container to pod
81](#04.htm_marker-1103829){.index1} --
[83](#04.htm_marker-1103881){.index1}

[]{#index.htm_pgfId-434164 .calibre17}[creating pod
80](#04.htm_marker-1103803){.index1} --
[81](#04.htm_marker-1103819){.index1}

[]{#index.htm_pgfId-434167 .calibre17}[listing pods
85](#04.htm_marker-1103949){.index1}

[]{#index.htm_pgfId-434169 .calibre17}[removing pods
85](#04.htm_marker-1103968){.index1} --
[86](#04.htm_marker-1103988){.index1}

[]{#index.htm_pgfId-434172 .calibre17}[starting pod
83](#04.htm_marker-1103886){.index1} --
[84](#04.htm_marker-1103922){.index1}

[]{#index.htm_pgfId-434175 .calibre17}[stopping pod
84](#04.htm_marker-1103926){.index1} --
[85](#04.htm_marker-1103946){.index1}

[]{#index.htm_pgfId-434178 .calibre17}[-p option
31](#02.htm_marker-1037634){.index1} --
[32](#02.htm_marker-1046818){.index1}

[]{#index.htm_pgfId-434181 .calibre17}[port command
31](#02.htm_marker-1037635){.index1}

[]{#index.htm_pgfId-434183 .calibre17}[- -preserve-fds option
183](#09.htm_marker-1116029){.index1}

[]{#index.htm_pgfId-434185 .calibre17}[- -privileged command
163](#08.htm_marker-1121496){.index1}

[]{#index.htm_pgfId-434187 .calibre17}[- -privileged container
219](#11.htm_marker-1121744){.index1}

[]{#index.htm_pgfId-434189 .calibre17}[- -privileged flag
16](#01.htm_marker-1031988){.index1},
[209](#10.htm_marker-1114868){.index1},
[230](#11.htm_marker-1122186){.index1}

[]{#index.htm_pgfId-434193 .calibre17}[privileged Kubernetes container
164](#08.htm_marker-1119077){.index1}

[]{#index.htm_pgfId-434195 .calibre17}[- -privileged mode
190](#10.htm_marker-1124108){.index1},
[192](#10.htm_marker-1114169){.index1}

[]{#index.htm_pgfId-434198 .calibre17}[- -privileged option
163](#08.htm_marker-1121498){.index1}

[]{#index.htm_pgfId-434200 .calibre17}[procfs mount type
117](#06.htm_marker-1112577){.index1}

[]{#index.htm_pgfId-434202 .calibre17}[prune command
41](#02.htm_marker-1044883){.index1},
[54](#02.htm_marker-1038632){.index1},
[66](#02.htm_marker-1046095){.index1},
[86](#04.htm_marker-1107366){.index1},
[186](#09.htm_marker-1116360){.index1}

[]{#index.htm_pgfId-434208 .calibre17}[ps command
30](#02.htm_marker-1037605){.index1},
[61](#02.htm_marker-1038920){.index1},
[248](#B.htm_marker-1284230){.index1}

[]{#index.htm_pgfId-434212 .calibre17}[pull command
66](#02.htm_marker-1039270){.index1}

[]{#index.htm_pgfId-434214 .calibre17}[pulling images
119](#06.htm_marker-1110666){.index1} --
[120](#06.htm_marker-1110677){.index1}

[]{#index.htm_pgfId-434217 .calibre17}[overview
55](#02.htm_marker-1038658){.index1} --
[58](#02.htm_marker-1038808){.index1}

[]{#index.htm_pgfId-434220 .calibre17}[short names and container
registries 56](#02.htm_marker-1045426){.index1} --
[58](#02.htm_marker-1038807){.index1}

[]{#index.htm_pgfId-434223 .calibre17}[pulling signed images
226](#11.htm_marker-1122031){.index1} --
[227](#11.htm_marker-1126246){.index1}

[]{#index.htm_pgfId-434226 .calibre17}[pushing images
225](#11.htm_marker-1122001){.index1}

[]{#index.htm_pgfId-434228 .calibre17}[container transports
46](#02.htm_marker-1038373){.index1} --
[48](#02.htm_marker-1045226){.index1}

[]{#index.htm_pgfId-434231 .calibre17}[overview
46](#02.htm_marker-1038365){.index1} --
[48](#02.htm_marker-1045227){.index1}

[]{#index.htm_pgfId-434234 .calibre17}[python-docker package
174](#09.htm_marker-1109695){.index1}

[]{#index.htm_pgfId-434236 .calibre17}[Python libraries
173](#09.htm_marker-1109683){.index1} --
[177](#09.htm_marker-1109818){.index1}

[]{#index.htm_pgfId-434239 .calibre17}[using docker-py with Podman API
174](#09.htm_marker-1114805){.index1} --
[175](#09.htm_marker-1109727){.index1}

[]{#index.htm_pgfId-434242 .calibre17}[using podman-py with Podman API
175](#09.htm_marker-1109732){.index1} --
[176](#09.htm_marker-1109771){.index1}

[]{#index.htm_pgfId-434245 .calibre17}[which to use
176](#09.htm_marker-1109776){.index1} --
[177](#09.htm_marker-1109816){.index1}

[]{#index.htm_pgfId-434248 .calibre17}Q[]{#index.htm_Q .calibre17}

[]{#index.htm_pgfId-434250 .calibre17}[- -quiet (-q) option
36](#02.htm_marker-1037785){.index1},
[58](#02.htm_marker-1038800){.index1}

[]{#index.htm_pgfId-434253 .calibre17}R[]{#index.htm_R .calibre17}

[]{#index.htm_pgfId-434255 .calibre17}[ramfs mount type
117](#06.htm_marker-1112580){.index1}

[]{#index.htm_pgfId-434257 .calibre17}[Raspberry Pi OS arm64
257](#C.htm_marker-1284926){.index1}

[]{#index.htm_pgfId-434259 .calibre17}[- -raw option
13](#01.htm_marker-1031753){.index1}

[]{#index.htm_pgfId-434261 .calibre17}[- -read-only mode
229](#11.htm_marker-1122167){.index1}

[]{#index.htm_pgfId-434263 .calibre17}[- -read-only option
229](#11.htm_marker-1122158){.index1}

[]{#index.htm_pgfId-434265 .calibre17}[- -read-only-tmpfs=false flag
229](#11.htm_marker-1122171){.index1}

[]{#index.htm_pgfId-434267 .calibre17}[- -read-only-tmpfs option
229](#11.htm_marker-1122165){.index1}

[]{#index.htm_pgfId-434269 .calibre17}[read syscall
213](#10.htm_marker-1115109){.index1}

[]{#index.htm_pgfId-434271 .calibre17}[Red Hat Enterprise Linux
257](#C.htm_marker-1284938){.index1}

[]{#index.htm_pgfId-434273 .calibre17}[RHEL7
257](#C.htm_marker-1284942){.index1}

[]{#index.htm_pgfId-434275 .calibre17}[RHEL8
257](#C.htm_marker-1284952){.index1}

[]{#index.htm_pgfId-434277 .calibre17}[RHEL9
257](#C.htm_marker-1284962){.index1}

[]{#index.htm_pgfId-434279 .calibre17}registries

[]{#index.htm_pgfId-434280 .calibre17}[blocking pulling from
98](#05.htm_marker-1105830){.index1} --
[100](#05.htm_marker-1105902){.index1}

[]{#index.htm_pgfId-434283 .calibre17}[configuration files for
96](#05.htm_marker-1105769){.index1} --
[100](#05.htm_marker-1105905){.index1}

[]{#index.htm_pgfId-434286 .calibre17}[customizing Podman
23](#01.htm_marker-1039161){.index1} --
[24](#01.htm_marker-1032156){.index1}

[]{#index.htm_pgfId-434289 .calibre17}[logging into
48](#02.htm_marker-1038456){.index1} --
[50](#02.htm_marker-1038507){.index1}

[]{#index.htm_pgfId-434292 .calibre17}[pushing images to
243](#A.htm_marker-1278191){.index1}

[]{#index.htm_pgfId-434294 .calibre17}[short names and
56](#02.htm_marker-1045425){.index1} --
[58](#02.htm_marker-1038806){.index1}

[]{#index.htm_pgfId-434297 .calibre17}[registries.conf
96](#05.htm_marker-1105774){.index1} --
[100](#05.htm_marker-1105904){.index1}

[]{#index.htm_pgfId-434300 .calibre17}[registry.access.redhat.com
container registry 28](#02.htm_marker-1037557){.index1},
[61](#02.htm_marker-1038912){.index1}

[]{#index.htm_pgfId-434303 .calibre17}[REGISTRY_AUTH_FILE environment
variable 49](#02.htm_marker-1038498){.index1}

[]{#index.htm_pgfId-434305 .calibre17}[reject flag
224](#11.htm_marker-1121963){.index1}

[]{#index.htm_pgfId-434307 .calibre17}[remote connections
182](#09.htm_marker-1112090){.index1} --
[184](#09.htm_marker-1110064){.index1}

[]{#index.htm_pgfId-434310 .calibre17}[enable Podman service on server
machine 183](#09.htm_marker-1116098){.index1} --
[184](#09.htm_marker-1110062){.index1}

[]{#index.htm_pgfId-434313 .calibre17}[enable SSHD connections
183](#09.htm_marker-1110035){.index1}

[]{#index.htm_pgfId-434315 .calibre17}[- -remote mode
268](#E.htm_marker-1289945){.index1},
[278](#F.htm_marker-1292705){.index1}

[]{#index.htm_pgfId-434318 .calibre17}[- -remote option
167](#09.htm_marker-1109430){.index1},
[180](#09.htm_marker-1109930){.index1},
[182](#09.htm_marker-1109968){.index1},
[185](#09.htm_marker-1116219){.index1},
[268](#E.htm_marker-1289943){.index1},
[278](#F.htm_marker-1292703){.index1}

[]{#index.htm_pgfId-434325 .calibre17}[- -remote support
263](#E.htm_marker-1286449){.index1},
[270](#F.htm_marker-1289602){.index1}

[]{#index.htm_pgfId-434328 .calibre17}removing

[]{#index.htm_pgfId-434329 .calibre17}[containers
37](#02.htm_marker-1037844){.index1} --
[38](#02.htm_marker-1037859){.index1}

[]{#index.htm_pgfId-434332 .calibre17}[images
53](#02.htm_marker-1038584){.index1} --
[55](#02.htm_marker-1038653){.index1}

[]{#index.htm_pgfId-434335 .calibre17}[pods
85](#04.htm_marker-1103967){.index1} --
[86](#04.htm_marker-1103987){.index1}

[]{#index.htm_pgfId-434338 .calibre17}[rename command
41](#02.htm_marker-1044884){.index1}

[]{#index.htm_pgfId-434340 .calibre17}[renumber command
186](#09.htm_marker-1116367){.index1}

[]{#index.htm_pgfId-434342 .calibre17}[replicas flag
156](#08.htm_marker-1118787){.index1}

[]{#index.htm_pgfId-434344 .calibre17}[replicas option
156](#08.htm_marker-1118777){.index1}

[]{#index.htm_pgfId-434346 .calibre17}[Repository heading
44](#02.htm_marker-1044995){.index1}

[]{#index.htm_pgfId-434348 .calibre17}[reset command
186](#09.htm_marker-1116374){.index1}

[]{#index.htm_pgfId-434350 .calibre17}[resource constraints (cgroups)
8](#01.htm_marker-1035922){.index1}

[]{#index.htm_pgfId-434352 .calibre17}[REST API, Podman support for
21](#01.htm_marker-1032053){.index1}

[]{#index.htm_pgfId-434354 .calibre17}[restart command
41](#02.htm_marker-1044885){.index1},
[86](#04.htm_marker-1107367){.index1}

[]{#index.htm_pgfId-434357 .calibre17}[- -restart container
137](#07.htm_marker-1110644){.index1}

[]{#index.htm_pgfId-434359 .calibre17}[restarting containers
137](#07.htm_marker-1110640){.index1}

[]{#index.htm_pgfId-434361 .calibre17}[restore command
41](#02.htm_marker-1044886){.index1},
[249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434364 .calibre17}[restorecon command
93](#05.htm_marker-1105629){.index1}

[]{#index.htm_pgfId-434366 .calibre17}[resume command
249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434368 .calibre17}[RHEL7
257](#C.htm_marker-1284941){.index1}

[]{#index.htm_pgfId-434370 .calibre17}[RHEL8
257](#C.htm_marker-1284951){.index1}

[]{#index.htm_pgfId-434372 .calibre17}[RHEL9
257](#C.htm_marker-1284961){.index1}

[]{#index.htm_pgfId-434374 .calibre17}[rm command
41](#02.htm_marker-1044887){.index1},
[66](#02.htm_marker-1039268){.index1},
[86](#04.htm_marker-1107368){.index1},
[221](#11.htm_marker-1125736){.index1},
[264](#E.htm_marker-1288247){.index1},
[273](#F.htm_marker-1292530){.index1}

[]{#index.htm_pgfId-434381 .calibre17}[- -rm option
29](#02.htm_marker-1037568){.index1} --
[30](#02.htm_marker-1037615){.index1},
[34](#02.htm_marker-1037682){.index1},
[110](#06.htm_marker-1110346){.index1},
[124](#06.htm_marker-1110777){.index1},
[200](#10.htm_marker-1114501){.index1}

[]{#index.htm_pgfId-434388 .calibre17}[- -roll-back option
145](#07.htm_marker-1110935){.index1}

[]{#index.htm_pgfId-434390 .calibre17}[rolling back failed containers
147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-434392 .calibre17}[ro option
69](#03.htm_marker-1051591){.index1},
[72](#03.htm_marker-1048734){.index1}

[]{#index.htm_pgfId-434395 .calibre17}[root account
266](#E.htm_marker-1286570){.index1},
[275](#F.htm_marker-1289781){.index1}

[]{#index.htm_pgfId-434398 .calibre17}[root-auto-userns-user option
201](#10.htm_marker-1121477){.index1}

[]{#index.htm_pgfId-434400 .calibre17}[rootfs container image
240](#A.htm_marker-1278007){.index1}

[]{#index.htm_pgfId-434402 .calibre17}[rootfs mount point
78](#04.htm_marker-1103761){.index1}

[]{#index.htm_pgfId-434404 .calibre17}[rootfs root file system
206](#10.htm_marker-1114739){.index1},
[248](#B.htm_marker-1282861){.index1}

[]{#index.htm_pgfId-434407 .calibre17}[rootfs (root filesystem)
13](#01.htm_marker-1031719){.index1}

[]{#index.htm_pgfId-434409 .calibre17}[- -rootful option
275](#F.htm_marker-1291493){.index1}

[]{#index.htm_pgfId-434411 .calibre17}[rootless containers
16](#01.htm_marker-1031983){.index1} --
[17](#01.htm_marker-1031996){.index1},
[106](#06.htm_marker-1111672){.index1} --
[124](#06.htm_marker-1110785){.index1}

[]{#index.htm_pgfId-434416 .calibre17}[conmon
121](#06.htm_marker-1110714){.index1}

[]{#index.htm_pgfId-434418 .calibre17}[containerized application running
until completion 124](#06.htm_marker-1110763){.index1}

[]{#index.htm_pgfId-434420 .calibre17}[creating container
120](#06.htm_marker-1110681){.index1}

[]{#index.htm_pgfId-434422 .calibre17}[images containing content owned
by multiple UIDs 110](#06.htm_marker-1113924){.index1} --
[117](#06.htm_marker-1110574){.index1}

[]{#index.htm_pgfId-434425 .calibre17}[mount namespace
115](#06.htm_marker-1110517){.index1} --
[116](#06.htm_marker-1110553){.index1}

[]{#index.htm_pgfId-434428 .calibre17}[user namespace
111](#06.htm_marker-1110394){.index1} --
[115](#06.htm_marker-1110512){.index1}

[]{#index.htm_pgfId-434431 .calibre17}[user namespace and mount
namespace 117](#06.htm_marker-1110561){.index1}

[]{#index.htm_pgfId-434433 .calibre17}[launching OCI runtime
121](#06.htm_marker-1110731){.index1} --
[123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-434436 .calibre17}[pulling image
119](#06.htm_marker-1110665){.index1} --
[120](#06.htm_marker-1110676){.index1}

[]{#index.htm_pgfId-434439 .calibre17}[setting up network
120](#06.htm_marker-1110696){.index1} --
[121](#06.htm_marker-1110704){.index1}

[]{#index.htm_pgfId-434442 .calibre17}[rootless_storage_path key
93](#05.htm_marker-1105603){.index1}

[]{#index.htm_pgfId-434444 .calibre17}runc

[]{#index.htm_pgfId-434445 .calibre17}[command
252](#B.htm_marker-1282994){.index1}

[]{#index.htm_pgfId-434447 .calibre17}[executable
207](#10.htm_marker-1114746){.index1}

[]{#index.htm_pgfId-434449 .calibre17}[OCI runtime
7](#01.htm_marker-1031582){.index1},
[17](#01.htm_marker-1032012){.index1},
[121](#06.htm_marker-1110718){.index1},
[207](#10.htm_marker-1114745){.index1}

[]{#index.htm_pgfId-434454 .calibre17}[runtime
248](#B.htm_marker-1282854){.index1} --
[249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434457 .calibre17}[run command
50](#02.htm_marker-1038528){.index1},
[153](#08.htm_marker-1118712){.index1},
[249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434461 .calibre17}[RUN instruction
61](#02.htm_marker-1038915){.index1},
[239](#A.htm_marker-1277945){.index1} --
[240](#A.htm_marker-1282729){.index1}

[]{#index.htm_pgfId-434465 .calibre17}[runlabel command
41](#02.htm_marker-1044888){.index1}

[]{#index.htm_pgfId-434467 .calibre17}[running container
237](#A.htm_marker-1277869){.index1}

[]{#index.htm_pgfId-434469 .calibre17}[running containerized application
30](#02.htm_marker-1037620){.index1} --
[34](#02.htm_marker-1037692){.index1}

[]{#index.htm_pgfId-434472 .calibre17}[runsc OCI runtime
252](#B.htm_marker-1283018){.index1}

[]{#index.htm_pgfId-434474 .calibre17}[RUN systemctl enable
httpd.service command 133](#07.htm_marker-1110461){.index1}

[]{#index.htm_pgfId-434476 .calibre17}[- -runtime option
246](#B.htm_marker-1282824){.index1},
[248](#B.htm_marker-1282849){.index1}

[]{#index.htm_pgfId-434479 .calibre17}S[]{#index.htm_S .calibre17}

[]{#index.htm_pgfId-434481 .calibre17}[save command
66](#02.htm_marker-1039282){.index1}

[]{#index.htm_pgfId-434483 .calibre17}[scanning, image
228](#11.htm_marker-1122125){.index1} --
[229](#11.htm_marker-1122155){.index1}

[]{#index.htm_pgfId-434486 .calibre17}[scope
128](#07.htm_marker-1110303){.index1}

[]{#index.htm_pgfId-434488 .calibre17}[scp command
66](#02.htm_marker-1039281){.index1}

[]{#index.htm_pgfId-434490 .calibre17}[scratch image
61](#02.htm_marker-1038909){.index1}

[]{#index.htm_pgfId-434492 .calibre17}[sd-notify containerized services
127](#07.htm_marker-1113419){.index1}

[]{#index.htm_pgfId-434494 .calibre17}[sd-notify feature
145](#07.htm_marker-1117747){.index1}

[]{#index.htm_pgfId-434496 .calibre17}[sd-notify service type
146](#07.htm_marker-1110963){.index1}

[]{#index.htm_pgfId-434498 .calibre17}[search command
66](#02.htm_marker-1039280){.index1}

[]{#index.htm_pgfId-434500 .calibre17}[searching for images
58](#02.htm_marker-1038813){.index1}

[]{#index.htm_pgfId-434502 .calibre17}[seccomp
213](#10.htm_marker-1115104){.index1} --
[214](#10.htm_marker-1115145){.index1}

[]{#index.htm_pgfId-434505 .calibre17}[component
9](#01.htm_marker-1033542){.index1}

[]{#index.htm_pgfId-434507 .calibre17}[filters
163](#08.htm_marker-1119062){.index1},
[214](#10.htm_marker-1115115){.index1}

[]{#index.htm_pgfId-434510 .calibre17}[Linux kernel feature
213](#10.htm_marker-1115114){.index1}

[]{#index.htm_pgfId-434512 .calibre17}[second-level address translation
(SLAT) support 270](#F.htm_marker-1289614){.index1}

[]{#index.htm_pgfId-434514 .calibre17}[secret handling
220](#11.htm_marker-1121784){.index1} --
[221](#11.htm_marker-1121822){.index1}

[]{#index.htm_pgfId-434517 .calibre17}[- -secret my_secret,type=env flag
221](#11.htm_marker-1121800){.index1}

[]{#index.htm_pgfId-434519 .calibre17}[security
216](#11.htm_marker-1124735){.index1} --
[231](#11.htm_marker-1122205){.index1}

[]{#index.htm_pgfId-434522 .calibre17}[daemon vs. fork/exec model
217](#11.htm_marker-1121664){.index1} --
[220](#11.htm_marker-1121778){.index1}

[]{#index.htm_pgfId-434525 .calibre17}[access to docker.sock
217](#11.htm_marker-1121670){.index1}

[]{#index.htm_pgfId-434527 .calibre17}[auditing and logging
218](#11.htm_marker-1121704){.index1} --
[220](#11.htm_marker-1121773){.index1}

[]{#index.htm_pgfId-434530 .calibre17}[Podman image scanning
228](#11.htm_marker-1122124){.index1} --
[229](#11.htm_marker-1122169){.index1}

[]{#index.htm_pgfId-434533 .calibre17}[Podman image trust command
221](#11.htm_marker-1121864){.index1} --
[227](#11.htm_marker-1126249){.index1}

[]{#index.htm_pgfId-434536 .calibre17}[Podman secret handling
220](#11.htm_marker-1121783){.index1} --
[221](#11.htm_marker-1121821){.index1}

[]{#index.htm_pgfId-434539 .calibre17}[security in depth
229](#11.htm_marker-1122177){.index1} --
[230](#11.htm_marker-1122199){.index1}

[]{#index.htm_pgfId-434542 .calibre17}[Podman using all of security
mechanisms simultaneously 230](#11.htm_marker-1122183){.index1}

[]{#index.htm_pgfId-434544 .calibre17}[where to run containers
230](#11.htm_marker-1122193){.index1}

[]{#index.htm_pgfId-434546 .calibre17}[security constraints
8](#01.htm_marker-1031604){.index1}

[]{#index.htm_pgfId-434548 .calibre17}[security container isolation
189](#10.htm_marker-1121657){.index1} --
[215](#10.htm_marker-1115162){.index1}

[]{#index.htm_pgfId-434551 .calibre17}[file system isolation
207](#10.htm_marker-1114754){.index1} --
[213](#10.htm_marker-1115096){.index1}

[]{#index.htm_pgfId-434554 .calibre17}[IPC namespace
206](#10.htm_marker-1123073){.index1}

[]{#index.htm_pgfId-434556 .calibre17}[Linux capabilities
194](#10.htm_marker-1114239){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-434559 .calibre17}[adding capabilities
197](#10.htm_marker-1114414){.index1} --
[198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-434562 .calibre17}[dropped CAP_SYS_ADMIN
196](#10.htm_marker-1114370){.index1}

[]{#index.htm_pgfId-434564 .calibre17}[dropped Linux capabilities
195](#10.htm_marker-1114268){.index1} --
[196](#10.htm_marker-1122767){.index1}

[]{#index.htm_pgfId-434567 .calibre17}[dropping capabilities
197](#10.htm_marker-1114385){.index1}

[]{#index.htm_pgfId-434569 .calibre17}[no new privileges
198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-434571 .calibre17}[root with no capabilities is
still dangerous 198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-434573 .calibre17}[mount namespace
206](#10.htm_marker-1114734){.index1} --
[207](#10.htm_marker-1114747){.index1}

[]{#index.htm_pgfId-434576 .calibre17}[network namespace
205](#10.htm_marker-1114672){.index1}

[]{#index.htm_pgfId-434578 .calibre17}[PID namespace
204](#10.htm_marker-1114646){.index1}

[]{#index.htm_pgfId-434580 .calibre17}[read-only Linux kernel pseudo
file systems 191](#10.htm_marker-1114101){.index1} --
[194](#10.htm_marker-1114235){.index1}

[]{#index.htm_pgfId-434583 .calibre17}[masking additional paths
193](#10.htm_marker-1114201){.index1} --
[194](#10.htm_marker-1114232){.index1}

[]{#index.htm_pgfId-434586 .calibre17}[unmasking masked paths
192](#10.htm_marker-1114167){.index1} --
[193](#10.htm_marker-1123819){.index1}

[]{#index.htm_pgfId-434589 .calibre17}[system call isolation SECCOMP
213](#10.htm_marker-1115103){.index1} --
[214](#10.htm_marker-1115144){.index1}

[]{#index.htm_pgfId-434592 .calibre17}[UID isolation
198](#10.htm_marker-1114464){.index1} --
[204](#10.htm_marker-1114642){.index1}

[]{#index.htm_pgfId-434595 .calibre17}[isolating containers using -
-userns=auto flag 199](#10.htm_marker-1114478){.index1} --
[200](#10.htm_marker-1114509){.index1}

[]{#index.htm_pgfId-434598 .calibre17}[rootless Podman with -
-userns=auto flag 202](#10.htm_marker-1114570){.index1}

[]{#index.htm_pgfId-434600 .calibre17}[user namespaced Linux
capabilities 201](#10.htm_marker-1114539){.index1} --
[202](#10.htm_marker-1114563){.index1}

[]{#index.htm_pgfId-434603 .calibre17}[user volumes with - -userns=auto
flag 202](#10.htm_marker-1114592){.index1} --
[204](#10.htm_marker-1114639){.index1}

[]{#index.htm_pgfId-434606 .calibre17}[VM (virtual machine) isolation
214](#10.htm_marker-1115150){.index1} --
[215](#10.htm_marker-1115157){.index1}

[]{#index.htm_pgfId-434609 .calibre17}[security in depth
229](#11.htm_marker-1122176){.index1} --
[230](#11.htm_marker-1122198){.index1}

[]{#index.htm_pgfId-434612 .calibre17}[Podman using all of security
mechanisms simultaneously 230](#11.htm_marker-1122182){.index1}

[]{#index.htm_pgfId-434614 .calibre17}[where to run containers
230](#11.htm_marker-1122192){.index1}

[]{#index.htm_pgfId-434616 .calibre17}[- -security-opt label=disable
option 74](#03.htm_marker-1048789){.index1}

[]{#index.htm_pgfId-434618 .calibre17}[- -security-opt label:disable
flag 213](#10.htm_marker-1115076){.index1}

[]{#index.htm_pgfId-434620 .calibre17}[- -security-opt
mask=/proc/sys/dev flag 193](#10.htm_marker-1114215){.index1}

[]{#index.htm_pgfId-434622 .calibre17}[- -security-opt mask flag
193](#10.htm_marker-1114206){.index1}

[]{#index.htm_pgfId-434624 .calibre17}[- -security-opt no-new-privileges
option 198](#10.htm_marker-1114464){.index1}

[]{#index.htm_pgfId-434626 .calibre17}[- -security-opt
seccomp=unconfined flag 214](#10.htm_marker-1115140){.index1}

[]{#index.htm_pgfId-434628 .calibre17}[- -security-opt unmask=/proc/scsi
flag 192](#10.htm_marker-1114172){.index1}

[]{#index.htm_pgfId-434630 .calibre17}[SELinux
207](#10.htm_marker-1114753){.index1} --
[213](#10.htm_marker-1115095){.index1}

[]{#index.htm_pgfId-434633 .calibre17}[MCS (Multi-Category security)
separation 211](#10.htm_marker-1114955){.index1} --
[213](#10.htm_marker-1115090){.index1}

[]{#index.htm_pgfId-434636 .calibre17}[SELinux MCS separation
211](#10.htm_marker-1114956){.index1} --
[213](#10.htm_marker-1115091){.index1}

[]{#index.htm_pgfId-434639 .calibre17}[SELinux type enforcement
207](#10.htm_marker-1120089){.index1} --
[210](#10.htm_marker-1114949){.index1}

[]{#index.htm_pgfId-434642 .calibre17}[type enforcement
207](#10.htm_marker-1120088){.index1} --
[210](#10.htm_marker-1114948){.index1}

[]{#index.htm_pgfId-434645 .calibre17}[SELinux volume options
73](#03.htm_marker-1048780){.index1} --
[74](#03.htm_marker-1053207){.index1}

[]{#index.htm_pgfId-434648 .calibre17}[semanage command
93](#05.htm_marker-1105628){.index1}

[]{#index.htm_pgfId-434650 .calibre17}[server machine
183](#09.htm_marker-1116097){.index1} --
[184](#09.htm_marker-1110061){.index1}

[]{#index.htm_pgfId-434653 .calibre17}[service command
186](#09.htm_marker-1116381){.index1}

[]{#index.htm_pgfId-434655 .calibre17}[set command
273](#F.htm_marker-1292535){.index1}

[]{#index.htm_pgfId-434657 .calibre17}[SET_SETPCAP option
196](#10.htm_marker-1118976){.index1}

[]{#index.htm_pgfId-434659 .calibre17}[setuid program
194](#10.htm_marker-1114245){.index1}

[]{#index.htm_pgfId-434661 .calibre17}[short names
56](#02.htm_marker-1045424){.index1} --
[58](#02.htm_marker-1038805){.index1}

[]{#index.htm_pgfId-434664 .calibre17}[shutting down pods and containers
158](#08.htm_marker-1118854){.index1} --
[159](#08.htm_marker-1118878){.index1}

[]{#index.htm_pgfId-434667 .calibre17}[SIGCHLD signal
129](#07.htm_marker-1110323){.index1}

[]{#index.htm_pgfId-434669 .calibre17}[SIGKILL signal
34](#02.htm_marker-1037706){.index1}

[]{#index.htm_pgfId-434671 .calibre17}[sign command
66](#02.htm_marker-1039279){.index1}

[]{#index.htm_pgfId-434673 .calibre17}[signing images
225](#11.htm_marker-1122000){.index1}

[]{#index.htm_pgfId-434675 .calibre17}[sigstore flag
226](#11.htm_marker-1122034){.index1}

[]{#index.htm_pgfId-434677 .calibre17}[sigstore-staging flag
225](#11.htm_marker-1121993){.index1}

[]{#index.htm_pgfId-434679 .calibre17}[SIGTERM stop signal
34](#02.htm_marker-1037709){.index1}

[]{#index.htm_pgfId-434681 .calibre17}[SIZE heading
44](#02.htm_marker-1044999){.index1}

[]{#index.htm_pgfId-434683 .calibre17}[- -size option
36](#02.htm_marker-1037787){.index1} --
[37](#02.htm_marker-1037835){.index1}

[]{#index.htm_pgfId-434686 .calibre17}[size storage driver
96](#05.htm_marker-1110082){.index1}

[]{#index.htm_pgfId-434688 .calibre17}[skip_mount_home storage driver
96](#05.htm_marker-1110072){.index1}

[]{#index.htm_pgfId-434690 .calibre17}[Skopeo
7](#01.htm_marker-1036167){.index1},
[13](#01.htm_marker-1031751){.index1},
[234](#A.htm_marker-1282252){.index1} --
[236](#A.htm_marker-1277808){.index1}

[]{#index.htm_pgfId-434695 .calibre17}[skopeo copy command
236](#A.htm_marker-1277787){.index1} --
[237](#A.htm_marker-1280540){.index1}

[]{#index.htm_pgfId-434698 .calibre17}[skopeo delete command
237](#A.htm_marker-1280541){.index1}

[]{#index.htm_pgfId-434700 .calibre17}[skopeo inspect command
235](#A.htm_marker-1280173){.index1},
[237](#A.htm_marker-1280542){.index1}

[]{#index.htm_pgfId-434703 .calibre17}[skopeo list-tags command
237](#A.htm_marker-1280543){.index1}

[]{#index.htm_pgfId-434705 .calibre17}[skopeo login command
237](#A.htm_marker-1280544){.index1}

[]{#index.htm_pgfId-434707 .calibre17}[skopeo logout command
237](#A.htm_marker-1280545){.index1}

[]{#index.htm_pgfId-434709 .calibre17}[skopeo manifest digest command
237](#A.htm_marker-1280546){.index1}

[]{#index.htm_pgfId-434711 .calibre17}[skopeo sync command
236](#A.htm_marker-1277804){.index1} --
[237](#A.htm_marker-1280547){.index1}

[]{#index.htm_pgfId-434714 .calibre17}[SLAT (second-level address
translation) support 270](#F.htm_marker-1289613){.index1}

[]{#index.htm_pgfId-434716 .calibre17}[socket-activated Podman
containers 147](#07.htm_marker-1110994){.index1} --
[149](#07.htm_marker-1111048){.index1}

[]{#index.htm_pgfId-434719 .calibre17}[socket-activated services
147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-434721 .calibre17}[source code, building from
257](#C.htm_marker-1284985){.index1} --
[258](#C.htm_marker-1284991){.index1}

[]{#index.htm_pgfId-434724 .calibre17}[spec command
249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434726 .calibre17}[ssh command
264](#E.htm_marker-1288248){.index1},
[273](#F.htm_marker-1292540){.index1}

[]{#index.htm_pgfId-434729 .calibre17}SSH connections

[]{#index.htm_pgfId-434730 .calibre17}[macOS
266](#E.htm_marker-1286564){.index1} --
[267](#E.htm_marker-1286596){.index1}

[]{#index.htm_pgfId-434733 .calibre17}[setting up on client machine
184](#09.htm_marker-1110069){.index1} --
[185](#09.htm_marker-1110082){.index1}

[]{#index.htm_pgfId-434736 .calibre17}[Windows
275](#F.htm_marker-1289776){.index1} --
[276](#F.htm_marker-1289808){.index1}

[]{#index.htm_pgfId-434739 .calibre17}[ssh-copy-id command
184](#09.htm_marker-1110078){.index1}

[]{#index.htm_pgfId-434741 .calibre17}[SSHD connections
183](#09.htm_marker-1110034){.index1}

[]{#index.htm_pgfId-434743 .calibre17}[ssh_home_t type
209](#10.htm_marker-1114884){.index1}

[]{#index.htm_pgfId-434745 .calibre17}[start command
41](#02.htm_marker-1044889){.index1},
[86](#04.htm_marker-1107370){.index1},
[249](#B.htm_marker-1282957){.index1},
[264](#E.htm_marker-1288249){.index1},
[273](#F.htm_marker-1292545){.index1}

[]{#index.htm_pgfId-434751 .calibre17}starting

[]{#index.htm_pgfId-434752 .calibre17}[containers
35](#02.htm_marker-1037738){.index1}

[]{#index.htm_pgfId-434754 .calibre17}[Podman
279](#F.htm_marker-1289948){.index1}

[]{#index.htm_pgfId-434756 .calibre17}[pods
83](#04.htm_marker-1103885){.index1} --
[84](#04.htm_marker-1103921){.index1}

[]{#index.htm_pgfId-434759 .calibre17}[VM (virtual machine)
267](#E.htm_marker-1286602){.index1} --
[268](#E.htm_marker-1286641){.index1}

[]{#index.htm_pgfId-434762 .calibre17}[WSL 2 instance
276](#F.htm_marker-1289813){.index1} --
[277](#F.htm_marker-1289856){.index1}

[]{#index.htm_pgfId-434765 .calibre17}[state command
249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-434767 .calibre17}[stats command
41](#02.htm_marker-1044890){.index1},
[86](#04.htm_marker-1107369){.index1}

[]{#index.htm_pgfId-434770 .calibre17}[STDERR file descriptor
123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-434772 .calibre17}[STDIN file descriptor
123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-434774 .calibre17}[STDOUT file descriptor
123](#06.htm_marker-1110753){.index1}

[]{#index.htm_pgfId-434776 .calibre17}[stop command
41](#02.htm_marker-1044891){.index1},
[86](#04.htm_marker-1107371){.index1},
[153](#08.htm_marker-1118714){.index1},
[264](#E.htm_marker-1288250){.index1},
[273](#F.htm_marker-1292550){.index1}

[]{#index.htm_pgfId-434782 .calibre17}stopping

[]{#index.htm_pgfId-434783 .calibre17}[containers
34](#02.htm_marker-1037697){.index1} --
[35](#02.htm_marker-1037733){.index1}

[]{#index.htm_pgfId-434786 .calibre17}[Podman
279](#F.htm_marker-1289947){.index1}

[]{#index.htm_pgfId-434788 .calibre17}[pods
84](#04.htm_marker-1103925){.index1} --
[85](#04.htm_marker-1103945){.index1}

[]{#index.htm_pgfId-434791 .calibre17}[VM (virtual machine)
268](#E.htm_marker-1286648){.index1}

[]{#index.htm_pgfId-434793 .calibre17}[WSL 2 instance
277](#F.htm_marker-1289872){.index1}

[]{#index.htm_pgfId-434795 .calibre17}[STOPSIGNAL instruction
40](#02.htm_marker-1037956){.index1},
[242](#A.htm_marker-1280883){.index1}

[]{#index.htm_pgfId-434798 .calibre17}[storage, configuration files for
91](#05.htm_marker-1105545){.index1} --
[96](#05.htm_marker-1105765){.index1}

[]{#index.htm_pgfId-434801 .calibre17}[storage drivers
94](#05.htm_marker-1105642){.index1} --
[96](#05.htm_marker-1105762){.index1}

[]{#index.htm_pgfId-434804 .calibre17}[storage location
91](#05.htm_marker-1109582){.index1} --
[94](#05.htm_marker-1105637){.index1}

[]{#index.htm_pgfId-434807 .calibre17}[sudo command
195](#10.htm_marker-1114264){.index1}

[]{#index.htm_pgfId-434809 .calibre17}[syscall
213](#10.htm_marker-1115106){.index1}

[]{#index.htm_pgfId-434811 .calibre17}[sysfs mount type
117](#06.htm_marker-1112581){.index1}

[]{#index.htm_pgfId-434813 .calibre17}[system call isolation SECCOMP
213](#10.htm_marker-1115101){.index1} --
[214](#10.htm_marker-1115142){.index1}

[]{#index.htm_pgfId-434816 .calibre17}[system configuration files
104](#05.htm_marker-1108995){.index1} --
[105](#05.htm_marker-1108201){.index1}

[]{#index.htm_pgfId-434819 .calibre17}[systemctl command
133](#07.htm_marker-1110463){.index1}

[]{#index.htm_pgfId-434821 .calibre17}[systemd
21](#01.htm_marker-1032062){.index1} --
[22](#01.htm_marker-1032080){.index1},
[127](#07.htm_marker-1113414){.index1} --
[150](#07.htm_marker-1111058){.index1}

[]{#index.htm_pgfId-434826 .calibre17}[journald
134](#07.htm_marker-1110504){.index1} --
[137](#07.htm_marker-1110630){.index1}

[]{#index.htm_pgfId-434829 .calibre17}[events
136](#07.htm_marker-1110575){.index1} --
[137](#07.htm_marker-1110627){.index1}

[]{#index.htm_pgfId-434832 .calibre17}[log driver
135](#07.htm_marker-1110509){.index1} --
[136](#07.htm_marker-1110570){.index1}

[]{#index.htm_pgfId-434835 .calibre17}[rolling back failed containers
after update 147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-434837 .calibre17}[running containers in notify unit
files 145](#07.htm_marker-1110958){.index1} --
[146](#07.htm_marker-1110975){.index1}

[]{#index.htm_pgfId-434840 .calibre17}[running within container
128](#07.htm_marker-1110309){.index1} --
[134](#07.htm_marker-1110500){.index1}

[]{#index.htm_pgfId-434843 .calibre17}[containerized systemd
requirements 131](#07.htm_marker-1110356){.index1}

[]{#index.htm_pgfId-434845 .calibre17}[Podman container in systemd mode
131](#07.htm_marker-1116574){.index1} --
[132](#07.htm_marker-1110435){.index1}

[]{#index.htm_pgfId-434848 .calibre17}[running Apache Service within
systemd container 132](#07.htm_marker-1110440){.index1} --
[134](#07.htm_marker-1110497){.index1}

[]{#index.htm_pgfId-434851 .calibre17}[services
168](#09.htm_marker-1112574){.index1} --
[171](#09.htm_marker-1109560){.index1}

[]{#index.htm_pgfId-434854 .calibre17}[socket-activated Podman
containers 147](#07.htm_marker-1110994){.index1} --
[149](#07.htm_marker-1111047){.index1}

[]{#index.htm_pgfId-434857 .calibre17}[starting containers at boot
137](#07.htm_marker-1110634){.index1} --
[145](#07.htm_marker-1117752){.index1}

[]{#index.htm_pgfId-434860 .calibre17}[automatically updating Podman
containers 142](#07.htm_marker-1110843){.index1} --
[145](#07.htm_marker-1117749){.index1}

[]{#index.htm_pgfId-434863 .calibre17}[distributing systemd unit files
to manage Podman containers 141](#07.htm_marker-1110770){.index1} --
[142](#07.htm_marker-1110838){.index1}

[]{#index.htm_pgfId-434866 .calibre17}[Podman containers as systemd
services 138](#07.htm_marker-1110687){.index1} --
[141](#07.htm_marker-1110765){.index1}

[]{#index.htm_pgfId-434869 .calibre17}[restarting containers
137](#07.htm_marker-1110639){.index1}

[]{#index.htm_pgfId-434871 .calibre17}[- -systemd=always flag
131](#07.htm_marker-1116578){.index1}

[]{#index.htm_pgfId-434873 .calibre17}T[]{#index.htm_T .calibre17}

[]{#index.htm_pgfId-434875 .calibre17}[-t 0 option
34](#02.htm_marker-1037711){.index1}

[]{#index.htm_pgfId-434877 .calibre17}[tag command
66](#02.htm_marker-1039278){.index1}

[]{#index.htm_pgfId-434879 .calibre17}[tagging images
50](#02.htm_marker-1038513){.index1} --
[52](#02.htm_marker-1038571){.index1}

[]{#index.htm_pgfId-434882 .calibre17}[TAG heading
44](#02.htm_marker-1044996){.index1}

[]{#index.htm_pgfId-434884 .calibre17}[- -tag option
64](#02.htm_marker-1039036){.index1}

[]{#index.htm_pgfId-434886 .calibre17}[time container
83](#04.htm_marker-1104888){.index1}

[]{#index.htm_pgfId-434888 .calibre17}[- -time option
168](#09.htm_marker-1109463){.index1}

[]{#index.htm_pgfId-434890 .calibre17}[- -timeout (-t) option
35](#02.htm_marker-1037721){.index1},
[85](#04.htm_marker-1103942){.index1}

[]{#index.htm_pgfId-434893 .calibre17}[tmpfs mount type
117](#06.htm_marker-1112582){.index1}

[]{#index.htm_pgfId-434895 .calibre17}[tools
232](#A.htm_marker-1277655){.index1} --
[245](#A.htm_marker-1278274){.index1}

[]{#index.htm_pgfId-434898 .calibre17}[Buildah
237](#A.htm_marker-1277859){.index1} --
[244](#A.htm_marker-1278257){.index1}

[]{#index.htm_pgfId-434901 .calibre17}[adding content to working
container directly from host 240](#A.htm_marker-1278003){.index1} --
[241](#A.htm_marker-1278028){.index1}

[]{#index.htm_pgfId-434904 .calibre17}[adding data to working container
239](#A.htm_marker-1277918){.index1}

[]{#index.htm_pgfId-434906 .calibre17}[as library
244](#A.htm_marker-1278252){.index1}

[]{#index.htm_pgfId-434908 .calibre17}[building images from
Containerfiles 243](#A.htm_marker-1278219){.index1} --
[244](#A.htm_marker-1278247){.index1}

[]{#index.htm_pgfId-434911 .calibre17}[configuring working container
241](#A.htm_marker-1278033){.index1} --
[242](#A.htm_marker-1278147){.index1}

[]{#index.htm_pgfId-434914 .calibre17}[creating images from working
container 242](#A.htm_marker-1278151){.index1} --
[243](#A.htm_marker-1278182){.index1}

[]{#index.htm_pgfId-434917 .calibre17}[creating working container from
base image 238](#A.htm_marker-1282679){.index1} --
[239](#A.htm_marker-1277913){.index1}

[]{#index.htm_pgfId-434920 .calibre17}[pushing images to container
registry 243](#A.htm_marker-1278190){.index1}

[]{#index.htm_pgfId-434922 .calibre17}[running commands in working
container 239](#A.htm_marker-1277941){.index1} --
[240](#A.htm_marker-1277959){.index1}

[]{#index.htm_pgfId-434925 .calibre17}[CRI-O (Container Runtime
Interface for OCI containers) 244](#A.htm_marker-1278261){.index1} --
[245](#A.htm_marker-1278272){.index1}

[]{#index.htm_pgfId-434928 .calibre17}[Skopeo
235](#A.htm_marker-1280942){.index1} --
[236](#A.htm_marker-1277807){.index1}

[]{#index.htm_pgfId-434931 .calibre17}[top command
41](#02.htm_marker-1044892){.index1},
[86](#04.htm_marker-1107372){.index1}

[]{#index.htm_pgfId-434934 .calibre17}[-t option
29](#02.htm_marker-1037561){.index1}

[]{#index.htm_pgfId-434936 .calibre17}[transport:ImageName format
46](#02.htm_marker-1038376){.index1}

[]{#index.htm_pgfId-434938 .calibre17}transports

[]{#index.htm_pgfId-434939 .calibre17}[container registry (Docker)
transport 25](#01.htm_marker-1035270){.index1},
[47](#02.htm_marker-1045311){.index1},
[235](#A.htm_marker-1280406){.index1}

[]{#index.htm_pgfId-434943 .calibre17}[containers-storage transport
236](#A.htm_marker-1277791){.index1}

[]{#index.htm_pgfId-434945 .calibre17}[container-storage transport
25](#01.htm_marker-1035276){.index1},
[48](#02.htm_marker-1045316){.index1},
[236](#A.htm_marker-1280412){.index1}

[]{#index.htm_pgfId-434949 .calibre17}[Podman and multiple
25](#01.htm_marker-1032160){.index1}

[]{#index.htm_pgfId-434951 .calibre17}[pushing images
46](#02.htm_marker-1038372){.index1} --
[48](#02.htm_marker-1045225){.index1}

[]{#index.htm_pgfId-434954 .calibre17}[tree command
66](#02.htm_marker-1039277){.index1}

[]{#index.htm_pgfId-434956 .calibre17}[trust command
66](#02.htm_marker-1039276){.index1}

[]{#index.htm_pgfId-434958 .calibre17}[- -tty -(t) option
34](#02.htm_marker-1037684){.index1},
[39](#02.htm_marker-1037904){.index1}

[]{#index.htm_pgfId-434961 .calibre17}[type enforcement, SELinux
207](#10.htm_marker-1120087){.index1} --
[210](#10.htm_marker-1114947){.index1}

[]{#index.htm_pgfId-434964 .calibre17}U[]{#index.htm_U .calibre17}

[]{#index.htm_pgfId-434966 .calibre17}[uay.io registry
56](#02.htm_marker-1045447){.index1}

[]{#index.htm_pgfId-434968 .calibre17}[UBI (Universal Base Images)
27](#02.htm_marker-1037530){.index1}

[]{#index.htm_pgfId-434970 .calibre17}[Ubuntu
257](#C.htm_marker-1284971){.index1}

[]{#index.htm_pgfId-434972 .calibre17}[\$UID environment variable
93](#05.htm_marker-1105624){.index1}

[]{#index.htm_pgfId-434974 .calibre17}UIDs (user identifiers)

[]{#index.htm_pgfId-434975 .calibre17}[images containing content owned
by multiple 110](#06.htm_marker-1113923){.index1} --
[117](#06.htm_marker-1110573){.index1}

[]{#index.htm_pgfId-434978 .calibre17}[mount namespace
115](#06.htm_marker-1110516){.index1} --
[116](#06.htm_marker-1110552){.index1}

[]{#index.htm_pgfId-434981 .calibre17}[user namespace
111](#06.htm_marker-1110393){.index1} --
[115](#06.htm_marker-1110511){.index1}

[]{#index.htm_pgfId-434984 .calibre17}[user namespace and mount
namespace 117](#06.htm_marker-1110560){.index1}

[]{#index.htm_pgfId-434986 .calibre17}[isolation
198](#10.htm_marker-1114464){.index1} --
[204](#10.htm_marker-1114641){.index1}

[]{#index.htm_pgfId-434989 .calibre17}[isolating containers using -
-userns=auto flag 199](#10.htm_marker-1114477){.index1}

[]{#index.htm_pgfId-434991 .calibre17}[isolating containers using -
-userns-auto flag 199](#10.htm_marker-1123372){.index1} --
[200](#10.htm_marker-1114508){.index1}

[]{#index.htm_pgfId-434994 .calibre17}[rootless Podman with -
-userns=auto flag 202](#10.htm_marker-1114569){.index1}

[]{#index.htm_pgfId-434996 .calibre17}[user namespaced Linux
capabilities 201](#10.htm_marker-1114538){.index1} --
[202](#10.htm_marker-1114562){.index1}

[]{#index.htm_pgfId-434999 .calibre17}[user volumes with - -userns=auto
flag 202](#10.htm_marker-1114591){.index1} --
[204](#10.htm_marker-1114638){.index1}

[]{#index.htm_pgfId-435002 .calibre17}[unconfined label
74](#03.htm_marker-1048790){.index1}

[]{#index.htm_pgfId-435004 .calibre17}[unconfined_t type
209](#10.htm_marker-1114865){.index1}

[]{#index.htm_pgfId-435006 .calibre17}[unmasking masked paths
192](#10.htm_marker-1114166){.index1} --
[193](#10.htm_marker-1123818){.index1}

[]{#index.htm_pgfId-435009 .calibre17}[unmount command
41](#02.htm_marker-1044893){.index1},
[66](#02.htm_marker-1039275){.index1}

[]{#index.htm_pgfId-435012 .calibre17}[unpause command
41](#02.htm_marker-1044894){.index1},
[86](#04.htm_marker-1107373){.index1}

[]{#index.htm_pgfId-435015 .calibre17}[unqualified-search-registries
option 97](#05.htm_marker-1105778){.index1}

[]{#index.htm_pgfId-435017 .calibre17}[untag command
66](#02.htm_marker-1039274){.index1}

[]{#index.htm_pgfId-435019 .calibre17}[update command
249](#B.htm_marker-1282957){.index1}

[]{#index.htm_pgfId-435021 .calibre17}updates

[]{#index.htm_pgfId-435022 .calibre17}[Fedora
279](#F.htm_marker-1289926){.index1}

[]{#index.htm_pgfId-435024 .calibre17}[rolling back failed containers
after 147](#07.htm_marker-1110994){.index1}

[]{#index.htm_pgfId-435026 .calibre17}[systemd timers triggering Podman
updates 145](#07.htm_marker-1110939){.index1}

[]{#index.htm_pgfId-435028 .calibre17}[user account
275](#F.htm_marker-1289780){.index1}

[]{#index.htm_pgfId-435030 .calibre17}useradd

[]{#index.htm_pgfId-435031 .calibre17}[command
112](#06.htm_marker-1110417){.index1}

[]{#index.htm_pgfId-435033 .calibre17}[program
112](#06.htm_marker-1110407){.index1}

[]{#index.htm_pgfId-435035 .calibre17}[tool
104](#05.htm_marker-1108998){.index1}

[]{#index.htm_pgfId-435037 .calibre17}[USER instruction
40](#02.htm_marker-1037957){.index1},
[242](#A.htm_marker-1280884){.index1}

[]{#index.htm_pgfId-435040 .calibre17}[- -username option
49](#02.htm_marker-1038494){.index1}

[]{#index.htm_pgfId-435042 .calibre17}[user namespace
26](#01.htm_marker-1032224){.index1},
[111](#06.htm_marker-1110392){.index1} --
[115](#06.htm_marker-1110510){.index1},
[117](#06.htm_marker-1110559){.index1}

[]{#index.htm_pgfId-435047 .calibre17}[user namespaced Linux
capabilities 201](#10.htm_marker-1114537){.index1} --
[202](#10.htm_marker-1114561){.index1}

[]{#index.htm_pgfId-435050 .calibre17}[- -userns=auto flag
201](#10.htm_marker-1114545){.index1} --
[202](#10.htm_marker-1114586){.index1}

[]{#index.htm_pgfId-435053 .calibre17}[isolating containers using
199](#10.htm_marker-1114476){.index1} --
[200](#10.htm_marker-1114507){.index1}

[]{#index.htm_pgfId-435056 .calibre17}[rootless Podman with
202](#10.htm_marker-1114568){.index1}

[]{#index.htm_pgfId-435058 .calibre17}[user volumes with
202](#10.htm_marker-1114590){.index1} --
[204](#10.htm_marker-1114637){.index1}

[]{#index.htm_pgfId-435061 .calibre17}[- -user option
33](#02.htm_marker-1037680){.index1},
[163](#08.htm_marker-1119050){.index1},
[170](#09.htm_marker-1109498){.index1}

[]{#index.htm_pgfId-435065 .calibre17}[USER_START audit log entry
219](#11.htm_marker-1121732){.index1}

[]{#index.htm_pgfId-435067 .calibre17}[U volume option
72](#03.htm_marker-1048742){.index1} --
[73](#03.htm_marker-1048775){.index1}

[]{#index.htm_pgfId-435070 .calibre17}V[]{#index.htm_V .calibre17}

[]{#index.htm_pgfId-435072 .calibre17}[vfs storage driver
95](#05.htm_marker-1108316){.index1}

[]{#index.htm_pgfId-435074 .calibre17}[virtualization technologies
9](#01.htm_marker-1031649){.index1}

[]{#index.htm_pgfId-435076 .calibre17}VM (virtual machine)

[]{#index.htm_pgfId-435077 .calibre17}[isolation
214](#10.htm_marker-1115149){.index1} --
[215](#10.htm_marker-1115156){.index1}

[]{#index.htm_pgfId-435080 .calibre17}[starting
267](#E.htm_marker-1286601){.index1} --
[268](#E.htm_marker-1286640){.index1}

[]{#index.htm_pgfId-435083 .calibre17}[stopping
268](#E.htm_marker-1286647){.index1}

[]{#index.htm_pgfId-435085 .calibre17}[- -volume flag U
203](#10.htm_marker-1114607){.index1}

[]{#index.htm_pgfId-435087 .calibre17}[- -volume HOST-DIR:CONTAINER-DIR
option 68](#03.htm_marker-1048618){.index1}

[]{#index.htm_pgfId-435089 .calibre17}[VOLUME instruction
40](#02.htm_marker-1037958){.index1},
[242](#A.htm_marker-1280885){.index1}

[]{#index.htm_pgfId-435092 .calibre17}[volume list command
71](#03.htm_marker-1051690){.index1}

[]{#index.htm_pgfId-435094 .calibre17}[- -volume option
69](#03.htm_marker-1051591){.index1},
[183](#09.htm_marker-1116034){.index1}

[]{#index.htm_pgfId-435097 .calibre17}[volumes
67](#03.htm_marker-1051546){.index1} --
[74](#03.htm_marker-1053255){.index1}

[]{#index.htm_pgfId-435100 .calibre17}[named volumes
70](#03.htm_marker-1048656){.index1} --
[72](#03.htm_marker-1048726){.index1}

[]{#index.htm_pgfId-435103 .calibre17}[volume mount options
72](#03.htm_marker-1048731){.index1} --
[74](#03.htm_marker-1053223){.index1}

[]{#index.htm_pgfId-435106 .calibre17}[SELinux volume options
73](#03.htm_marker-1048779){.index1} --
[74](#03.htm_marker-1053206){.index1}

[]{#index.htm_pgfId-435109 .calibre17}[U volume option
72](#03.htm_marker-1048741){.index1} --
[73](#03.htm_marker-1048774){.index1}

[]{#index.htm_pgfId-435112 .calibre17}[- -volume (-v) option
68](#03.htm_marker-1048617){.index1}

[]{#index.htm_pgfId-435114 .calibre17}W[]{#index.htm_W .calibre17}

[]{#index.htm_pgfId-435116 .calibre17}[wait command
42](#02.htm_marker-1038212){.index1}

[]{#index.htm_pgfId-435118 .calibre17}[webdata volume
70](#03.htm_marker-1048662){.index1}

[]{#index.htm_pgfId-435120 .calibre17}[Windows
255](#C.htm_marker-1284805){.index1} --
[256](#C.htm_marker-1284828){.index1},
[269](#F.htm_marker-1290859){.index1} --
[280](#F.htm_marker-1289974){.index1}

[]{#index.htm_pgfId-435125 .calibre17}[installing Podman
271](#F.htm_marker-1289621){.index1} --
[272](#F.htm_marker-1292573){.index1}

[]{#index.htm_pgfId-435128 .calibre17}[prerequisites
270](#F.htm_marker-1289611){.index1} --
[271](#F.htm_marker-1289617){.index1}

[]{#index.htm_pgfId-435131 .calibre17}[using podman machine
272](#F.htm_marker-1292506){.index1} --
[279](#F.htm_marker-1289962){.index1}

[]{#index.htm_pgfId-435134 .calibre17}[advanced stopping and restarting
279](#F.htm_marker-1289946){.index1}

[]{#index.htm_pgfId-435136 .calibre17}[listing machines
278](#F.htm_marker-1289890){.index1}

[]{#index.htm_pgfId-435138 .calibre17}[Podman machine init
273](#F.htm_marker-1293020){.index1} --
[275](#F.htm_marker-1289736){.index1}

[]{#index.htm_pgfId-435141 .calibre17}[Podman machine SSH configuration
275](#F.htm_marker-1289775){.index1} --
[276](#F.htm_marker-1289807){.index1}

[]{#index.htm_pgfId-435144 .calibre17}[starting WSL 2 instance
276](#F.htm_marker-1289812){.index1} --
[277](#F.htm_marker-1289855){.index1}

[]{#index.htm_pgfId-435147 .calibre17}[stopping WSL 2 instance
277](#F.htm_marker-1289871){.index1}

[]{#index.htm_pgfId-435149 .calibre17}[updating Fedora
279](#F.htm_marker-1289925){.index1}

[]{#index.htm_pgfId-435151 .calibre17}[using Podman at WSL prompt
278](#F.htm_marker-1289907){.index1}

[]{#index.htm_pgfId-435153 .calibre17}[using podman machine commands
277](#F.htm_marker-1289860){.index1}

[]{#index.htm_pgfId-435155 .calibre17}[Windows remote client
255](#C.htm_marker-1286527){.index1} --
[256](#C.htm_marker-1286533){.index1}

[]{#index.htm_pgfId-435158 .calibre17}[wsl - -shutdown command
279](#F.htm_marker-1289955){.index1}

[]{#index.htm_pgfId-435160 .calibre17}[wsl - -terminate command
279](#F.htm_marker-1289954){.index1}

[]{#index.htm_pgfId-435162 .calibre17}[WSL (Windows subsystem for Linux)
2.0 256](#C.htm_marker-1284822){.index1}

[]{#index.htm_pgfId-435164 .calibre17}[installation
272](#F.htm_marker-1292567){.index1}

[]{#index.htm_pgfId-435166 .calibre17}[prompt, using Podman at
278](#F.htm_marker-1289906){.index1}

[]{#index.htm_pgfId-435168 .calibre17}[starting
276](#F.htm_marker-1289811){.index1} --
[277](#F.htm_marker-1289854){.index1}

[]{#index.htm_pgfId-435171 .calibre17}[stopping
277](#F.htm_marker-1289870){.index1}

[]{#index.htm_pgfId-435173 .calibre17}[Windows remote client
255](#C.htm_marker-1286526){.index1} --
[256](#C.htm_marker-1286532){.index1}

[]{#index.htm_pgfId-435176 .calibre17}[- -workdir command option
82](#04.htm_marker-1104510){.index1}

[]{#index.htm_pgfId-435178 .calibre17}[WORKDIR containerfile instruction
241](#A.htm_marker-1278038){.index1} --
[242](#A.htm_marker-1280886){.index1}

[]{#index.htm_pgfId-435181 .calibre17}[world permission
113](#06.htm_marker-1110450){.index1}

[]{#index.htm_pgfId-435183 .calibre17}[write syscall
213](#10.htm_marker-1115110){.index1}

[]{#index.htm_pgfId-435185 .calibre17}Y[]{#index.htm_X
.calibre17}[]{#index.htm_Y .calibre17}

[]{#index.htm_pgfId-435188 .calibre17}[yum install tool
238](#A.htm_marker-1282679){.index1}

[]{#index.htm_pgfId-435190 .calibre17}[yum tool
24](#01.htm_marker-1032147){.index1}

[]{#index.htm_pgfId-435192 .calibre17}Z[]{#index.htm_Z .calibre17}

[]{#index.htm_pgfId-435194 .calibre17}[zfs storage driver
95](#05.htm_marker-1108321){.index1}

[]{#index.htm_pgfId-435196 .calibre17}[zombie processes
129](#07.htm_marker-1110322){.index1}

[]{#index.htm_pgfId-435198 .calibre17}[z option
72](#03.htm_marker-1048736){.index1} --
[73](#03.htm_marker-1048784){.index1},
[81](#04.htm_marker-1103817){.index1}
