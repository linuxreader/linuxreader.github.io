### Managing Ansible Errors and Logs

#### Using Check Mode


Before actually running a playbook in a way that all changes are
implemented, you can start the playbooks in check mode. To do this, you
use the **\--check** or **-C** command-line argument to the **ansible**
or **ansible-playbook** command. The effect of using check mode is that
changes that would have been made are shown but not executed. You should
realize, though, that check mode is not supported in all cases. You
will, for instance, have problems with check mode if it is applied to
conditionals, where a specific task can do its work only after a
preceding task has made some changes. Also, to successfully use check
mode, the modules need to support it, but some don't. Modules that don't
support check mode don't show any result while running check mode, but
also they don't make any changes.

Apart from the command-line argument, you can use **check_mode: yes** or
**check_mode: no** with any task in a playbook. If **check_mode: yes**
is used, the task always runs in check mode (and does not implement any
changes), regardless of the use of the **\--check** option. If a task
has **check_mode: no** set, it never runs in check mode and just does
its work, even if the **ansible-playbook** command is used with the
**\--check** option. Using check mode on individual tasks might be a
good idea if using check mode on the entire playbook gives unpredicted
results: you can enable it on just a couple of tasks to ensure that they
run successfully before proceeding to the next set of tasks. Notice that
using **check_mode: no** for specific tasks can be dangerous; these
tasks will make changes, even if the entire playbook was started with
the **\--check** option!

::: note

------------------------------------------------------------------------

**Note**

The **check_mode** argument is a replacement for the **always_run**
option that was used in Ansible 2.5 and earlier. In current Ansible
versions, you should not use **always_run** anymore.

Another option that is commonly used with the **\--check** option is
**\--diff**. This option reports changes to template files without
actually applying them. [Listing 11-1](#ch11.xhtml#list11_1) shows a
sample playbook, [Listing 11-2](#ch11.xhtml#list11_2) shows the template
that it is processing, and [Listing 11-3](#ch11.xhtml#list11_3) shows
the result of running this playbook with the **ansible-playbook
listing111.yaml \--check \--diff** command.

------------------------------------------------------------------------
```yaml
    ---
    - name: simple template example
      hosts: ansible2
      tasks:
      - template:
          src: listing112.j2
          dest: /etc/issue
:::

**Listing 11-2** Sample Template File

::: pre_1
    {# /etc/issue #}
    Welcome to {{ ansible_facts[’hostname’] }}
:::

**Listing 11-3** Running the listing111.yaml Sample Playbook

::: pre_1
    [ansible@control rhce8-book]$ ansible-playbook listing111.yaml --check --diff
    
    PLAY [simple template example] *************************************************
    
    TASK [Gathering Facts] *********************************************************
    ok: [ansible2]
    
    TASK [template] ****************************************************************
    --- before
    +++ after: /home/ansible/.ansible/tmp/ansible-local-4493uxbpju1e/tmpm5gn7crg/listing112.j2
    @@ -0,0 +1,3 @@
    +Welcome to ansible2
    +
    +
    
    changed: [ansible2]
    
    PLAY RECAP *********************************************************************
    ansible2                   : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```
#### Understanding Output

When you run the **ansible-playbook** command, output is generated.
You've probably had a glimpse of it before, but let's look at the output
in a more structured way now. [Listing 11-4](#ch11.xhtml#list11_4) shows
some typical sample output generated by running the **ansible-playbook**
command.

**Listing 11-4 ansible-playbook** Command Output

::: pre_1
    [ansible@control rhce8-book]$ ansible-playbook listing52.yaml
    
    PLAY [install start and enable httpd] ******************************************
    
    TASK [Gathering Facts] *********************************************************
    ok: [ansible2]
    ok: [ansible1]
    ok: [ansible3]
    ok: [ansible4]
    
    TASK [install package] *********************************************************
    changed: [ansible2]
    changed: [ansible1]
    changed: [ansible3]
    changed: [ansible4]
    
    TASK [start and enable service] ************************************************
    changed: [ansible2]
    changed: [ansible1]
    changed: [ansible3]
    changed: [ansible4]
    
    PLAY RECAP *********************************************************************
    ansible1                   : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
    ansible2                   : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
    ansible3                   : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
    ansible4                   : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
:::

In the output of any **ansible-playbook** command, you can see different
items:

![Image](/Images/key_topic_icon.jpg){width="64" height="51"}

• An indicator of the play that is started

• If not disabled, the Gathering Facts task that is executed for each
play

• Each individual task, including the task name if that was specified

• The Play Recap, which summarizes the play results

In the Play Recap, different results can be shown. [Table
11-2](#ch11.xhtml#tab11_2) gives an overview.

::: group
**Table 11-2** Playbook Recap Overview

![Image](/Images/11tab02.jpg){width="941" height="338"}
:::

As discussed before, when you use the **ansible-playbook** command, you
can increase the output verbosity level using one or more **-v**
options. [Table 11-3](#ch11.xhtml#tab11_3) lists what these options
accomplish. For generic troubleshooting, you might want to consider
using **-vv**, which shows output as well as input data. In particular
cases using the **-vvv** option can be useful because it adds connection
information as well.

The **-vvvv** option just brings too much information in many cases but
can be useful if you need to analyze which exact scripts are executed or
whether any problems were encountered in privilege escalation. Make sure
to capture the output of any command that runs with **-vvvv** to a text
file, though, so that you can read it in an easy way. Even for a simple
playbook, it can easily generate more than 10 screens of output.

::: group
**Table 11-3** Verbosity Options Overview

![Image](/Images/11tab03.jpg){width="941" height="209"}
:::

In [Listing 11-5](#ch11.xhtml#list11_5) you can see the output of a
small playbook that runs different tasks on the managed hosts. [Listing
11-5](#ch11.xhtml#list11_5) shows details about execution of one task on
host ansible4, and as you can see, it goes deep in the amount of detail
that is shown. One component is worth looking at, and that is the
escalation succeeded that you can see in the output. This means that
privilege escalation was successful and tasks were executed because
**become_user** was defined in ansible.cfg. Failing privilege escalation
is one of the common reasons why playbook execution may go wrong, which
is why it's worth keeping an eye on this indicator.

**Listing 11-5** Analyzing Partial **-vvvv** Output

```
    <ansible4> ESTABLISH SSH CONNECTION FOR USER: ansible
    <ansible4> SSH: EXEC ssh -vvv -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ’User="ansible"’ -o ConnectTimeout=10 -o ControlPath=/home/ansible/.ansible/cp/859d5267e3 ansible4 ’/bin/sh -c ’"’"’chmod u+x /home/ansible/.ansible/tmp/ansible-tmp-1587544652.4716983-118789810824208/ /home/ansible/.ansible/tmp/ansible-tmp-1587544652.4716983-118789810824208/AnsiballZ_systemd.py && sleep 0’"’"’’
    Escalation succeeded
    <ansible4> (0, b’’, b"OpenSSH_8.0p1, OpenSSL 1.1.1c FIPS  28 May 2019\r\ndebug1: Reading configuration data /etc/ssh/ssh_config\r\ndebug3: /etc/ssh/ssh_config line 51: Including file /etc/ssh/ssh_config.d/05-redhat.conf depth 0\r\ndebug1: Reading configuration data /etc/ssh/ssh_config.d/05-redhat.conf\r\ndebug2: checking match for ’final all’ host ansible4 originally ansible4\r\ndebug3: /etc/ssh/ssh_config.d/05-redhat.conf line 3: not matched ’final’\r\ndebug2: match not found\r\ndebug3: /etc/ssh/ssh_config.d/05-redhat.conf line 5: Including file /etc/crypto-policies/back-ends/openssh.config depth 1 (parse only)\r\ndebug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.config\r\ndebug3: gss kex names ok: [gss-gex-sha1-,gss-group14-sha1-]\r\ndebug3: kex names ok: [curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1]\r\ndebug1: configuration requests final Match pass\r\ndebug1: re-parsing configuration\r\ndebug1: Reading configuration data /etc/ssh/ssh_config\r\ndebug3: /etc/ssh/ssh_config line 51: Including file /etc/ssh/ssh_config.d/05-redhat.conf depth 0\r\ndebug1: Reading configuration data /etc/ssh/ssh_config.d/05-redhat.conf\r\ndebug2: checking match for ’final all’ host ansible4 originally ansible4\r\ndebug3: /etc/ssh/ssh_config.d/05-redhat.conf line 3: matched ’final’\r\ndebug2: match found\r\ndebug3: /etc/ssh/ssh_config.d/05-redhat.conf line 5: Including file /etc/crypto-policies/back-ends/openssh.config depth 1\r\ndebug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.config\r\ndebug3: gss kex names ok: [gss-gex-sha1-,gss-group14-sha1-]\r\ndebug3: kex names ok: [curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1]\r\ndebug1: auto-mux: Trying existing master\r\ndebug2: fd 4 setting O_NONBLOCK\r\ndebug2: mux_client_hello_exchange: master version 4\r\ndebug3: mux_client_forwards: request forwardings: 0 local, 0 remote\r\ndebug3: mux_client_request_session: entering\r\ndebug3: mux_client_request_alive: entering\r\ndebug3: mux_client_request_alive: done pid = 4764\r\ndebug3: mux_client_request_session: session request sent\r\ndebug3: mux_client_read_packet: read header failed: Broken pipe\r\ndebug2: Received exit status from master 0\r\n")
    <ansible4> ESTABLISH SSH CONNECTION FOR USER: ansible
    <ansible4> SSH: EXEC ssh -vvv -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ’User="ansible"’ -o ConnectTimeout=10 -o ControlPath=/home/ansible/.ansible/cp/859d5267e3 -tt ansible4 ’/bin/sh -c ’"’"’sudo -H -S -n  -u root /bin/sh -c ’"’"’"’"’"’"’"’"’echo BECOME-SUCCESS-muvtpdvqkslnlegyhoibfcrilvlyjcqp ; /usr/libexec/platform-python /home/ansible/.ansible/tmp/ansible-tmp-1587544652.4716983-118789810824208/AnsiballZ_systemd.py’"’"’"’"’"’"’"’"’ && sleep 0’"’"’’
    Escalation succeeded
```

#### Optimizing Command Output Error Formatting

You might have noticed that the formatting of error messages in Ansible
command output can be a bit hard to read. Fortunately, there's an easy
way to make it a little more readable by including two options in the
ansible.cfg file. These options are **stdout_callback = debug** and
**stdout_callback = error**. After including these options, you'll
notice it's a lot easier to read error output and distinguish between
its different components!

#### Logging to Files {.h4}

By default, Ansible does not write anything to log files. The reason is
that the Ansible commands have all the options that may be useful to
write output to the STDOUT. If so required, it's always possible to use
shell redirection to write the command output to a file.

If you do need Ansible to write log files, you can set the **log_path**
parameter in ansible.cfg. Alternatively, Ansible can log to the filename
that is specified as the argument to the \$ANSIBLE_LOG_PATH variable.
Notice that Ansible logs can grow big very fast, so if logging to output
files is enabled, make sure that Linux log rotation is configured to
ensure that files cannot grow beyond a specific maximum size.

#### Running Task by Task {.h4}

When you analyze playbook behavior, it's possible to run playbook tasks
one by one or to start running a playbook at a specific task. The
**ansible-playbook \--step** command runs playbooks task by task and
prompts for confirmation before running the next task. Alternatively,
you can use the **ansible-playbook \--start-at-task=\"task name\"**
command to start playbook execution as a specific task. Before using
this command, you might want to use **ansible-playbook \--list-tasks**
for a list of all tasks that have been configured. To use these options
in an efficient way, you must configure each task with its own name. In
[Listing 11-6](#ch11.xhtml#list11_6) you can see what running playbooks
this way looks like. This listing first shows how to list tasks in a
playbook and next how the **\--start-at-task** and **\--step** options
are used.

**Listing 11-6** Running Tasks One by One

::: pre_1
    [ansible@control rhce8-book]$ ansible-playbook --list-tasks exercise81.yaml
    
    playbook: exercise81.yaml
    
      play #1 (ansible1): testing file manipulation skills.    TAGS: []
        tasks:
          create a new file              TAGS: []
          check status of the new file   TAGS: []
          for debugging purposes only    TAGS: []
          change file owner if needed    TAGS: []
    
      play #2 (ansible1): fetching a remote file.    TAGS: []
        tasks:
          fetch file from remote machine.    TAGS: []
    
      play #3 (localhost): adding text to the file that is now on localhost TAGS: []
        tasks:
          add a message.    TAGS: []
    
      play #4 (ansible2): copy the modified file to ansible2.    TAGS: []
        tasks:
          copy motd file.    TAGS: []
    [ansible@control rhce8-book]$ ansible-playbook --start-at-task "add a message"  --step exercise81.yaml
    
    PLAY [testing file manipulation skills] ****************************************
    
    PLAY [fetching a remote file] **************************************************
    
    PLAY [adding text to the file that is now on localhost] ************************
    Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue:
:::

In [Exercise 11-1](#ch11.xhtml#exe11_1) you learn how to apply check
mode while working with templates.

::: box
**Exercise 11-1 Using Templates in Check Mode**

1\. Locate the file httpd.conf; you can find it in the rhce8-book
directory, which you can download from the GitHub repository at
<https://github.com/sandervanvugt/rhce8-book>. Use **mv httpd.conf
exercise111-httpd.j2** to rename it to a Jinja2 template file.

2\. Open the exercise111-httpd.j2 file with an editor, and apply
modifications to existing parameters so that they look like the
following:

``` pre1
ServerRoot "{{ apache_root }}"
User {{ apache_user }}
Group {{ apache_group }}
```

3\. Write a playbook that takes care of the complete Apache web server
setup and installation, starts and enables the service, opens a port in
the firewall, and uses the template module to create the
/etc/httpd/conf/httpd.conf file based on the template that you created
in step 2 of this exercise. The complete playbook with the name
exercise111.yaml looks like the following (make sure you have the
*exact* contents shown below and do *not* correct any typos):

``` pre1
---
- name: perform basic apache setup
  hosts: ansible2
  vars:
    apache_root: /etc/httpd
    apache_user: httpd
    apache_group: httpd
  tasks:
  - name: install RPM package
    yum:
      name: httpd
      state: latest
  - name: copy template file
    template:
      src: exercise111-httpd.j2
      dest: /etc/httpd/httpd.conf
  - name: start and enable service
    service:
      name: httpd
      state: started
      enabled: yes
  - name: open port in firewall
    firewalld:
      service: http
      permanent: yes
      state: enabled
      immediate: yes
```

4\. Run the command **ansible-playbook \--syntax-check
exercise111.yaml**. If no errors are found in the playbook syntax, you
should just see the name of the playbook.

5\. Run the command **ansible-playbook \--check \--diff
exercise111.yaml**. In the output of the command, pay attention to the
task copy template file. After the line that starts with **+++ after**,
you should see the lines in the template that were configured to use a
variable, using the right variables.

6\. Run the playbook to perform all its tasks step by step, using the
command **ansible-playbook \--step exercise111.yaml**. Press **y** to
confirm the first step. Next, press **c** to automatically continue. The
playbook will fail on the copy template file task because the target
directory does not exist. Notice that the **\--syntax-check** and the
**\--check** options do not check for any logical errors in the playbook
and for that reason have not detected this problem.

7\. Edit the exercise111.yaml file and ensure the **template** task
contains the following corrected line: (replace the old line starting
with **dest:**):

``` pre1
dest: /etc/httpd/conf/httpd.conf
```

8\. Type **ansible-playbook \--list-tasks exercise111.yaml** to list all
the tasks in the playbook.

9\. To avoid running the entire playbook again, use **ansible-playbook
\--start-at-task=\"copy template file\" exercise111.yaml** to run the
playbook to completion.
:::