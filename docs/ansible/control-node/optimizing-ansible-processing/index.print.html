<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.152.2">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Optimizing Ansible Processing Parallel task execution
manages the number of hosts on which tasks are executed simultaneously. Serial task execution tasks are executed on a host or group of hosts before proceeding to the next host or group of hosts. Parallel Task Execution Ansible can run tasks on all hosts at the same time, and in many cases that would not be a problem because processing is executed on the managed host anyway. If, however, network devices or other nodes that do not have their own Python stack are involved, processing needs to be done on the control host. To prevent the control host from being overloaded in that case, the maximum number of simultaneous connections by default is set to 5. You can manage this setting by using the forks parameter in ansible.cfg. Alternatively, you can use the -f option with the ansible and ansible-playbook commands. If only Linux hosts are managed, there is no reason to keep the maximum number of simultaneous tasks much lower than 100. Managing Serial Task Execution While executing tasks, Ansible processes tasks in a playbook one by one. This means that, by default, the first task is executed on all managed hosts. Once that is done, the next task is processed, until all tasks have been executed. There is no specific order in the execution of tasks, so you may see that in one run ansible1 is processed before ansible2, while on another run they might be processed in the opposite order. In some cases, this is undesired behavior. If, for instance, a playbook is used to update a cluster of hosts this way, this would create a situation where the old software has been updated, but the new version has not been started yet and the entire cluster would be down. Use the serial keyword in the play header to configure serial: 3 all tasks are executed on three hosts, and after completely running all tasks on three hosts, the next group of three hosts is handled. Lab: Managing Parallelism Add two more managed nodes with the names ansible3.example.com and ansible4.example.com. Open the inventory file with an editor and add the following lines: ansible3 ansible4 Open the ansible.cfg file and add the line forks = 4 to the [defaults] section. Write a playbook with the name exercise102-install that installs and enables the Apache web server and another playbook with the name exercise102-remove that disables and removes the Apache web server. Run ansible-playbook exercise102-remove.yaml to remove and disable the Apache web server on all hosts. This is just to make sure you start with a clean configuration. Run the playbook to install and run the web server, using time ansible-playbook exercise102-install.yaml, and notice the time it takes to run the playbook. Run ansible-playbook exercise102-remove.yaml again to get back to a clean state. Edit ansible.cfg and change the forks parameter to forks = 2. Run the time ansible-playbook exercise102-install.yaml command again to see how much time it takes now Edit the exercise102-install.yaml playbook and include the line serial: 2 in the play header. Run the ansible-playbook exercise102-remove.yaml command again to get back to a clean state. Run the ansible-playbook exercise102-install.yaml command again and observe that the entire play is executed on two hosts only before the next group of two hosts is taken care of.">
    <meta name="author" content="David Thomas">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:description" content="Optimizing Ansible Processing Parallel task execution
manages the number of hosts on which tasks are executed simultaneously. Serial task execution tasks are executed on a host or group of hosts before proceeding to the next host or group of hosts. Parallel Task Execution Ansible can run tasks on all hosts at the same time, and in many cases that would not be a problem because processing is executed on the managed host anyway. If, however, network devices or other nodes that do not have their own Python stack are involved, processing needs to be done on the control host. To prevent the control host from being overloaded in that case, the maximum number of simultaneous connections by default is set to 5. You can manage this setting by using the forks parameter in ansible.cfg. Alternatively, you can use the -f option with the ansible and ansible-playbook commands. If only Linux hosts are managed, there is no reason to keep the maximum number of simultaneous tasks much lower than 100. Managing Serial Task Execution While executing tasks, Ansible processes tasks in a playbook one by one. This means that, by default, the first task is executed on all managed hosts. Once that is done, the next task is processed, until all tasks have been executed. There is no specific order in the execution of tasks, so you may see that in one run ansible1 is processed before ansible2, while on another run they might be processed in the opposite order. In some cases, this is undesired behavior. If, for instance, a playbook is used to update a cluster of hosts this way, this would create a situation where the old software has been updated, but the new version has not been started yet and the entire cluster would be down. Use the serial keyword in the play header to configure serial: 3 all tasks are executed on three hosts, and after completely running all tasks on three hosts, the next group of three hosts is handled. Lab: Managing Parallelism Add two more managed nodes with the names ansible3.example.com and ansible4.example.com. Open the inventory file with an editor and add the following lines: ansible3 ansible4 Open the ansible.cfg file and add the line forks = 4 to the [defaults] section. Write a playbook with the name exercise102-install that installs and enables the Apache web server and another playbook with the name exercise102-remove that disables and removes the Apache web server. Run ansible-playbook exercise102-remove.yaml to remove and disable the Apache web server on all hosts. This is just to make sure you start with a clean configuration. Run the playbook to install and run the web server, using time ansible-playbook exercise102-install.yaml, and notice the time it takes to run the playbook. Run ansible-playbook exercise102-remove.yaml again to get back to a clean state. Edit ansible.cfg and change the forks parameter to forks = 2. Run the time ansible-playbook exercise102-install.yaml command again to see how much time it takes now Edit the exercise102-install.yaml playbook and include the line serial: 2 in the play header. Run the ansible-playbook exercise102-remove.yaml command again to get back to a clean state. Run the ansible-playbook exercise102-install.yaml command again and observe that the entire play is executed on two hosts only before the next group of two hosts is taken care of.">
    <meta property="og:url" content="http://linuxreader.com/ansible/control-node/optimizing-ansible-processing/">
    <meta property="og:site_name" content="Linux Reader">
    <meta property="og:description" content="Optimizing Ansible Processing Parallel task execution
manages the number of hosts on which tasks are executed simultaneously. Serial task execution tasks are executed on a host or group of hosts before proceeding to the next host or group of hosts. Parallel Task Execution Ansible can run tasks on all hosts at the same time, and in many cases that would not be a problem because processing is executed on the managed host anyway. If, however, network devices or other nodes that do not have their own Python stack are involved, processing needs to be done on the control host. To prevent the control host from being overloaded in that case, the maximum number of simultaneous connections by default is set to 5. You can manage this setting by using the forks parameter in ansible.cfg. Alternatively, you can use the -f option with the ansible and ansible-playbook commands. If only Linux hosts are managed, there is no reason to keep the maximum number of simultaneous tasks much lower than 100. Managing Serial Task Execution While executing tasks, Ansible processes tasks in a playbook one by one. This means that, by default, the first task is executed on all managed hosts. Once that is done, the next task is processed, until all tasks have been executed. There is no specific order in the execution of tasks, so you may see that in one run ansible1 is processed before ansible2, while on another run they might be processed in the opposite order. In some cases, this is undesired behavior. If, for instance, a playbook is used to update a cluster of hosts this way, this would create a situation where the old software has been updated, but the new version has not been started yet and the entire cluster would be down. Use the serial keyword in the play header to configure serial: 3 all tasks are executed on three hosts, and after completely running all tasks on three hosts, the next group of three hosts is handled. Lab: Managing Parallelism Add two more managed nodes with the names ansible3.example.com and ansible4.example.com. Open the inventory file with an editor and add the following lines: ansible3 ansible4 Open the ansible.cfg file and add the line forks = 4 to the [defaults] section. Write a playbook with the name exercise102-install that installs and enables the Apache web server and another playbook with the name exercise102-remove that disables and removes the Apache web server. Run ansible-playbook exercise102-remove.yaml to remove and disable the Apache web server on all hosts. This is just to make sure you start with a clean configuration. Run the playbook to install and run the web server, using time ansible-playbook exercise102-install.yaml, and notice the time it takes to run the playbook. Run ansible-playbook exercise102-remove.yaml again to get back to a clean state. Edit ansible.cfg and change the forks parameter to forks = 2. Run the time ansible-playbook exercise102-install.yaml command again to see how much time it takes now Edit the exercise102-install.yaml playbook and include the line serial: 2 in the play header. Run the ansible-playbook exercise102-remove.yaml command again to get back to a clean state. Run the ansible-playbook exercise102-install.yaml command again and observe that the entire play is executed on two hosts only before the next group of two hosts is taken care of.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Ansible">
    <meta itemprop="description" content="Optimizing Ansible Processing Parallel task execution
manages the number of hosts on which tasks are executed simultaneously. Serial task execution tasks are executed on a host or group of hosts before proceeding to the next host or group of hosts. Parallel Task Execution Ansible can run tasks on all hosts at the same time, and in many cases that would not be a problem because processing is executed on the managed host anyway. If, however, network devices or other nodes that do not have their own Python stack are involved, processing needs to be done on the control host. To prevent the control host from being overloaded in that case, the maximum number of simultaneous connections by default is set to 5. You can manage this setting by using the forks parameter in ansible.cfg. Alternatively, you can use the -f option with the ansible and ansible-playbook commands. If only Linux hosts are managed, there is no reason to keep the maximum number of simultaneous tasks much lower than 100. Managing Serial Task Execution While executing tasks, Ansible processes tasks in a playbook one by one. This means that, by default, the first task is executed on all managed hosts. Once that is done, the next task is processed, until all tasks have been executed. There is no specific order in the execution of tasks, so you may see that in one run ansible1 is processed before ansible2, while on another run they might be processed in the opposite order. In some cases, this is undesired behavior. If, for instance, a playbook is used to update a cluster of hosts this way, this would create a situation where the old software has been updated, but the new version has not been started yet and the entire cluster would be down. Use the serial keyword in the play header to configure serial: 3 all tasks are executed on three hosts, and after completely running all tasks on three hosts, the next group of three hosts is handled. Lab: Managing Parallelism Add two more managed nodes with the names ansible3.example.com and ansible4.example.com. Open the inventory file with an editor and add the following lines: ansible3 ansible4 Open the ansible.cfg file and add the line forks = 4 to the [defaults] section. Write a playbook with the name exercise102-install that installs and enables the Apache web server and another playbook with the name exercise102-remove that disables and removes the Apache web server. Run ansible-playbook exercise102-remove.yaml to remove and disable the Apache web server on all hosts. This is just to make sure you start with a clean configuration. Run the playbook to install and run the web server, using time ansible-playbook exercise102-install.yaml, and notice the time it takes to run the playbook. Run ansible-playbook exercise102-remove.yaml again to get back to a clean state. Edit ansible.cfg and change the forks parameter to forks = 2. Run the time ansible-playbook exercise102-install.yaml command again to see how much time it takes now Edit the exercise102-install.yaml playbook and include the line serial: 2 in the play header. Run the ansible-playbook exercise102-remove.yaml command again to get back to a clean state. Run the ansible-playbook exercise102-install.yaml command again and observe that the entire play is executed on two hosts only before the next group of two hosts is taken care of.">
    <meta itemprop="wordCount" content="551">
    <title></title>
    <link href="http://linuxreader.com/ansible/control-node/optimizing-ansible-processing/" rel="canonical" type="text/html" title="">
    <link href="/ansible/control-node/optimizing-ansible-processing/index.xml" rel="alternate" type="application/rss+xml" title="">
    <link href="/images/favicon.svg?1762442645" rel="icon" type="image/svg+xml">
    <link href="/css/auto-complete/auto-complete.min.css?1762442645" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js?1762442645" defer></script>
    <script src="/js/search-lunr.min.js?1762442645" defer></script>
    <script src="/js/search.min.js?1762442645" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/searchindex.en.js?1762442645";
    </script>
    <script src="/js/lunr/lunr.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.multi.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.en.min.js?1762442645" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css?1762442645" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css?1762442645" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css?1762442645" rel="stylesheet">
    <link href="/css/theme.min.css?1762442645" rel="stylesheet">
    <link href="/css/format-print.min.css?1762442645" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/ansible\/control-node\/optimizing-ansible-processing\/';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='http:\/\/linuxreader.com';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'oled' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script><style>
:root {
    --MENU-WIDTH-S: 14.375rem;
    --MENU-WIDTH-M: 14.375rem;
    --MENU-WIDTH-L: 18.75rem;
    --MAIN-WIDTH-MAX: 80rem;
    font-size: 1.2rem;
}
</style>

  </head>
  <body class="mobile-support print" data-url="/ansible/control-node/optimizing-ansible-processing/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/ad-hoc-commands-and-scripting/" title="Ad Hoc Commands and Scripting (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>

            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#optimizing-ansible-processing">Optimizing Ansible Processing</a></li>
        <li><a href="#lab-managing-parallelism">Lab: Managing Parallelism</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>


          </div>
          <span class="topbar-breadcrumbs highlightable">
            
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/control-node/optimizing-ansible-processing/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>

            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/troubleshooting/ansible-documentation/" title="Ansible Documentation (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>







          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable ansible" tabindex="-1">
        <div class="flex-block-wrapper">
        </div>
      </main>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/js/js-yaml/js-yaml.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-color.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-dispatch.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-drag.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-ease.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-interpolate.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-selection.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-timer.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-transition.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-zoom.min.js?1762442645" defer></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js" defer></script>
    <script>
      window.relearn.themeUseMermaid = JSON.parse("{ \"theme\": \"default\" }");
    </script>
    <script src="/js/clipboard/clipboard.min.js?1762442645" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js?1762442645" defer></script>
    <script src="/js/theme.min.js?1762442645" defer></script>
  </body>
</html>
