<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.152.2">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Managing SSH Connections How to provide for SSH keys for new users in such a way that users are provided with SSH keys without having to set them up themselves. To do this, you use the authorized_key module together with theÂ generate_ssh_keyÂ argument to the user module. Understanding SSH Connection Management Requirements How SSH keys are used in the communication process between a user and an SSH server:
The user initiates a session with an SSH server. The server sends back an identification token that is encrypted with the server private key to the user. The user uses the serverâ€™s public key fingerprint, which is stored in the ~/.ssh/known_hosts file to verify the identification token. If no public key fingerprint was stored yet in the ~/.ssh/known_hosts file, the user is prompted to store the remote server identity in the ~/.ssh/known_hosts file. At this point there is no good way to verify whether the user is indeed communicating with the intended server. After establishing the identity of the remote server, the user can either send over a password or generate an authentication token that is based on the userâ€™s private key. If an authentication token that was based on the userâ€™s private key is sent over, this token is received by the server, which tries to match it against the userâ€™s public key that is stored in the ~/.ssh/authorized_keys file. After the incoming authentication token to the stored user public key in the authorized_keys file is matched, the user is authenticated. If this authentication fails and password authentication is allowed, password authentication is attempted next. In the authentication procedure, two key pairs play an important role. First, there is the serverâ€™s public/private key pair, which is used to establish a secure connection. To manage the host public key, you can use the Ansible known_hosts module. Next, there is the userâ€™s public/private key pair, which the user uses to authenticate. To manage the public key in this key pair, you can use the Ansible authorized_key module.">
    <meta name="author" content="David Thomas">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:description" content="Managing SSH Connections How to provide for SSH keys for new users in such a way that users are provided with SSH keys without having to set them up themselves. To do this, you use the authorized_key module together with theÂ generate_ssh_keyÂ argument to the user module. Understanding SSH Connection Management Requirements How SSH keys are used in the communication process between a user and an SSH server:
The user initiates a session with an SSH server. The server sends back an identification token that is encrypted with the server private key to the user. The user uses the serverâ€™s public key fingerprint, which is stored in the ~/.ssh/known_hosts file to verify the identification token. If no public key fingerprint was stored yet in the ~/.ssh/known_hosts file, the user is prompted to store the remote server identity in the ~/.ssh/known_hosts file. At this point there is no good way to verify whether the user is indeed communicating with the intended server. After establishing the identity of the remote server, the user can either send over a password or generate an authentication token that is based on the userâ€™s private key. If an authentication token that was based on the userâ€™s private key is sent over, this token is received by the server, which tries to match it against the userâ€™s public key that is stored in the ~/.ssh/authorized_keys file. After the incoming authentication token to the stored user public key in the authorized_keys file is matched, the user is authenticated. If this authentication fails and password authentication is allowed, password authentication is attempted next. In the authentication procedure, two key pairs play an important role. First, there is the serverâ€™s public/private key pair, which is used to establish a secure connection. To manage the host public key, you can use the Ansible known_hosts module. Next, there is the userâ€™s public/private key pair, which the user uses to authenticate. To manage the public key in this key pair, you can use the Ansible authorized_key module.">
    <meta property="og:url" content="http://linuxreader.com/ansible/managing-users/ssh-connections/">
    <meta property="og:site_name" content="Linux Reader">
    <meta property="og:description" content="Managing SSH Connections How to provide for SSH keys for new users in such a way that users are provided with SSH keys without having to set them up themselves. To do this, you use the authorized_key module together with theÂ generate_ssh_keyÂ argument to the user module. Understanding SSH Connection Management Requirements How SSH keys are used in the communication process between a user and an SSH server:
The user initiates a session with an SSH server. The server sends back an identification token that is encrypted with the server private key to the user. The user uses the serverâ€™s public key fingerprint, which is stored in the ~/.ssh/known_hosts file to verify the identification token. If no public key fingerprint was stored yet in the ~/.ssh/known_hosts file, the user is prompted to store the remote server identity in the ~/.ssh/known_hosts file. At this point there is no good way to verify whether the user is indeed communicating with the intended server. After establishing the identity of the remote server, the user can either send over a password or generate an authentication token that is based on the userâ€™s private key. If an authentication token that was based on the userâ€™s private key is sent over, this token is received by the server, which tries to match it against the userâ€™s public key that is stored in the ~/.ssh/authorized_keys file. After the incoming authentication token to the stored user public key in the authorized_keys file is matched, the user is authenticated. If this authentication fails and password authentication is allowed, password authentication is attempted next. In the authentication procedure, two key pairs play an important role. First, there is the serverâ€™s public/private key pair, which is used to establish a secure connection. To manage the host public key, you can use the Ansible known_hosts module. Next, there is the userâ€™s public/private key pair, which the user uses to authenticate. To manage the public key in this key pair, you can use the Ansible authorized_key module.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Ansible">
    <meta itemprop="description" content="Managing SSH Connections How to provide for SSH keys for new users in such a way that users are provided with SSH keys without having to set them up themselves. To do this, you use the authorized_key module together with theÂ generate_ssh_keyÂ argument to the user module. Understanding SSH Connection Management Requirements How SSH keys are used in the communication process between a user and an SSH server:
The user initiates a session with an SSH server. The server sends back an identification token that is encrypted with the server private key to the user. The user uses the serverâ€™s public key fingerprint, which is stored in the ~/.ssh/known_hosts file to verify the identification token. If no public key fingerprint was stored yet in the ~/.ssh/known_hosts file, the user is prompted to store the remote server identity in the ~/.ssh/known_hosts file. At this point there is no good way to verify whether the user is indeed communicating with the intended server. After establishing the identity of the remote server, the user can either send over a password or generate an authentication token that is based on the userâ€™s private key. If an authentication token that was based on the userâ€™s private key is sent over, this token is received by the server, which tries to match it against the userâ€™s public key that is stored in the ~/.ssh/authorized_keys file. After the incoming authentication token to the stored user public key in the authorized_keys file is matched, the user is authenticated. If this authentication fails and password authentication is allowed, password authentication is attempted next. In the authentication procedure, two key pairs play an important role. First, there is the serverâ€™s public/private key pair, which is used to establish a secure connection. To manage the host public key, you can use the Ansible known_hosts module. Next, there is the userâ€™s public/private key pair, which the user uses to authenticate. To manage the public key in this key pair, you can use the Ansible authorized_key module.">
    <meta itemprop="wordCount" content="1186">
    <title></title>
    <link href="http://linuxreader.com/ansible/managing-users/ssh-connections/" rel="canonical" type="text/html" title="">
    <link href="/ansible/managing-users/ssh-connections/index.xml" rel="alternate" type="application/rss+xml" title="">
    <link href="/images/favicon.svg?1762442645" rel="icon" type="image/svg+xml">
    <link href="/css/auto-complete/auto-complete.min.css?1762442645" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js?1762442645" defer></script>
    <script src="/js/search-lunr.min.js?1762442645" defer></script>
    <script src="/js/search.min.js?1762442645" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/searchindex.en.js?1762442645";
    </script>
    <script src="/js/lunr/lunr.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.multi.min.js?1762442645" defer></script>
    <script src="/js/lunr/lunr.en.min.js?1762442645" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css?1762442645" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css?1762442645" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css?1762442645" rel="stylesheet">
    <link href="/css/theme.min.css?1762442645" rel="stylesheet">
    <link href="/css/format-print.min.css?1762442645" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/ansible\/managing-users\/ssh-connections\/';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='http:\/\/linuxreader.com';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'oled' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script><style>
:root {
    --MENU-WIDTH-S: 14.375rem;
    --MENU-WIDTH-M: 14.375rem;
    --MENU-WIDTH-L: 18.75rem;
    --MAIN-WIDTH-MAX: 80rem;
    font-size: 1.2rem;
}
</style>

  </head>
  <body class="mobile-support print" data-url="/ansible/managing-users/ssh-connections/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/ad-hoc-commands-and-scripting/" title="Ad Hoc Commands and Scripting (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>

            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#managing-ssh-connections">Managing SSH Connections</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>


          </div>
          <span class="topbar-breadcrumbs highlightable">
            
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/managing-users/ssh-connections/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>

            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/ansible/troubleshooting/ansible-documentation/" title="Ansible Documentation (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>







          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable ansible" tabindex="-1">
        <div class="flex-block-wrapper">
        </div>
      </main>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/js/js-yaml/js-yaml.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-color.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-dispatch.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-drag.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-ease.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-interpolate.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-selection.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-timer.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-transition.min.js?1762442645" defer></script>
    <script src="/js/d3/d3-zoom.min.js?1762442645" defer></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js" defer></script>
    <script>
      window.relearn.themeUseMermaid = JSON.parse("{ \"theme\": \"default\" }");
    </script>
    <script src="/js/clipboard/clipboard.min.js?1762442645" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js?1762442645" defer></script>
    <script src="/js/theme.min.js?1762442645" defer></script>
  </body>
</html>
