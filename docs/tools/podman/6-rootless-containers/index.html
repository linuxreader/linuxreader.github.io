<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.140.0">
    <meta name="generator" content="Relearn 7.1.1">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="6 Rootless containers []{#06.htm#pgfId-1110286}This chapter []{#06.htm#marker-1111672}covers
[]{#06.htm#pgfId-1110287 .calibre17}Why rootless mode is more secure []{#06.htm#pgfId-1110288 .calibre17}How Podman works with the user and mount namespaces []{#06.htm#pgfId-1110289 .calibre17}The architecture of Podman running in rootless mode []{#06.htm#pgfId-1110290}In this chapter, you will take a deep dive into what is going on when running Podman in rootless mode. I believe it is helpful to understand what is happening when you run rootless containers and learn about the problems that running in rootless mode can cause. With the introduction of containerized applications over the last few years, certain highly secure environments were not able to take advantage of the new technology.">
    <meta name="author" content="David Vargas">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:description" content="6 Rootless containers []{#06.htm#pgfId-1110286}This chapter []{#06.htm#marker-1111672}covers
[]{#06.htm#pgfId-1110287 .calibre17}Why rootless mode is more secure []{#06.htm#pgfId-1110288 .calibre17}How Podman works with the user and mount namespaces []{#06.htm#pgfId-1110289 .calibre17}The architecture of Podman running in rootless mode []{#06.htm#pgfId-1110290}In this chapter, you will take a deep dive into what is going on when running Podman in rootless mode. I believe it is helpful to understand what is happening when you run rootless containers and learn about the problems that running in rootless mode can cause. With the introduction of containerized applications over the last few years, certain highly secure environments were not able to take advantage of the new technology.">
    <meta property="og:url" content="http://perfectdarkmode.com/tools/podman/6-rootless-containers/">
    <meta property="og:description" content="6 Rootless containers []{#06.htm#pgfId-1110286}This chapter []{#06.htm#marker-1111672}covers
[]{#06.htm#pgfId-1110287 .calibre17}Why rootless mode is more secure []{#06.htm#pgfId-1110288 .calibre17}How Podman works with the user and mount namespaces []{#06.htm#pgfId-1110289 .calibre17}The architecture of Podman running in rootless mode []{#06.htm#pgfId-1110290}In this chapter, you will take a deep dive into what is going on when running Podman in rootless mode. I believe it is helpful to understand what is happening when you run rootless containers and learn about the problems that running in rootless mode can cause. With the introduction of containerized applications over the last few years, certain highly secure environments were not able to take advantage of the new technology.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Tools">
    <meta itemprop="description" content="6 Rootless containers []{#06.htm#pgfId-1110286}This chapter []{#06.htm#marker-1111672}covers
[]{#06.htm#pgfId-1110287 .calibre17}Why rootless mode is more secure []{#06.htm#pgfId-1110288 .calibre17}How Podman works with the user and mount namespaces []{#06.htm#pgfId-1110289 .calibre17}The architecture of Podman running in rootless mode []{#06.htm#pgfId-1110290}In this chapter, you will take a deep dive into what is going on when running Podman in rootless mode. I believe it is helpful to understand what is happening when you run rootless containers and learn about the problems that running in rootless mode can cause. With the introduction of containerized applications over the last few years, certain highly secure environments were not able to take advantage of the new technology.">
    <meta itemprop="wordCount" content="6273">
    <title></title>
    <link href="/tools/podman/6-rootless-containers/index.xml" rel="alternate" type="application/rss+xml" title="">
    <link href="/tools/podman/6-rootless-containers/index.print.html" rel="alternate" type="text/html" title="">
    <link href="/images/logo.svg?1734871290" rel="icon" type="image/svg+xml">
    <link href="/css/fontawesome-all.min.css?1734871290" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fontawesome-all.min.css?1734871290" rel="stylesheet"></noscript>
    <link href="/css/nucleus.css?1734871290" rel="stylesheet">
    <link href="/css/auto-complete.css?1734871290" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/auto-complete.css?1734871290" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar.min.css?1734871290" rel="stylesheet">
    <link href="/css/fonts.css?1734871290" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fonts.css?1734871290" rel="stylesheet"></noscript>
    <link href="/css/theme.css?1734871290" rel="stylesheet">
    <link href="/css/theme-amoled.css?1734871290" rel="stylesheet" id="R-variant-style">
    <link href="/css/chroma-relearn-dark.css?1734871290" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/css/print.css?1734871290" rel="stylesheet" media="print">
    <script src="/js/variant.js?1734871290"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='http:\/\/perfectdarkmode.com';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      // variant stuff
      window.variants && variants.init( [ 'amoled' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-23N4FSG0HM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-23N4FSG0HM');
</script>


  </head>
  <body class="mobile-support html" data-url="/tools/podman/6-rootless-containers/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-back" data-content-empty="show" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="history.back()" type="button" title=""><i class="fa-fw fas fa-chevron-left"></i></button>
            </div>

            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#heading_id_3">[]{#06.htm#pgfId-1110312}6.1 How does rootless Podman work?</a>
      <ul>
        <li><a href="#heading_id_4">[]{#06.htm#pgfId-1110335}6.1.1 Images contain content owned by multiple user identifiers (UIDs)</a></li>
      </ul>
    </li>
    <li><a href="#heading_id_5">[]{#06.htm#pgfId-1110640}6.2 Rootless Podman under the covers</a>
      <ul>
        <li><a href="#heading_id_6">[]{#06.htm#pgfId-1110658}6.2.1 Pulling the image</a></li>
        <li><a href="#heading_id_7">[]{#06.htm#pgfId-1110680}6.2.2 Creating a container</a></li>
        <li><a href="#heading_id_8">[]{#06.htm#pgfId-1110688}6.2.3 Setting up the network</a></li>
        <li><a href="#heading_id_9">[]{#06.htm#pgfId-1110707}6.2.4 Starting the container monitor: conmon</a></li>
        <li><a href="#heading_id_10">[]{#06.htm#pgfId-1110723}6.2.5 Launching the OCI runtime</a></li>
        <li><a href="#heading_id_11">[]{#06.htm#pgfId-1110762}6.2.6 The containerized application runs until completion</a></li>
      </ul>
    </li>
    <li><a href="#heading_id_12">[]{#06.htm#pgfId-1110780}Summary</a></li>
    <li><a href="#part-3-advanced-topics">Part 3. Advanced topics</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>


          </div>
          <span class="topbar-breadcrumbs highlightable">
            
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-about" data-content-empty="show" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/about/" title=""><span class="title">About</span></a>
            </div>

            <div class="topbar-button topbar-button-now" data-content-empty="show" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/now/" title=""><span class="title">Now</span></a>
            </div>

            <div class="topbar-button topbar-button-booknotes" data-content-empty="show" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/booknotes/" title=""><span class="title">Book Notes</span></a>
            </div>

            <div class="topbar-button topbar-button-contact" data-content-empty="show" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/contact/" title=""><span class="title">Contact</span></a>
            </div>






          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable tools" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id=""></h1>

<h1 id="6-rootless-containers">6 Rootless containers</h1>
<p>[]{#06.htm#pgfId-1110286}This chapter []{#06.htm#marker-1111672}covers</p>
<ul>
<li>[]{#06.htm#pgfId-1110287 .calibre17}Why rootless mode is more secure</li>
<li>[]{#06.htm#pgfId-1110288 .calibre17}How Podman works with the user
and mount namespaces</li>
<li>[]{#06.htm#pgfId-1110289 .calibre17}The architecture of Podman
running in rootless mode</li>
</ul>
<p>[]{#06.htm#pgfId-1110290}In this chapter, you will take a deep dive into
what is going on when running Podman in rootless mode. I believe it is
helpful to understand what is happening when you run rootless containers
and learn about the problems that running in rootless mode can cause.
With the introduction of containerized applications over the last few
years, certain highly secure environments were not able to take
advantage of the new technology.</p>
<p>[]{#06.htm#pgfId-1110292}High performance computing
(HPC[]{#06.htm#marker-1110291}) systems run the fastest computers in the
world. These tend to be at national labs and universities and deal with
high-security information. They also handle some of the most secure data
in the world and expressly forbid the use of rootful containers. HPC
systems deal with huge datasets, including artificial intelligence,
nuclear weapons, global weather patterns, and medical research. These
systems tend to have thousands of shared computers, and they need to be
locked down because of their multi-user shared environments. HPC
computing believes running daemons as root is too insecure. If a rogue
container process breaks out of confinement and gains root access, it
can access highly sensitive data. Administrators of HPC environments
couldn&rsquo;t use Open Container Initiative (OCI) containers until Podman
came along. The HPC community is now working to move to rootless Podman.</p>
<p>[]{#06.htm#pgfId-1110293}Similarly, large financial company
administrators do not allow users and developers access to root on their
shared computer systems, out of concern for the financial data involved.
The largest financial firms in the world were having difficulty fully
adopting OCI containers. Figure 6.1 shows that even though the Docker
client can be run as non-root, it connects to a root running daemon,
giving full root access to the host OS.</p>
<p>::: figure
<a href="#R-image-1d8a2981b2dc18d90fda8384e30fb0ff" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-01.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d8a2981b2dc18d90fda8384e30fb0ff"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-01.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115608}Figure 6.1 Multiple users&rsquo; workloads sharing
the same daemon running as root is inherently insecure.
:::</p>
<p>[]{#06.htm#pgfId-1110300}The bottom line is that allowing users on a
shared computing system to run container workloads accessing the same
root-running daemon is too insecure. Running each user&rsquo;s containers in
rootless mode under different users&rsquo; accounts is more secure. Figure 6.2
shows multiple users running Podman independent of each other, without
any root access.</p>
<p>::: figure
<a href="#R-image-c7932ea22c36e098771428bbf75c2f32" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-02.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7932ea22c36e098771428bbf75c2f32"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-02.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115646}Figure 6.2 Each workload running within its
unique user space is more secure.
:::</p>
<p>[]{#06.htm#pgfId-1110307}Linux was designed from the ground up with a
separation between privileged mode (rootful) and unprivileged mode
(rootless). In Linux almost all tasks run without being privileged.
Privileged operations are only required for modifications to the core
operating system. Almost all applications that run in containers, web
servers, databases, and user tools run without requiring root. The
applications do not modify core parts of the system. Sadly, most of the
images you will find on container registries are built to require root
privileges or at least start as root and then drop privileges.</p>
<p>[]{#06.htm#pgfId-1110308}In the corporate world, administrators are very
reluctant to give out root access to their users. If you receive a
corporate laptop from your employer, usually you are not granted any
root access. Administrators need to control what is installed on their
systems because of scale, and they need to be able to update hundreds to
thousands of machines at the same time, so controlling what is in the OS
is critical. If someone else is administering your machine, they need to
control who gets root access.</p>
<p>[]{#06.htm#pgfId-1110309}As a security person, I still flinch a little
when I see sudo without a password. When I first started working with
Docker, I was shocked that it was encouraging the use of the Docker
group, giving users full root access on the host, without a password.
The holy grail of hackers is to get a root exploit; this means the
hackers gain full control over the system.</p>
<p>[]{#06.htm#pgfId-1110310}Bottom line is that if you have a container
escape, as bad as that is, you are better off in rootless mode. This is
because the hackers have control over only nonprivileged processes, as
opposed to a root exploit, where they have full control over the system
and all of the data (ignoring other security mechanisms like SELinux).
Podman&rsquo;s design goals include the ability to run as many workloads as
possible without being root and push the core OS to make it easier for
you to run in this more secure mode.</p>
<h2 id="heading_id_3" class="fm-head">[]{#06.htm#pgfId-1110312}6.1 How does rootless Podman work?</h2>
<p>[]{#06.htm#pgfId-1110313}Have you ever wondered what happens behind the
scenes of a rootless Podman container? In chapter 2, all of the Podman
examples were running in rootless mode. Let&rsquo;s take a look at what
happens under the hood of rootless Podman containers. I&rsquo;ll explain each
component and then break down all of the steps involved.</p>
<p>[]{#06.htm#pgfId-1110314}[Note]{.fm-callout-head} Some of this section
is copied and rewritten from the &ldquo;What Happens behind the Scenes of a
Rootless Podman Container?&rdquo; blog
(<a href="https://www.redhat.com/sysadmin/behind-scenes-podman" rel="external" target="_blank">https://www.redhat.com/sysadmin/behind-scenes-podman</a>{.url}),
written by myself and coworkers Matthew Heon and Giuseppe Scrivano.</p>
<p>[]{#06.htm#pgfId-1110316}First, let&rsquo;s first clear out all storage, so
you can get a fresh environment, and then run a container on
quay.io/rhatdan/myimage. (Remember that the <code>podman</code>{.fm-code-in-text}
<code>rmi</code>{.fm-code-in-text} <code>--all</code>{.fm-code-in-text}
<code>--force</code>{.fm-code-in-text} command[]{#06.htm#marker-1110317} removes
all images and containers from storage.)</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman rmi --all --force
Untagged: registry.access.redhat.com/ubi8/httpd-24:latest
Untagged: registry.access.redhat.com/ubi8-init:latest
Untagged: localhost/myimage:latest
Untagged: quay.io/rhatdan/myimage:latest
Deleted: d2244a4379d6f1981189d35154beaf4f9a17666ae3b9fba680ddb014eac72adc
Deleted: 82eb390304938f16dd707f32abaa8464af8d4a25959ab342e25696a540ec56b5
Deleted: 8773554aad01d4b8443d979cdd509e7b8fa88ddbc966987fe91690d05614c961</code></pre></div>
<p>[]{#06.htm#pgfId-1110327}Now that you have a clean system, you need to
retrieve the application image, quay.io/ rhatdan/myimage, from the
container registry you pushed it to in chapter 2. In the following
command, re-create the application on your machine. The command pulls
the image back from the container registry and starts the
<code>myapp</code>{.fm-code-in-text} container[]{#06.htm#marker-1110328} on your
host.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run -d -p 8080:8080 --name myapp quay.io/rhatdan/myimage
Trying to pull quay.io/rhatdan/myimage:latest...
...  
2f111737752dcbf1a1c7e15e807fb48f55362b67356fc10c2ade24964e99fa09</code></pre></div>
<p>[]{#06.htm#pgfId-1110333}Now let&rsquo;s dig deep into what just happened when
you ran a rootless Podman container. The first thing that happened was
Podman needed to set up the user namespace. In the next section, I
explain why, and how it works.</p>
<h3 id="heading_id_4" class="fm-head1">[]{#06.htm#pgfId-1110335}6.1.1 Images contain content owned by multiple user identifiers (UIDs)</h3>
<p>[]{#06.htm#pgfId-1110340}In
[]{#06.htm#marker-1113923}[]{#06.htm#marker-1113924}[]{#06.htm#marker-1113925}Linux,
user identifiers (UIDs) and group identifiers
(GIDs[]{#06.htm#marker-1113926}) are assigned to processes and stored on
filesystem objects. The filesystem objects also have permission values
assigned to them. Linux controls the processes&rsquo; access to the filesystem
based on these UIDs and GIDs. This access is called <em>discretionary
access control</em>
(DAC[]{#06.htm#marker-1113928}[]{#06.htm#marker-1113929}). When you log
in to a Linux machine, your rootless user processes run with a single
UID&mdash;say, <code>1000</code>{.fm-code-in-text}&mdash;but container images usually come
with multiple different UIDs in their image layers. Let&rsquo;s examine the
UIDs needed to run our image. In this example, you examine all the UIDs
defined within the container image by running another container.</p>
<p>[]{#06.htm#pgfId-1110343}In the following command, launch a container
with the quay.io/rhatdan/myimage image. You need to run the container as
root (<code>- -user=root</code>{.fm-code-in-text}) inside the container to examine
every file within the image.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c &#34;find / 
➥ -mount -printf \”%U=%u\n\” | sort -un&#34; 2&gt;/dev/null</code></pre></div>
<p>[]{#06.htm#pgfId-1110347}Since this is only a temporary container, use
the <code>--rm</code>{.fm-code-in-text} option[]{#06.htm#marker-1110346} to make
sure the container is removed when it finishes running. The container
runs a Bash script, which finds all of the UIDs and users associated
with every file/directory in the container. The script pipes the output
to show unique entries and redirects <code>stderr</code>{.fm-code-in-text} to
/dev/null to eliminate any errors.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c &#34;find /
➥ -mount -printf \”%U=%u\n\” | sort -un&#34; 2&gt;/dev/null
0=root
48=apache
1001=default
65534=nobody</code></pre></div>
<p>[]{#06.htm#pgfId-1110354}As you can see from the output, our container
image uses four different UIDs, shown in table 6.1.</p>
<p>[]{#06.htm#pgfId-1112391}Table 6.1 Unique UIDs required to run the
container image</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#06.htm#pg   | []{#06.htm#pgf  | []{                               |
| fId-1112397}UID | Id-1112399}Name | #06.htm#pgfId-1112401}Description |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []              | []{#0           | []{#06.htm#pgfId-1112407}Owns     |
| {#06.htm#pgfId- | 6.htm#pgfId-111 | most of the content within the    |
| 1112403}<code>0</code>{.fm | 2405}<code>root</code>{.fm | container image                   |
| -code-in-text1} | -code-in-text1} |                                   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{             | []{#06.         | []{#06.htm#pgfId-1112413}Owns all |
| #06.htm#pgfId-1 | htm#pgfId-11124 | of the Apache content             |
| 112409}<code>48</code>{.fm | 11}<code>apache</code>{.fm |                                   |
| -code-in-text1} | -code-in-text1} |                                   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#0           | []{#06.h        | []{#06.htm#pgfId-1112419}Default  |
| 6.htm#pgfId-111 | tm#pgfId-111241 | user the container runs as        |
| 2415}<code>1001</code>{.fm | 7}<code>default</code>{.fm |                                   |
| -code-in-text1} | -code-in-text1} |                                   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#06          | []{#06.         | []{#06.htm#pgfId-1112425}Assigned |
| .htm#pgfId-1112 | htm#pgfId-11124 | to any UID that is not mapped     |
| 421}<code>65634</code>{.fm | 23}<code>nobody</code>{.fm | into the container                |
| -code-in-text1} | -code-in-text1} |                                   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<p>[]{#06.htm#pgfId-1110389}For you to pull a container image to your home
directory, Podman needs to store at least three different UIDs:
<code>0</code>{.fm-code-in-text}, <code>48</code>{.fm-code-in-text}, and
<code>1001</code>{.fm-code-in-text}. Since the Linux kernel prevents nonprivileged
accounts from using more than a single UID, you are prevented from
creating files with different UIDs. You will need to take advantage of
the user namespace.</p>
<p>[]{#06.htm#pgfId-1110391}User namespace</p>
<p>[]{#06.htm#pgfId-1110396}Linux[]{#06.htm#marker-1110392}[]{#06.htm#marker-1110393}[]{#06.htm#marker-1110394}[]{#06.htm#marker-1110395}
supports the concept of user namespaces, which is a mapping of UID/GIDs
from the host to different UIDs and GIDs inside the namespace. Here is
how the man page describes it:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ man user namespaces
...</code></pre></div>
<p>[]{#06.htm#pgfId-1110399}User namespaces isolate security-related
identifiers and attributes&mdash;in particular, user IDs and group IDs (see
<code>credentials(7)</code>{.fm-code-in-text}), the root directory, keys (see
<code>keyrings(7)</code>{.fm-code-in-text}), and capabilities (see
<code>capabilities(7)</code>{.fm-code-in-text}). A process&rsquo;s user and group IDs can
be different inside and outside a user namespace. In particular, a
process can have a normal, unprivileged user ID outside a user
namespace, while at the same time having a user ID of
<code>0</code>{.fm-code-in-text} inside the namespace; in other words, the process
has full privileges for operations inside the user namespace but is
unprivileged for operations outside the namespace.</p>
<p>[]{#06.htm#pgfId-1110400}Since your container requires more than one
UID, the Podman process first creates and enters a user namespace, where
it has access to more UIDs. Podman must also mount several filesystems
to run a container. These mount commands are not allowed outside a user
namespace (along with a mount namespace). Figure 6.3 shows the UIDs used
within a user namespace.</p>
<p>::: figure
<a href="#R-image-a1f8f4abc2fa9f2bf68df3e3b3a68c0e" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-03.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a1f8f4abc2fa9f2bf68df3e3b3a68c0e"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-03.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115684}Figure 6.3 User namespace mapping for
containers
:::</p>
<p>[]{#06.htm#pgfId-1110408}When I created my system, I used the
<code>useradd</code>{.fm-code-in-text} program[]{#06.htm#marker-1110407} to create
my account. It assigned me <code>3267</code>{.fm-code-in-text} as my UID and GID,
defined in /etc/passwd and /etc/group. It also allocated UID
<code>100000-1065535</code>{.fm-code-in-text}&mdash;additional UIDs and GIDs for me
defined in /etc/ subuid and /etc/subgid. Let&rsquo;s see the content of these
files:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ cat /etc/subuid
dwalsh:100000:65536
Testuser:165536:65536
$ cat /etc/subgid
dwalsh:100000:65536
Testuser:165536:65536</code></pre></div>
<p>[]{#06.htm#pgfId-1110415}You can cat these files on your system, and
you&rsquo;ll see something similar. On my system I also have a
<code>testuser</code>{.fm-code-in-text} account; <code>useradd</code>{.fm-code-in-text} also
added UIDs/GIDs for that user, starting right after my allocation.</p>
<p>[]{#06.htm#pgfId-1110416}Within a user namespace, I have access to UIDs
<code>3267</code>{.fm-code-in-text} (my UID) as well as <code>100000</code>{.fm-code-in-text},
<code>100001</code>{.fm-code-in-text}, <code>100002</code>{.fm-code-in-text}, ...,
<code>165535</code>{.fm-code-in-text}, for a total of 65,537 UIDs. A root user can
modify the /etc/subuid and /etc/subgid files to increase or decrease
this number.</p>
<p>[]{#06.htm#pgfId-1110418}The <code>useradd</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110417} starts at UID
<code>100000</code>{.fm-code-in-text} to allow you to have around 99,000 regular
users plus 1,000 UIDs reserved for system services on a Linux system.
The kernel supports more than 4 billion UIDs (2^32^ = 4,294,967,296).
Since <code>useradd</code>{.fm-code-in-text} allocates 65,537 per user, Linux can
support more than 60,000 users. The 65,536 (2^16^) number was picked
because up until the Linux kernel 2.4, this was the maximum number of
users on a Linux system. Let&rsquo;s look deeper into the user namespace.</p>
<p>[]{#06.htm#pgfId-1110419}Every process on a Linux system is in a
namespace, including the init process and systemd. These are the host
namespaces. Therefore, every process is in a user namespace. You can see
the user namespace mapping for your process by examining the /proc
filesystem. The /proc/PID/uid_map and /proc/PID/gid_map contain the user
namespace mappings for each process on the OS. /proc/self/uid_map
contains the UID map of the current process:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ cat /proc/self/uid_map 
      0        0 4294967295</code></pre></div>
<p>[]{#06.htm#pgfId-1110422}The mapping means UIDs starting at UID
<code>0</code>{.fm-code-in-text} are mapped to UID <code>0</code>{.fm-code-in-text} for a
range of 4,294,967,295 UIDs.</p>
<p>[]{#06.htm#pgfId-1110423}Another way of looking at this mapping is</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">UID 0-&gt;0, 1-&gt;1,...3267-&gt;3267,...,4294967294-&gt;4294967294.</code></pre></div>
<p>[]{#06.htm#pgfId-1110425}Basically, there is no mapping, so root is
root. And my UID <code>3267</code>{.fm-code-in-text} is mapped to
<code>3267</code>{.fm-code-in-text}&mdash;itself.</p>
<p>[]{#06.htm#pgfId-1110426}Now let&rsquo;s enter the user namespace and see what
is mapped. Podman has a special command, <code>podman</code>{.fm-code-in-text}
<code>unshare</code>{.fm-code-in-text}, which allows you to enter a user namespace
without launching a container. It allows you to examine what is going on
within the user namespace, while still running as a regular process on
your system.</p>
<p>[]{#06.htm#pgfId-1110427}In the following command, I run
<code>podman</code>{.fm-code-in-text} <code>unshare</code>{.fm-code-in-text} to launch the cat
/proc/self/ uid_map within the default user namespace for my account:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare cat /proc/self/uid_map 
       0     3267        1
       1   100000    65536</code></pre></div>
<p>[]{#06.htm#pgfId-1110431}The mappings show that UID
<code>0</code>{.fm-code-in-text} is mapped to UID <code>3267</code>{.fm-code-in-text} (my UID)
for a range of <code>1</code>{.fm-code-in-text}. Then UID <code>1</code>{.fm-code-in-text} is
mapped to UID <code>100000</code>{.fm-code-in-text} for a range of
<code>65536</code>{.fm-code-in-text} UIDS.</p>
<p>[]{#06.htm#pgfId-1110432}Any UID not mapped to the user namespace is
reported within the user namespace as the <code>nobody</code>{.fm-code-in-text}
user[]{#06.htm#marker-1110433}. You saw this earlier when you searched
for the UIDs within the container image:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run --user=root --rm quay.io/rhatdan/myimage -- bash -c &#34;find / 
➥ -mount -exec stat -c %u=%U {} \; | sort -un&#34; 2&gt;/dev/null
0=root
48=apache
1001=default
65534=nobody</code></pre></div>
<p>[]{#06.htm#pgfId-1110440}If you look at <code>/</code>{.fm-code-in-text} on the
host, you see it is owned by the real root:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ ls -l -ld /
dr-xr-xr-x. 18 root root 242 Sep 21 22:32 /</code></pre></div>
<p>[]{#06.htm#pgfId-1110443}If you examine the same directory within the
user namespace, you see it is owned by the <code>nobody</code>{.fm-code-in-text}
user[]{#06.htm#marker-1110444}:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare ls -ld /
dr-xr-xr-x. 18 nobody nobody 242 Sep 21 22:32 /</code></pre></div>
<p>[]{#06.htm#pgfId-1110447}Since the host&rsquo;s UID <code>0</code>{.fm-code-in-text} is
not mapped into the user namespace, the kernel reports the UID as the
<code>nobody</code>{.fm-code-in-text} user[]{#06.htm#marker-1110448}. Processes
within the user namespace only have access to <code>nobody</code>{.fm-code-in-text}
files based on only the
<code>other</code>{.fm-code-in-text}[]{#06.htm#marker-1110449} or
<code>world</code>{.fm-code-in-text} permissions[]{#06.htm#marker-1110450}. In the
example that follows, you will launch a Bash script that shows the user
is root within the user namespace but sees /etc/passwd as owned by the
user <code>nobody</code>{.fm-code-in-text}. You can read the file with the grep
command because /etc/passwd is world readable. But the touch command
fails because even root cannot modify files owned by UIDs not mapped to
the user namespace:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare bash -c &#34;id ; ls -l /etc/passwd; grep dwalsh 
➥ /etc/passwd; touch /etc/passwd&#34;
uid=0(root) gid=0(root) groups=0(root),65534(nobody)
-rw-r--r--. 1 nobody nobody 2942 Sep 28 07:08 /etc/passwd
dwalsh:x:3267:3267:Dan Walsh:/home/dwalsh:/bin/bash
touch: cannot touch &#39;/etc/passwd&#39;: Permission denied</code></pre></div>
<p>[]{#06.htm#pgfId-1110457}Looking at your home directory on the host
versus inside of the user namespace, you see that the same files are
reported as being owned by your UID:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ ls -ld /home/dwalsh
drwx------. 365 dwalsh dwalsh 24576 Sep 28 07:30 /home/dwalsh</code></pre></div>
<p>[]{#06.htm#pgfId-1110460}Within the user namespace, they are owned by
root:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare ls -ld /home/dwalsh
drwx------. 365 root root 24576 Sep 28 07:30 /home/dwalsh</code></pre></div>
<p>[]{#06.htm#pgfId-1110463}By default, Podman maps your UID to root within
the user namespace. Podman defaults to root because, as I specified at
the beginning of this chapter, the majority of container images assume
they start with root.</p>
<p>[]{#06.htm#pgfId-1110464}I&rsquo;ll give one last example. Create a directory
and a file within the directory while in the user namespace, and use the
<code>chown</code>{.fm-code-in-text} command[]{#06.htm#marker-1110465} to change
the contents UIDs to <code>1:1</code>{.fm-code-in-text}:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare bash -c &#34;mkdir test;touch test/testfile; chown -R 1:1 test&#34;</code></pre></div>
<p>[]{#06.htm#pgfId-1110467}Outside the user namespace, you see the test
file is owned by UID <code>100000</code>{.fm-code-in-text}:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ ls -l test
total 0
-rw-r--r--. 1 100000 100000 0 Sep 28 07:53 testfile</code></pre></div>
<p>[]{#06.htm#pgfId-1110471}When you create the test file and
<code>chown</code>{.fm-code-in-text} it to UID/GID <code>1:1</code>{.fm-code-in-text} within
the user namespace, the on-disk owner is actually UID
<code>100000</code>{.fm-code-in-text}/<code>100000</code>{.fm-code-in-text}. Remember, within
the user namespace, UID <code>1</code>{.fm-code-in-text} is mapped to UID
<code>100000</code>{.fm-code-in-text}, so when you create a UID
<code>1</code>{.fm-code-in-text} file within the user namespace, the OS actually
creates UID <code>100000</code>{.fm-code-in-text}.</p>
<p>[]{#06.htm#pgfId-1110472}If you attempt to remove the file outside of
the user namespace, you get an error:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ rm -rf test
rm: cannot remove &#39;test/testfile&#39;: Permission denied</code></pre></div>
<p>[]{#06.htm#pgfId-1110475}Outside the user namespace, you have access to
only your UID; you don&rsquo;t have access to the additional UIDs.</p>
<p>[]{#06.htm#pgfId-1110476}[Note]{.fm-callout-head} In section 3.1.2, I
showed how user namespace mappings can be problematic with container
volumes and discussed ways you can handle them.</p>
<p>[]{#06.htm#pgfId-1110477}Reentering the user namespace, you can remove
the file:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare rm -rf test</code></pre></div>
<p>[]{#06.htm#pgfId-1110479}Hopefully, you are starting to get a feel for
the user namespace; the <code>podman</code>{.fm-code-in-text}
<code>unshare</code>{.fm-code-in-text} command[]{#06.htm#marker-1110480} makes it
easy to explore your system within the user namespace and understand
what is happening in rootless containers. When running a rootless
container, Podman needs more than just to run as root; it also needs
access to some of the special powers of root called Linux capabilities.</p>
<p>[]{#06.htm#pgfId-1110481}In Linux, the root processes actually are not
all equally powerful. Linux breaks root privileges into a series of
Linux capabilities. A root process with all Linux capabilities is all
powerful, while a root process without Linux capabilities is not allowed
to manipulate a lot of the system. For example, it cannot read non-root
files, unless those files have permission flags that allow all UIDs on
the system to read (world readable).</p>
<p>[]{#06.htm#pgfId-1110482}Let&rsquo;s see how capabilities work with the user
namespace:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ man capabilities
...
DESCRIPTION
For the purpose of performing permission checks, traditional UNIX 
implementations distinguish two categories of processes: privileged 
processes (whose effective user ID is 0, referred to as superuser or root), 
and unprivileged processes (whose effective UID is nonzero). Privileged 
processes bypass all kernel permission checks, while unprivileged processes 
are subject to full permission checking based on the process&#39;s credentials 
(usually: effective UID, effective GID, and supplementary group list).
Starting with kernel 2.2, Linux divides the privileges traditionally 
associated with superuser into distinct units, known as capabilities, which 
can be independently enabled and disabled. Capabilities are a per-thread 
attribute.</code></pre></div>
<p>[]{#06.htm#pgfId-1110498}Linux currently has around 40 capabilities.
Examples include
<code>CAP_SETUID</code>{.fm-code-in-text}[]{#06.htm#marker-1110497} and
<code>CAP_SETGID</code>{.fm-code-in-text}[]{#06.htm#marker-1110499}, which allow
processes to change their UIDs and GIDs.
<code>CAP_NET_ADMIN</code>{.fm-code-in-text}[]{#06.htm#marker-1110500} allows you
to manage the network stack.</p>
<p>[]{#06.htm#pgfId-1110502}Another capability called
<code>CAP_CHOWN</code>{.fm-code-in-text}[]{#06.htm#marker-1110501} allows processes
to change the UID/GID of files on disk. In the preceding example, when
you <code>chown</code>{.fm-code-in-text}ed the test directory to
<code>1:1</code>{.fm-code-in-text}, you used the <code>CAP_CHOWN</code>{.fm-code-in-text}
capability[]{#06.htm#marker-1110503} within the user namespace:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare bash -c &#34;mkdir test;touch test/testfile; chown -R 1:1 test&#34;</code></pre></div>
<p>[]{#06.htm#pgfId-1110505}When you run within a user namespace, you are
using namespaced capabilities. The root user within your user namespace
has these capabilities beyond the UIDs and GIDs defined within the
namespace. Processes with the namespaced capability,
<code>CAP_CHOWN</code>{.fm-code-in-text}, are allowed to <code>chown</code>{.fm-code-in-text}
files owned within your user namespace to UIDs that are also within the
user namespace. If a process within a user namespace attempts to
<code>chown</code>{.fm-code-in-text} a file not mapped to the user namespace, owned
by the <code>nobody</code>{.fm-code-in-text} user, the process is denied
permission. Likewise, a process attempting to <code>chown</code>{.fm-code-in-text}
a file with a UID not defined within the user namespace also gets
denied. Similarly, the <code>CAP_SETUID</code>{.fm-code-in-text} capability only
allows processes to change UIDs to those defined within the user
namespace.</p>
<p>[]{#06.htm#pgfId-1110508}When Podman runs a container, it needs to mount
several filesystems for the container. In Linux, the
<code>CAP_SYS_ADMIN</code>{.fm-code-in-text} capability[]{#06.htm#marker-1110509}
is required for mounting filesystems. From a security point of view,
mounting filesystems can be a dangerous thing to do on Linux. The kernel
adds additional controls on which types of filesystems can be mounted
and requires your user-namespaced processes to also be in a unique mount
namespace. In chapter 10, you will see how Podman limits the number of
Linux capabilities available to the namespaced root within a
[]{#06.htm#marker-1110510}[]{#06.htm#marker-1110511}[]{#06.htm#marker-1110512}[]{#06.htm#marker-1110513}container.</p>
<p>[]{#06.htm#pgfId-1110515}Mount namespace</p>
<p>[]{#06.htm#pgfId-1110520}Mount
[]{#06.htm#marker-1110516}[]{#06.htm#marker-1110517}[]{#06.htm#marker-1110518}[]{#06.htm#marker-1110519}namespaces
allow processes within them to mount filesystems, where the mount points
are not seen by processes outside the mount namespace. Inside a mount
namespace, you can mount a <code>tmpfs</code>{.fm-code-in-text} on /tmp, which
blocks the processes within the namespaces view of /tmp. Outside the
mount namespace, processes still see the original mount and files within
/tmp, but they do not see your mount.</p>
<p>[]{#06.htm#pgfId-1110521}In rootless containers, Podman needs to mount
the content in the container images as well as /proc, /sys, devices from
/dev, and some <code>tmpfs</code>{.fm-code-in-text} filesystems. For that, Podman
needs to create a mount namespace:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ man mount namespaces
...
Mount namespaces provide isolation of the list of mount points seen by the 
processes in each namespace instance. Thus, the processes in each of the 
mount namespace instances see distinct single-directory hierarchies.</code></pre></div>
<p>[]{#06.htm#pgfId-1110528}When you execute the <code>podman</code>{.fm-code-in-text}
<code>unshare</code>{.fm-code-in-text} command,[]{#06.htm#marker-1110527} you are
actually entering a different mount namespace as well as a different
user namespace.</p>
<p>[]{#06.htm#pgfId-1110529}You can examine a process&rsquo;s namespaces by
listing the /proc/self/ns/ directory as follows:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ ls -l /proc/self/ns/user /proc/self/ns/mnt
lrwxrwxrwx. 1 dwalsh dwalsh 0 Sep 28 09:17 /proc/self/ns/mnt -&gt; 
➥ &#39;mnt:[4026531840]&#39;
lrwxrwxrwx. 1 dwalsh dwalsh 0 Sep 28 09:17 /proc/self/ns/user -&gt; 
➥ &#39;user:[4026531837]&#39;</code></pre></div>
<p>[]{#06.htm#pgfId-1110535}Notice that when you enter the user namespace
and mount namespace, the identifiers change:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman unshare ls -l /proc/self/ns/user /proc/self/ns/mnt
lrwxrwxrwx. 1 root root 0 Sep 28 09:17 /proc/self/ns/mnt -&gt; 
➥ &#39;mnt:[4026533087]&#39;
lrwxrwxrwx. 1 root root 0 Sep 28 09:17 /proc/self/ns/user -&gt; 
➥ &#39;user:[4026533086]&#39;</code></pre></div>
<p>[]{#06.htm#pgfId-1110541}In the following test, you can create a file on
/tmp and then attempt to bind mount it onto /etc/shadow. Outside the
namespaces, the kernel rightly prevents you from mounting the file, as
you can see in the following output:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ echo hello &gt; /tmp/testfile
$ mount --bind /tmp/testfile /etc/shadow
mount: /etc/shadow: must be superuser to use mount.
 
Once you enter the user namespace and mount namespace, your namespaced 
process can successfully mount over the /etc/shadow file. You can see when 
you run the following command that /etc/shadow is actually modified:
$ podman unshare bash -c &#34;mount -o bind /tmp/testfile /etc/shadow; cat 
/etc/shadow&#34; 
hello</code></pre></div>
<p>[]{#06.htm#pgfId-1110556}Once you exit the <code>unshare</code>{.fm-code-in-text},
everything is back to
[]{#06.htm#marker-1110552}[]{#06.htm#marker-1110553}[]{#06.htm#marker-1110554}[]{#06.htm#marker-1110555}normal.</p>
<p>[]{#06.htm#pgfId-1110558}User namespace and mount namespace</p>
<p>[]{#06.htm#pgfId-1110564}As
[]{#06.htm#marker-1110559}[]{#06.htm#marker-1110560}[]{#06.htm#marker-1110561}[]{#06.htm#marker-1110562}[]{#06.htm#marker-1110563}you
saw previously, when you over-mount the /etc/shadow file, you might
trick some <code>setuid</code>{.fm-code-in-text} applications, like /bin/su or
/bin/sudo, into giving you full root. The reason rootless users are not
allowed to mount filesystems is to prevent this type of attack.</p>
<p>[]{#06.htm#pgfId-1110565}As you have seen, the separate mount namespace
prevents you from affecting the host&rsquo;s view of the system, and anything
you mount is seen only within the mount namespace. Within the user
namespace, the container already has a namespaced root. Attacks on your
mount points can be escalated to root only within the user
namespace&mdash;not real root on the host. Containerized processes cannot
change their UID (<code>setuid</code>{.fm-code-in-text}) to real root or any other
UID not mapped into the user namespace.</p>
<p>[]{#06.htm#pgfId-1110566}Even with the namespaces, the Linux kernel only
allows you to mount certain filesystem types. Many filesystem types are
too dangerous to allow for rootless users because they gain access to
sensitive parts of the kernel. I work with filesystem kernel engineers
to see if there are ways to lock down other filesystem types that could
be allowed to be mounted in rootless mode, without affecting the
security of the system.</p>
<p>[]{#06.htm#pgfId-1110567}As of kernel 5.13, the kernel engineers added
native overlay mounts to the list of allowed mounts. The filesystem
types currently allowed are
[]{#06.htm#marker-1110568}[]{#06.htm#marker-1110569}[]{#06.htm#marker-1110570}[]{#06.htm#marker-1110571}[]{#06.htm#marker-1110572}listed
[]{#06.htm#marker-1110573}[]{#06.htm#marker-1110574}[]{#06.htm#marker-1110575}in
table 6.2.</p>
<p>[]{#06.htm#pgfId-1112521}Table 6.2 Filesystem mounts currently supported
in rootless mode</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#06.htm#pgfI | []{#06.htm#pgfId-1112527}Description                |
| d-1112525}Mount |                                                     |
| type            |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| [               | []{#06.htm#pgfId-1112531}Used heavily in rootless   |
| ]{#06.htm#pgfId | containers. Because rootless users are not allowed  |
| -1112529}<code>bind</code> | to create devices, Podman <code>bind</code>{.fm-code-in-text1} |
| {.fm-code-in-te | mounts /dev on the host into the container. Podman  |
| xt1}[]{#06.htm# | also uses <code>bind</code>{.fm-code-in-text1} mounts to       |
| marker-1112572} | obscure content within the host filesystem from     |
|                 | containers. Podman also <code>bind</code>{.fm-code-in-text1}   |
|                 | mounts /dev/null over files in /proc and /sys to    |
|                 | hide content. Volume mounts, described in chapter   |
|                 | 3, also use <code>bind</code>{.fm-code-in-text1} mounts.       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#0           | []{#06.htm#pgfId-1112535}Filesystem for the Android |
| 6.htm#pgfId-111 | binder IPC mechanism. It is not supported by        |
| 2533}<code>binderfs</code> | Podman.                                             |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112573} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{             | []{#06.htm#pgfId-1112539}Virtual filesystem mounted |
| #06.htm#pgfId-1 | at /dev/pts. It contains device files used for      |
| 112537}<code>devpts</code> | terminal emulators                                  |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112574} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#0           | []{#06.htm#pgfId-1112543}Kernel filesystem used to  |
| 6.htm#pgfId-111 | manipulate cgroups; rootless containers can use     |
| 2541}<code>cgroupfs</code> | <code>cgroupfs</code>{.fm-code-in-text1} to manipulate cgroups |
| {.fm-code-in-te | in cgroups v2. On v1 this is not supported. This is |
| xt1}[]{#06.htm# | mounted at /sys/fs/cgroups.                         |
| marker-1112575} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#0           | []{#06.htm#pgfId-1112547}Used to mount container    |
| 6.htm#pgfId-111 | images using the                                    |
| 2545}<code>FUSE</code>{.fm | <code>fuse-overlayfs</code>{.fm-code-in-text1} in rootless     |
| -code-in-text1} | mode. Prior to kernel 5.13, this was the only way   |
| []{#06.htm#     | to use an overlay filesystem in rootless mode.      |
| marker-1112576} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{             | []{#06.htm#pgfId-1112551}Mounted at /proc within    |
| #06.htm#pgfId-1 | the container. You can examine processes within the |
| 112549}<code>procfs</code> | container.                                          |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112577} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{             | []{#06.htm#pgfId-1112555}Implements the POSIX       |
| #06.htm#pgfId-1 | message queues API. Podman mounts this filesystem   |
| 112553}<code>mqueue</code> | at /dev/mqueue.                                     |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112578} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []{#06          | []{#06.htm#pgfId-1112559}Used for mounting the      |
| .htm#pgfId-1112 | image. Performs better in the                       |
| 557}<code>overlayfs</code> | <code>fuse-overlayfs</code>{.fm-code-in-text1} filesystem. In  |
| {.fm-code-in-te | certain use cases, it provides benefits over native |
| xt1}[]{#06.htm# | overlay, such as NFS home directories.              |
| marker-1112579} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []              | []{#06.htm#pgfId-1112563}Dynamically resizable,     |
| {#06.htm#pgfId- | ram-based Linux filesystem, currently not used with |
| 1112561}<code>ramfs</code> | Podman.                                             |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112580} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []              | []{#06.htm#pgfId-1112567}Mounted at /sys.           |
| {#06.htm#pgfId- |                                                     |
| 1112565}<code>sysfs</code> |                                                     |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112581} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| []              | []{#06.htm#pgfId-1112571}Used to obscure kernel     |
| {#06.htm#pgfId- | filesystem directories from containers in /proc and |
| 1112569}<code>tmpfs</code> | /sys.                                               |
| {.fm-code-in-te |                                                     |
| xt1}[]{#06.htm# |                                                     |
| marker-1112582} |                                                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<h2 id="heading_id_5" class="fm-head">[]{#06.htm#pgfId-1110640}6.2 Rootless Podman under the covers</h2>
<p>[]{#06.htm#pgfId-1110641}Now that you have some understanding of how the
user namespace and mount namespace work and why they are needed, let&rsquo;s
dig deeper into what Podman does when it runs a container. The first
time you run a Podman container after logging in, Podman reads the
/etc/subuid and /etc/subgid files, looking for your username or UID.
Once Podman finds the entry, it uses the contents as well as your
current UID/GID to generate a user namespace for you. Podman then
launches the <code>podman</code>{.fm-code-in-text} <code>pause</code>{.fm-code-in-text}
process[]{#06.htm#marker-1110642} to hold open the user and mount
namespaces (figure 6.4).</p>
<p>::: figure
<a href="#R-image-8180887b6f3690dc082df2722c1be72b" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-04.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8180887b6f3690dc082df2722c1be72b"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-04.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115722}Figure 6.4 Podman launches the pause process to
hold open the user and mount namespaces.
:::</p>
<p>[]{#06.htm#pgfId-1110649}Users commonly report that after they run
Podman containers, they see a <code>podman</code>{.fm-code-in-text} process still
running when they run the following command:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ ps -e | grep podman
  2541 ?     00:00:00 podman pause </code></pre></div>
<p>[]{#06.htm#pgfId-1110652}Subsequent running of the Podman commands joins
the namespaces of the <code>podman</code>{.fm-code-in-text}
<code>pause</code>{.fm-code-in-text} process[]{#06.htm#marker-1110653}. Podman does
this to avoid race conditions when user namespaces are coming up and
going down. The <code>pause</code>{.fm-code-in-text} process remains running until
you log out. You can also execute the <code>podman</code>{.fm-code-in-text}
<code>system</code>{.fm-code-in-text} <code>migrate</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110654} to remove it. The
<code>pause</code>{.fm-code-in-text} process&rsquo;s role is keeping the user namespace
alive, as all rootless containers must be run in the same user
namespace. If they were not, sharing content and other namespaces (like
sharing the network namespace from another container) is impossible.</p>
<p>[]{#06.htm#pgfId-1110655}[Note]{.fm-callout-head} I often have users
report that when changing the /etc/subuid and /etc/subgid files, their
containers don&rsquo;t reflect the changes right away. Since the pause process
was launched with the previous user namespace settings, it needs to be
removed. Executing the <code>podman</code>{.fm-code-in-text1}
<code>system</code>{.fm-code-in-text1} <code>migrate</code>{.fm-code-in-text1} command
restarts the pause process within the user namespace.</p>
<p>[]{#06.htm#pgfId-1110656}You can kill the <code>pause</code>{.fm-code-in-text}
process at any time, but Podman re-creates it on the next run. By
default each rootless user has their own user namespace, and all of
their containers run within the same user namespace. You can subdivide
the user namespace and run containers with different user namespaces,
but realize, by default, you only have 65,000 UIDs to work with. Running
multiple containers in different user namespaces is much easier to do
when running rootful containers. Now that the user namespace and mount
namespace are created, Podman creates storage for the container&rsquo;s image
and sets up a mount point to start storing the image.</p>
<h3 id="heading_id_6" class="fm-head1">[]{#06.htm#pgfId-1110658}6.2.1 Pulling the image</h3>
<p>[]{#06.htm#pgfId-1110668}When
[]{#06.htm#marker-1110665}[]{#06.htm#marker-1110666}[]{#06.htm#marker-1110667}pulling
the image (figure 6.5), Podman checks if the container image quay.io/
rhatdan/myimage exists in local container storage. If it does, Podman
sets up the container network (see section 6.2.3). However, if the
container image does not exist, Podman uses the containers/image library
to pull the image. Following are the steps Podman takes while pulling
the image:</p>
<ol>
<li>
<p>[]{#06.htm#pgfId-1110669 .calibre17}Resolve the IP address for the
registry: quay.io.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110670 .calibre17}Connect to the IP address via
the HTTPS port (<code>443</code>{.fm-code-in-text}).</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110671 .calibre17}Begin pulling the manifest, all
layers, and the config of the image using the HTTP protocol.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110672 .calibre17}Find the multiple layers or
blobs of quay.io/rhatdan/myimage.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110673 .calibre17}Copy all layers simultaneously
from the container registry to the host.</p>
</li>
</ol>
<p>::: figure
<a href="#R-image-f650729b63becada67778d05e47fcf32" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-05.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f650729b63becada67778d05e47fcf32"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-05.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115763}Figure 6.5 Podman pulls an image off a
container registry and stores it in the container storage.
:::</p>
<p>[]{#06.htm#marker-1110696}[]{#06.htm#pgfId-1110674}As each layer is
copied to the host, Podman uses the containers/storage library to
reassemble the layers in order, creating an overlay mount point for each
of them on top of the previous one in
~/.local/share/containers/storage. If there is no previous layer, it
creates the initial layer.</p>
<p>[]{#06.htm#pgfId-1110675}Next, containers/storage untars the contents of
the layer into the new storage layer. As the layers are untarred,
containers/storage <code>chown</code>{.fm-code-in-text}s the UID/GIDs of files in
the tarball into the home directory. Podman takes advantage of the user
namespace <code>CAP_CHOWN</code>{.fm-code-in-text}, as explained in previous
sections. Remember that Podman fails to create content if the UID or GID
specified in the TAR file was not mapped into the user
[]{#06.htm#marker-1110676}[]{#06.htm#marker-1110677}[]{#06.htm#marker-1110678}namespace.</p>
<h3 id="heading_id_7" class="fm-head1">[]{#06.htm#pgfId-1110680}6.2.2 Creating a container</h3>
<p>[]{#06.htm#pgfId-1110682}Once []{#06.htm#marker-1110681}the
containers/storage library finishes downloading the image and creating
the storage, Podman creates a new container based on the image. Podman
adds the container to Podman&rsquo;s internal database. It then tells
containers/storage to create writable space on disk and use the default
storage driver, usually <code>overlayfs</code>{.fm-code-in-text}, to mount this
space as a new container layer. The new container layer acts as the
final read/write layer and is mounted on top of the image.</p>
<p>[]{#06.htm#pgfId-1110683}[Note]{.fm-callout-head} Rootful containers
default to using native Linux overlay mounts. In rootless mode, kernel
versions newer than 5.13 or with the rootless overlay feature backported
(RHEL 8.5 kernels or later also have this feature) use the native
overlay mounts. On older kernels, Podman uses the
<code>fuse-overlayfs</code>{.fm-code-in-text1} executable[]{#06.htm#marker-1110684}
to create the layer. In Podman, <code>overlay</code>{.fm-code-in-text1} and
<code>overlay2</code>{.fm-code-in-text1} are the same drivers.</p>
<p>[]{#06.htm#pgfId-1110686}At this point, Podman needs to configure the
network inside the network []{#06.htm#marker-1110685}namespace.</p>
<h3 id="heading_id_8" class="fm-head1">[]{#06.htm#pgfId-1110688}6.2.3 Setting up the network</h3>
<p>[]{#06.htm#pgfId-1110697}In
[]{#06.htm#marker-1115791}[]{#06.htm#marker-1115792}rootless Podman, you
cannot create full, separate networking for containers because rootless
processes are not allowed to create network devices and modify the
firewall rules. Rootless Podman uses slirp4netns
(<a href="https://github.com/rootless-containers/slirp4netns" rel="external" target="_blank">https://github.com/rootless-containers/slirp4netns</a>{.url})
to configure the host network and simulate a VPN for the container.
Slirp4netns provides user-mode networking (slirp) for unprivileged
network namespaces. See figure 6.6.</p>
<p>::: figure
<a href="#R-image-fa466b98525edbe71f292f71ff9e971c" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-06.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fa466b98525edbe71f292f71ff9e971c"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-06.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115814}Figure 6.6 Podman creates a network namespace
and launches slirp4netns to relay network connections.
:::</p>
<p>[]{#06.htm#pgfId-1110698}[Note]{.fm-callout-head} In rootful containers,
Podman uses the CNI plugins to configure networking devices. In rootless
mode, even though the user is allowed to create and join a network
namespace, they are not allowed to create network devices. The
slirp4netns program emulates a virtual network to connect host
networking to the container networking. More advanced networking setups
require rootful containers.</p>
<p>[]{#06.htm#pgfId-1110699}Remember that in our original example, you
specified the <code>8080:8080</code>{.fm-code-in-text} port mapping as follows:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run -d -p 8080:8080 --name myapp 
     registry.access.redhat.com/ubi8/httpd-24</code></pre></div>
<p>[]{#06.htm#marker-1110731}[]{#06.htm#pgfId-1110701}Podman configures the
slirp4netns program to listen on the host network at port
<code>8080</code>{.fm-code-in-text} and allow the container process to bind to port
<code>8080</code>{.fm-code-in-text}. The slirp4netns command creates a tap device
that is injected inside the new network namespace, where the container
lives. Each packet is read back from slirp4netns and emulates a TCP/IP
stack in user space. Each connection outside the container network&rsquo;s
namespace is converted in a socket operation the unprivileged user can
run in the host network&rsquo;s namespace.</p>
<p>[]{#06.htm#pgfId-1110702}[Note]{.fm-callout-head} Linux TAP devices
create a user space network bridge. In user space, TAP devices can
simulate network devices inside of a network namespace. Processes within
the namespace interact with the network device. Packets read/written
from the network device are routed via the TUN/TAP device to the user
space program: slirp4netns.</p>
<p>[]{#06.htm#pgfId-1110703}Now that the storage and network are
configured, Podman is ready to finally start the container
[]{#06.htm#marker-1110704}[]{#06.htm#marker-1110705}process.</p>
<h3 id="heading_id_9" class="fm-head1">[]{#06.htm#pgfId-1110707}6.2.4 Starting the container monitor: conmon</h3>
<p>[]{#06.htm#pgfId-1110716}Podman
[]{#06.htm#marker-1110714}[]{#06.htm#marker-1110715}now executes conmon
(container monitor) for the container, telling it to use its configured
OCI runtime, usually <code>crun</code>{.fm-code-in-text}[]{#06.htm#marker-1110717}
or <code>runc</code>{.fm-code-in-text}[]{#06.htm#marker-1110718}. It also executes
the <code>podman</code>{.fm-code-in-text} <code>container</code>{.fm-code-in-text}
<code>cleanup</code>{.fm-code-in-text} <code>$CTRID</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110719} when the container exits (see figure
6.7). conmon is described in
[]{#06.htm#marker-1110720}[]{#06.htm#marker-1110721}section 4.1.</p>
<p>::: figure
<a href="#R-image-7e140d7f20a7e06ca95b70e5259ac2cd" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-07.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e140d7f20a7e06ca95b70e5259ac2cd"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-07.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1115852}Figure 6.7 Podman launches the container
monitor, which launches the OCI runtime.
:::</p>
<h3 id="heading_id_10" class="fm-head1">[]{#06.htm#pgfId-1110723}6.2.5 Launching the OCI runtime</h3>
<p>[]{#06.htm#pgfId-1110732}The
[]{#06.htm#marker-1115925}[]{#06.htm#marker-1115926}OCI runtime reads
the OCI spec file and configures the kernel to run the container (see
figure 6.8). OCI runtimes do the following:</p>
<ol>
<li>
<p>[]{#06.htm#pgfId-1110733 .calibre17}Set up the additional namespaces
for the container.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110734 .calibre17}Configure cgroups v2 (cgroups v1
is not supported for rootless containers).</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110735 .calibre17}Set up the SELinux label for
running the container.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110736 .calibre17}Load the
/usr/share/containers/seccomp.json seccomp rules into the kernel.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110737 .calibre17}Set the environment variables
for the container.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110738 .calibre17}Bind mount any volumes onto the
paths in the rootfs.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110739 .calibre17}Switch the current
<code>/</code>{.fm-code-in-text} to the rootfs <code>/</code>{.fm-code-in-text}.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110740 .calibre17}Fork the container process.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110741 .calibre17}Execute any OCI hook programs,
passing them the rootfs as well as the container&rsquo;s PID 1.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110742 .calibre17}Execute the command specified by
the image.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110743 .calibre17}Exit the OCI runtime, leaving
conmon to monitor the container.</p>
</li>
</ol>
<p>::: figure
<a href="#R-image-03f6c3140d3f5c6a104faa2a71e543cb" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-08.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-03f6c3140d3f5c6a104faa2a71e543cb"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-08.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1116007}Figure 6.8 conmon launches the OCI runtime,
which configures the kernel.
:::</p>
<p>[]{#06.htm#marker-1110753}[]{#06.htm#pgfId-1110744}And finally, conmon
reports the success back to Podman (see figure 6.9).</p>
<p>::: figure
<a href="#R-image-03ed23a467c42c9d6e55ac2860823dcb" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="images/OEBPS/Images/06-09.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-03ed23a467c42c9d6e55ac2860823dcb"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="images/OEBPS/Images/06-09.png"></a>{.calibre18}</p>
<p>[]{#06.htm#pgfId-1116045}Figure 6.9 Podman and OCI runtime exit, leaving
the container running with conmon monitoring it and slirp4netns
providing the network.
:::</p>
<p>[]{#06.htm#pgfId-1110754}The Podman command now exits because it ran in
<code>--detach</code>{.fm-code-in-text} (<code>-d</code>{.fm-code-in-text})
[]{#06.htm#marker-1115991}[]{#06.htm#marker-1115992}mode[]{#06.htm#marker-1115993}.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman run -d -p 8080:8080 --name myapp 
     registry.access.redhat.com/ubi8/httpd-24</code></pre></div>
<p>[]{#06.htm#pgfId-1110756}[Note]{.fm-callout-head} If later you want
Podman to interact with the detached container, use the
<code>podman</code>{.fm-code-in-text1} <code>attach</code>{.fm-code-in-text1}
command[]{#06.htm#marker-1110757}, which connects to the conmon socket.
conmon allows Podman to interact with the container process through the
<code>STDIN</code>{.fm-code-in-text1}[]{#06.htm#marker-1110758},
<code>STDOUT</code>{.fm-code-in-text1}[]{#06.htm#marker-1110759}, and
<code>STDERR</code>{.fm-code-in-text1} file descriptors[]{#06.htm#marker-1110760},
which conmon has been monitoring.</p>
<h3 id="heading_id_11" class="fm-head1">[]{#06.htm#pgfId-1110762}6.2.6 The containerized application runs until completion</h3>
<p>[]{#06.htm#pgfId-1110764}The []{#06.htm#marker-1110763}application
process can exit on its own, or you can stop the container by executing
the <code>podman</code>{.fm-code-in-text} <code>stop</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110765}:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-programlisting" data-lang="programlisting">$ podman stop myapp</code></pre></div>
<p>[]{#06.htm#pgfId-1110768}When the container process exits, the kernel
sends a <code>SIGCHLD</code>{.fm-code-in-text} to the <code>conmon</code>{.fm-code-in-text}
process[]{#06.htm#marker-1110767}. In turn, conmon does the following:</p>
<ol>
<li>
<p>[]{#06.htm#pgfId-1110769 .calibre17}Records the container&rsquo;s exit
code</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110770 .calibre17}Closes the container&rsquo;s logfile</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110771 .calibre17}Closes the Podman command&rsquo;s
<code>STDOUT</code>{.fm-code-in-text}/<code>STDERR</code>{.fm-code-in-text}</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110773 .calibre17}Executes the
<code>podman</code>{.fm-code-in-text} <code>container</code>{.fm-code-in-text}
<code>cleanup</code>{.fm-code-in-text} <code>$CTRID</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110772 .calibre17}</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110774 .calibre17}Exits itself</p>
</li>
</ol>
<p>[]{#06.htm#pgfId-1110776}The <code>podman</code>{.fm-code-in-text}
<code>container</code>{.fm-code-in-text} <code>cleanup</code>{.fm-code-in-text}
command[]{#06.htm#marker-1110775} takes down the slirp4netns network and
unmounts all of the container mount points. If you specify the
<code>--rm</code>{.fm-code-in-text} option[]{#06.htm#marker-1110777}, the container
is entirely removed&mdash;layers are removed from containers/storage, and
the container definition is removed from []{#06.htm#marker-1110778}the
DB.</p>
<h2 id="heading_id_12" class="fm-head">[]{#06.htm#pgfId-1110780}Summary</h2>
<ul>
<li>
<p>[]{#06.htm#pgfId-1110781 .calibre17}Running rootless containers is
more secure than running rootful containers.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110782 .calibre17}The user namespace gives
ordinary users the ability to manipulate more than one UID and is
key to running containers.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110783 .calibre17}The mount namespace allows
Podman to mount filesystems within the user namespace.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110784 .calibre17}Podman uses slirp4netns for
providing network access to containers.</p>
</li>
<li>
<p>[]{#06.htm#pgfId-1110786 .calibre17}Podman launches the
<code>conmon</code>{.fm-code-in-text} process to monitor the
[]{#06.htm#marker-1110785 .calibre17}container.</p>
</li>
</ul>
<p>[]{#p3.htm}</p>
<h2 id="part-3-advanced-topics">Part 3. Advanced topics</h2>
<p>[]{#p3.htm#pgfId-1016264}[I]{.fm-part-initial-cap}n part 3 of the book,
you learn about advanced ways you can use Podman. This part discusses
integrating Podman into your system and how Podman can work with other
tools and orchestrators.</p>
<p>[]{#p3.htm#pgfId-1016265}In chapter 7, I introduce systemd integration.
Podman was developed to fully integrate into the system and takes
advantage of the init system: systemd. Systemd can easily be run within
Podman containers, and this chapter shows you how. Podman, likewise, can
be run within systemd services and provides commands that allow you to
automatically create the service configuration files to make this
happen.</p>
<p>[]{#p3.htm#pgfId-1016266}Chapter 8 shows you how Podman works with
Kubernetes. Podman is not a container engine under Kubernetes but can
work with Kubernetes YAML files. Because Kubernetes YAML files are used
to define applications that run within Kubernetes, Podman makes it easy
to move applications to and from a fully orchestrated environment back
to a single node. This feature makes it easier for you to develop
applications that eventually run under Kubernetes or debug problems that
happen under Kubernetes by running these applications locally on your
laptop. Kubernetes YAML is a great alternative to
<code>docker-compose</code>{.fm-code-in-text} YAML when running a group of
containers on a single node.</p>
<p>[]{#p3.htm#pgfId-1016267}Chapter 9 introduces the concept of Podman as a
service, which allows tools written to use a RESTful API to generate and
manage pods and containers with Podman. Tools like
<code>docker-compose</code>{.fm-code-in-text} and other Python tools built on
docker-py can interface with the Podman service, eliminating the need
for Docker altogether. The Podman service even allows Podman running on
remote systems, such as Windows, macOS, and Linux, to work with Linux
Podman containers.[]{#p3.htm#id_u6n877dddx1z}</p>
<p>[]{#07.htm}</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation showVisitedLinks">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
<a href="https://perfectdarkmode.com">
  <img src="/images/V.svg" alt="perfectdarkmode.com" >
</a>

        </div>
        <script>
          window.index_js_url="/searchindex.en.js?1734871290";
        </script>
        <search><form action="/search/" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="/js/auto-complete.js?1734871290" defer></script>
        <script src="/js/lunr/lunr.min.js?1734871290" defer></script>
        <script src="/js/lunr/lunr.stemmer.support.min.js?1734871290" defer></script>
        <script src="/js/lunr/lunr.multi.min.js?1734871290" defer></script>
        <script src="/js/lunr/lunr.en.min.js?1734871290" defer></script>
        <script src="/js/search.js?1734871290" defer></script>
      </div>
      <div id="R-homelinks" class="default-animation">
        <hr class="padding">
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div id="R-shortcutmenu-home" class="R-sidebarmenu">
          <ul class="enlarge morespace collapsible-menu">
            <li class="" data-nav-id="/linux/"><input type="checkbox" id="R-section-e2509333b88222aa06f1b5fc60b020b2" aria-controls="R-subsections-e2509333b88222aa06f1b5fc60b020b2"><label for="R-section-e2509333b88222aa06f1b5fc60b020b2"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Linux</span></label><a class="padding" href="/linux/">Linux<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-e2509333b88222aa06f1b5fc60b020b2" class="collapsible-menu">
            <li class="" data-nav-id="/linux/rhcsa/rhcsa-notes/"><a class="padding" href="/linux/rhcsa/rhcsa-notes/"><i class='fa-fw fas fa-caret-right'></i> My RHCSA 9 Notes<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/linux/rhcsa/rhcsa-vagrant-lab-setup/"><a class="padding" href="/linux/rhcsa/rhcsa-vagrant-lab-setup/"><i class='fa-fw fas fa-caret-right'></i> RHCSA Vagrant Lab Setup<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="" data-nav-id="/networking/"><input type="checkbox" id="R-section-d7c3359b808d40df139a3bb9f9073483" aria-controls="R-subsections-d7c3359b808d40df139a3bb9f9073483"><label for="R-section-d7c3359b808d40df139a3bb9f9073483"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Networking</span></label><a class="padding" href="/networking/">Networking<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-d7c3359b808d40df139a3bb9f9073483" class="collapsible-menu">
            <li class="" data-nav-id="/networking/how-to-study-for-the-ccna-exam/"><a class="padding" href="/networking/how-to-study-for-the-ccna-exam/"><i class='fa-fw fas fa-caret-right'></i> How to Study for the CCNA Exam<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/networking/resources-for-passing-ccna/"><a class="padding" href="/networking/resources-for-passing-ccna/"><i class='fa-fw fas fa-caret-right'></i> Resources for Passing CCNA<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/networking/what-to-learn-after-ccna/"><a class="padding" href="/networking/what-to-learn-after-ccna/"><i class='fa-fw fas fa-caret-right'></i> What to Learn After CCNA<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="parent " data-nav-id="/tools/"><input type="checkbox" id="R-section-bf1399820dde3dd110e03ace4147ff86" aria-controls="R-subsections-bf1399820dde3dd110e03ace4147ff86" checked><label for="R-section-bf1399820dde3dd110e03ace4147ff86"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Tools</span></label><a class="padding" href="/tools/">Tools<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-bf1399820dde3dd110e03ace4147ff86" class="collapsible-menu">
            <li class="" data-nav-id="/tools/calibre-web-with-docker-and-nginx/"><a class="padding" href="/tools/calibre-web-with-docker-and-nginx/"><i class='fa-fw fas fa-caret-right'></i> Calibre Web with Docker and NGINX<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="active hidden " data-nav-id="/tools/podman/6-rootless-containers/"><a class="padding" href="/tools/podman/6-rootless-containers/"><i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/obsidian-site-setup/"><a class="padding" href="/tools/obsidian-site-setup/"><i class='fa-fw fas fa-caret-right'></i> Automatically Sync Obsidian to Hugo and Apache<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/how-to-build-a-website-with-hugo/"><a class="padding" href="/tools/how-to-build-a-website-with-hugo/"><i class='fa-fw fas fa-caret-right'></i> How to Build a Website with Hugo<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/process-bookfusion-highlights/"><a class="padding" href="/tools/process-bookfusion-highlights/"><i class='fa-fw fas fa-caret-right'></i> How to Process Bookfusion Highlights with Vim<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/how-to-set-up-hugo-relearn-theme/"><a class="padding" href="/tools/how-to-set-up-hugo-relearn-theme/"><i class='fa-fw fas fa-caret-right'></i> How to Set Up Hugo Relearn Theme<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/setting-up-a-self-hosted-nextcloud-server/"><a class="padding" href="/tools/setting-up-a-self-hosted-nextcloud-server/"><i class='fa-fw fas fa-caret-right'></i> Setting Up a Self-hosted NextCloud Server<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/tools/using-vagrant-on-linux/"><a class="padding" href="/tools/using-vagrant-on-linux/"><i class='fa-fw fas fa-caret-right'></i> Using Vagrant on Linux<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="" data-nav-id="/writing/"><input type="checkbox" id="R-section-e3d1318aa75db5bce0725e0a3ed7bb24" aria-controls="R-subsections-e3d1318aa75db5bce0725e0a3ed7bb24"><label for="R-section-e3d1318aa75db5bce0725e0a3ed7bb24"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Writing</span></label><a class="padding" href="/writing/">Writing<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-e3d1318aa75db5bce0725e0a3ed7bb24" class="collapsible-menu">
            <li class="" data-nav-id="/writing/19-biggest-lessons-from-reading-100-books./"><a class="padding" href="/writing/19-biggest-lessons-from-reading-100-books./"><i class='fa-fw fas fa-caret-right'></i> 19 Biggest Lessons from Reading 100 Books<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/writing/nat-eliasons-seo-course/"><a class="padding" href="/writing/nat-eliasons-seo-course/"><i class='fa-fw fas fa-caret-right'></i> Nat Eliason&#39;s SEO Course<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/writing/writing-off-the-cuff/"><a class="padding" href="/writing/writing-off-the-cuff/"><i class='fa-fw fas fa-caret-right'></i> Writing Off the Cuff<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="" data-nav-id="/philosophy/"><input type="checkbox" id="R-section-8c82ea449b1ed3a82ac9f4c033e6c771" aria-controls="R-subsections-8c82ea449b1ed3a82ac9f4c033e6c771"><label for="R-section-8c82ea449b1ed3a82ac9f4c033e6c771"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Philosophy</span></label><a class="padding" href="/philosophy/">Philosophy<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-8c82ea449b1ed3a82ac9f4c033e6c771" class="collapsible-menu">
            <li class="" data-nav-id="/philosophy/austerities/"><a class="padding" href="/philosophy/austerities/"><i class='fa-fw fas fa-caret-right'></i> Austerities<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/philosophy/the-journey/"><a class="padding" href="/philosophy/the-journey/"><i class='fa-fw fas fa-caret-right'></i> The Journey<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="" data-nav-id="/recipes/"><input type="checkbox" id="R-section-c577cf8a0811f0416711bbf6194eeea7" aria-controls="R-subsections-c577cf8a0811f0416711bbf6194eeea7"><label for="R-section-c577cf8a0811f0416711bbf6194eeea7"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Recipes</span></label><a class="padding" href="/recipes/">Recipes<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-c577cf8a0811f0416711bbf6194eeea7" class="collapsible-menu">
            <li class="" data-nav-id="/recipes/creamy-jalepeno-sauce/"><a class="padding" href="/recipes/creamy-jalepeno-sauce/"><i class='fa-fw fas fa-caret-right'></i> Creamy Jalepeno Sauce<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/recipes/easy-mango-salsa-quinoa-bowl/"><a class="padding" href="/recipes/easy-mango-salsa-quinoa-bowl/"><i class='fa-fw fas fa-caret-right'></i> Easy Mango Salsa Quinoa Bowl<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/recipes/tempeh-bacon/"><a class="padding" href="/recipes/tempeh-bacon/"><i class='fa-fw fas fa-caret-right'></i> Tempeh Bacon<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/recipes/vegan-tofu-quesadilla/"><a class="padding" href="/recipes/vegan-tofu-quesadilla/"><i class='fa-fw fas fa-caret-right'></i> Vegan Tofu Quesadilla<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/health-and-fitness/"><input type="checkbox" id="R-section-8ea26d41efde3afeda887278c69eb108" aria-controls="R-subsections-8ea26d41efde3afeda887278c69eb108" checked><label for="R-section-8ea26d41efde3afeda887278c69eb108"><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu Health and Fitnesses</span></label><a class="padding" href="/health-and-fitness/">Health and Fitnesses<i class="fa-fw fas fa-check read-icon"></i></a><ul id="R-subsections-8ea26d41efde3afeda887278c69eb108" class="collapsible-menu">
            <li class="" data-nav-id="/health-and-fitness/4-ways-to-quit-caffeine/"><a class="padding" href="/health-and-fitness/4-ways-to-quit-caffeine/"><i class='fa-fw fas fa-caret-right'></i> 4 Ways to Quit Caffeine<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/health-and-fitness/7-steps-to-get-back-on-a-nofap-streak-immediately/"><a class="padding" href="/health-and-fitness/7-steps-to-get-back-on-a-nofap-streak-immediately/"><i class='fa-fw fas fa-caret-right'></i> 7 Steps to Get Back on a NoFap Streak Immediately<i class="fa-fw fas fa-check read-icon"></i></a></li>
            <li class="" data-nav-id="/health-and-fitness/caffeine-is-destroying-you/"><a class="padding" href="/health-and-fitness/caffeine-is-destroying-you/"><i class='fa-fw fas fa-caret-right'></i> Caffeine is Destroying You<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li>
          </ul>
        </div>
        <div id="R-shortcutmenu-shortcuts" class="R-sidebarmenu">
          <div class="nav-title padding">More</div>
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="https://github.com/tdavetech"><a class="padding" href="https://github.com/tdavetech" target="_blank"><i class='fab fa-fw fa-github'></i> GitHub<i class="fa-fw fas fa-check read-icon"></i></a></li>
          </ul>
        </div>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"></div>
        <div id="R-menu-footer">
          <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter">
          <div id="R-prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVisitedLinks">
            <ul>
              <li id="R-select-language-container" class="footerLangSwitch">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-language"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-language">Language</label>
                    <select id="R-select-language" onchange="location = this.querySelector( this.value ).dataset.url;">
                      <option id="R-select-language-en" value="#R-select-language-en" data-url="/tools/podman/6-rootless-containers/" lang="en-us" selected></option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
              <li id="R-select-variant-container" class="footerVariantSwitch">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-paint-brush"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-variant">Theme</label>
                    <select id="R-select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                      <option id="R-select-variant-amoled" value="amoled" selected>Amoled</option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
                <script>window.variants && variants.markSelectedVariant();</script>
              </li>
              <li class="footerVisitedLinks showVisitedLinks">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-history"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <button onclick="clearHistory();">Clear History</button>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
            </ul>
          </div>
          <div id="R-footer" class="footerFooter showFooter">
        <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
          </div>
        </div>
      </div>
    </aside>
    <script src="/js/clipboard.min.js?1734871290" defer></script>
    <script src="/js/perfect-scrollbar.min.js?1734871290" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/js/d3/d3-color.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-dispatch.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-drag.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-ease.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-interpolate.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-selection.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-timer.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-transition.min.js?1734871290" defer></script>
    <script src="/js/d3/d3-zoom.min.js?1734871290" defer></script>
    <script src="/js/js-yaml.min.js?1734871290" defer></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js" defer></script>
    <script>
      window.themeUseMermaid = JSON.parse("{ \"theme\": \"default\" }");
    </script>
    <script src="/js/theme.js?1734871290" defer></script>
  </body>
</html>
